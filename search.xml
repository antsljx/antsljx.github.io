<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[本地存储]]></title>
      <url>%2F2016%2F05%2F10%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[html5几种存储形式 本地存储（localStorage &amp;&amp; sessionStorage） 离线缓存（application cache） indexedDB 和 webSQL localStorage与sessionStorage区别及特点过期时间：localStorage 永久存储，永不失效除非手动删除 sessionStorage 浏览器重新打开后就消失了 大小：每个域名是5M localStorage API和sessionStorage API一致 getItem //取记录 setIten//设置记录 removeItem//移除记录 key//取key所对应的值 clear//清除记录 存储的内容： 数组，图片，json，样式，脚本…… localStorage实例12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE&gt; &lt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta http-equiv="Access-Control-Allow-Origin" content="anonymous"&gt; &lt;title&gt;locstorage 图片存储&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var src='images/1.png';//这里一定要在服务器上运行，图片要是当前服务器的图片！ function set(key)&#123; var img = document.createElement('img');//创建图片元素 img.addEventListener('load',function()&#123;//绑定加载时间 var imgcavens = document.createElement('canvas'); imgcontent = imgcavens.getContext('2d'); imgcavens.width = this.width;//设置画布大小为图片本身的大小 imgcavens.height = this.height; imgcontent.drawImage(this,0,0,this.width,this.height); var imgAsDataUrl = imgcavens.toDataURL('image/png');//这个方法一定要在服务器上运行/*对图像数据做出修改以后，可以使用toDataURL方法，将Canvas数据重新转化成一般的图像文件形式。function convertCanvasToImage(canvas) &#123; var image = new Image(); image.src = canvas.toDataURL("image/png"); return image;&#125;上面的代码将Canvas数据，转化成PNG data URI。*/ try&#123; localStorage.setItem(key,imgAsDataUrl);//保存图片地址 &#125;catch(e) &#123; console.log("storageFaild: "+e);//错误信息 &#125; &#125;,false) img.src = src;//指定需要存储的图片地址 &#125; function get(key)&#123; var srcStr = localStorage.getItem(key);//获取本地存储的元素 var imgobj = document.createElement('img'); imgobj.src = srcStr;//指定图片路径 document.body.appendChild(imgobj);//在页面中添加元素 &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以通过调试在资源管理器中进行分析 由于html5没有给本地存储设置过期策略，那么在处理图片的过期策略的时候可以编写自己过期策略程序，如下：12345678910111213141516171819202122232425262728&lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta http-equiv="Access-Control-Allow-Origin" content="anonymous"&gt; &lt;title&gt;locstorage 过期策略&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function set(key,value)&#123; var curtime = new Date().getTime();//获取当前时间 localStorage.setItem(key,JSON.stringify(&#123;val:value,time:curtime&#125;));//转换成json字符串序列 /* 说明： JSON.parse用于从一个字符串中解析出json对象,如 var str = '&#123;"name":"huangxiaojian","age":"23"&#125;' 结果： JSON.parse(str) Object age: "23" name: "huangxiaojian" __proto__: Object 注意：单引号写在&#123;&#125;外，每个属性名都必须用双引号，否则会抛出异常。 JSON.stringify()用于从一个对象解析出字符串，如 var a = &#123;a:1,b:2&#125; 结果： JSON.stringify(a) "&#123;"a":1,"b":2&#125;" */&#125; function get(key,exp)//exp是设置的过期时间 &#123; var val = localStorage.getItem(key);//获取存储的元素 var dataobj = JSON.parse(val);//解析出json对象 if(new Date().getTime() - dataobj.time &gt; exp)//如果当前时间-减去存储的元素在创建时候设置的时间 &gt; 过期时间 &#123; console.log("expires");//提示过期 &#125; else&#123; console.log("val="+dataobj.val); &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[盒子模型及box-sizing属性]]></title>
      <url>%2F2016%2F04%2F22%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%8F%8Abox-sizing%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[盒子模型及box-sizing属性html中的每个dom元素都被描述为矩形的盒子。渲染引擎的目的是判断大小，属性（颜色，背景，边框，边距，位置等信息）。在css中，这些盒子用标准的盒模型来描述。这个模型描述了一个元素所占用的空间。每一个盒子有四条边界，分别是：外边距边界（margin）、边框边界（border）、内边距边界（padding）和内容边界（content） 盒模型盒模型主要分为两种：IE盒模型与标准盒模型 确切的说IE盒模型仅是在IE8以下的情况 在W3C模型中: 总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right 在IE模型中: 总宽度 = margin-left + width + margin-right 在CSS3中引入了box-sizing属性, 它可以允许改变默认的CSS盒模型对元素宽高的计算方式. 共包括两个选项： content-box：标准盒模型，CSS定义的宽高只包含content的宽高(默认) border-box：IE盒模型，CSS定义的宽高包括了content，padding和border 共包括两个选项： content-box：标准盒模型，CSS定义的宽高只包含content的宽高(默认) border-box：IE盒模型，CSS定义的宽高包括了content，padding和border12345678910111213&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .con&#123;width: 100px; height: 100px;background-color:royalblue; border:1px solid red; padding: 10px;&#125; .con1&#123;box-sizing: border-box;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="con"&gt;&lt;/div&gt; &lt;div class="con con1"&gt;&lt;/div&gt; &lt;/body&gt; 通过调试可以一目了然box-sizing两个值得区别。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[md5加密]]></title>
      <url>%2F2016%2F04%2F10%2Fmd5%E5%8A%A0%E5%AF%86%2F</url>
      <content type="text"><![CDATA[md5.js 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212var hexcase = 0; /* hex output format. 0 - lowercase; 1 - uppercase */var b64pad = ""; /* base-64 pad character. "=" for strict RFC compliance */var chrsz = 8; /* bits per input character. 8 - ASCII; 16 - Unicode */function ants_md5(s)&#123; return binl2hex(core_md5(str2binl(s), s.length * chrsz));&#125;function b64_md5(s)&#123; return binl2b64(core_md5(str2binl(s), s.length * chrsz));&#125;function str_md5(s)&#123; return binl2str(core_md5(str2binl(s), s.length * chrsz));&#125;function hex_hmac_md5(key, data) &#123; return binl2hex(core_hmac_md5(key, data)); &#125;function b64_hmac_md5(key, data) &#123; return binl2b64(core_hmac_md5(key, data)); &#125;function str_hmac_md5(key, data) &#123; return binl2str(core_hmac_md5(key, data)); &#125;function md5_vm_test()&#123; return ants_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";&#125;function core_md5(x, len)&#123; /* append padding */ x[len &gt;&gt; 5] |= 0x80 &lt;&lt; ((len) % 32); x[(((len + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = len; var a = 1732584193; var b = -271733879; var c = -1732584194; var d = 271733878; for(var i = 0; i &lt; x.length; i += 16) &#123; var olda = a; var oldb = b; var oldc = c; var oldd = d; a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936); d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586); c = md5_ff(c, d, a, b, x[i+ 2], 17, 606105819); b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330); a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897); d = md5_ff(d, a, b, c, x[i+ 5], 12, 1200080426); c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341); b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983); a = md5_ff(a, b, c, d, x[i+ 8], 7 , 1770035416); d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417); c = md5_ff(c, d, a, b, x[i+10], 17, -42063); b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162); a = md5_ff(a, b, c, d, x[i+12], 7 , 1804603682); d = md5_ff(d, a, b, c, x[i+13], 12, -40341101); c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290); b = md5_ff(b, c, d, a, x[i+15], 22, 1236535329); a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510); d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632); c = md5_gg(c, d, a, b, x[i+11], 14, 643717713); b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302); a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691); d = md5_gg(d, a, b, c, x[i+10], 9 , 38016083); c = md5_gg(c, d, a, b, x[i+15], 14, -660478335); b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848); a = md5_gg(a, b, c, d, x[i+ 9], 5 , 568446438); d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690); c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961); b = md5_gg(b, c, d, a, x[i+ 8], 20, 1163531501); a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467); d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784); c = md5_gg(c, d, a, b, x[i+ 7], 14, 1735328473); b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734); a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558); d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463); c = md5_hh(c, d, a, b, x[i+11], 16, 1839030562); b = md5_hh(b, c, d, a, x[i+14], 23, -35309556); a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060); d = md5_hh(d, a, b, c, x[i+ 4], 11, 1272893353); c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632); b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640); a = md5_hh(a, b, c, d, x[i+13], 4 , 681279174); d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222); c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979); b = md5_hh(b, c, d, a, x[i+ 6], 23, 76029189); a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487); d = md5_hh(d, a, b, c, x[i+12], 11, -421815835); c = md5_hh(c, d, a, b, x[i+15], 16, 530742520); b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651); a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844); d = md5_ii(d, a, b, c, x[i+ 7], 10, 1126891415); c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905); b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055); a = md5_ii(a, b, c, d, x[i+12], 6 , 1700485571); d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606); c = md5_ii(c, d, a, b, x[i+10], 15, -1051523); b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799); a = md5_ii(a, b, c, d, x[i+ 8], 6 , 1873313359); d = md5_ii(d, a, b, c, x[i+15], 10, -30611744); c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380); b = md5_ii(b, c, d, a, x[i+13], 21, 1309151649); a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070); d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379); c = md5_ii(c, d, a, b, x[i+ 2], 15, 718787259); b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551); a = safe_add(a, olda); b = safe_add(b, oldb); c = safe_add(c, oldc); d = safe_add(d, oldd); &#125; return Array(a, b, c, d);&#125;/* * These functions implement the four basic operations the algorithm uses. */function md5_cmn(q, a, b, x, s, t)&#123; return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#125;function md5_ff(a, b, c, d, x, s, t)&#123; return md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#125;function md5_gg(a, b, c, d, x, s, t)&#123; return md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#125;function md5_hh(a, b, c, d, x, s, t)&#123; return md5_cmn(b ^ c ^ d, a, b, x, s, t);&#125;function md5_ii(a, b, c, d, x, s, t)&#123; return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#125;/* * Calculate the HMAC-MD5, of a key and some data */function core_hmac_md5(key, data)&#123; var bkey = str2binl(key); if(bkey.length &gt; 16) bkey = core_md5(bkey, key.length * chrsz); var ipad = Array(16), opad = Array(16); for(var i = 0; i &lt; 16; i++) &#123; ipad[i] = bkey[i] ^ 0x36363636; opad[i] = bkey[i] ^ 0x5C5C5C5C; &#125; var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz); return core_md5(opad.concat(hash), 512 + 128);&#125;/* * Add integers, wrapping at 2^32. This uses 16-bit operations internally * to work around bugs in some JS interpreters. */function safe_add(x, y)&#123; var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF); var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16); return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#125;/* * Bitwise rotate a 32-bit number to the left. */function bit_rol(num, cnt)&#123; return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));&#125;/* * Convert a string to an array of little-endian words * If chrsz is ASCII, characters &gt;255 have their hi-byte silently ignored. */function str2binl(str)&#123; var bin = Array(); var mask = (1 &lt;&lt; chrsz) - 1; for(var i = 0; i &lt; str.length * chrsz; i += chrsz) bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (i%32); return bin;&#125;/* * Convert an array of little-endian words to a string */function binl2str(bin)&#123; var str = ""; var mask = (1 &lt;&lt; chrsz) - 1; for(var i = 0; i &lt; bin.length * 32; i += chrsz) str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (i % 32)) &amp; mask); return str;&#125;/* * Convert an array of little-endian words to a hex string. */function binl2hex(binarray)&#123; var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef"; var str = ""; for(var i = 0; i &lt; binarray.length * 4; i++) &#123; str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8+4)) &amp; 0xF) + hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8 )) &amp; 0xF); &#125; return str;&#125;/* * Convert an array of little-endian words to a base-64 string */function binl2b64(binarray)&#123; var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; var str = ""; for(var i = 0; i &lt; binarray.length * 4; i += 3) &#123; var triplet = (((binarray[i &gt;&gt; 2] &gt;&gt; 8 * ( i %4)) &amp; 0xFF) &lt;&lt; 16) | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * ((i+1)%4)) &amp; 0xFF) &lt;&lt; 8 ) | ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * ((i+2)%4)) &amp; 0xFF); for(var j = 0; j &lt; 4; j++) &#123; if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad; else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F); &#125; &#125; return str;&#125; demo代码123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;md5加密demo&lt;/title&gt;&lt;/head&gt;&lt;script src="md5.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; var timestamp = Math.round(new Date().getTime()/1000);//得到个时间戳进行加密，一般加密的时候都会通过时间戳与要加密的内容结合加密 var sign = ants_md5(timestamp); //调用加密代码 ants是与md5.js中对应的 可以对应一起改变 console.log(sign) //打印md5加密后的内容&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node-webkit把web应用打包成桌面应用]]></title>
      <url>%2F2016%2F03%2F20%2Fnode-webkit%2F</url>
      <content type="text"><![CDATA[用node-webkit把web应用打包成桌面应用node-webkit是一个Chromium和node.js上的结合体，通过它我们可以把建立在chrome浏览器和node.js上的web应用打包成桌面应用，而且还可以跨平台。很显然比起传统的桌面应用，在某些特定领域用html5+css3+js开发的web应用更加简单和高效，而且还可以使用node.js的功能，所以node-webkit还是很有用处的。下面通过一个简单的demo来说明一下（这里只介绍windows环境） 1、首先新建一个index.html文件，作为我们这个demo的入口页面，我们暂且就把这个页面当成一个完整的web应用吧。内容随便写点什么：12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;node-webkite hello word&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 2、创建配置文件 package.json,最简单的参数配置如下：1234&#123; &quot;name&quot;: &quot;demo&quot;, &quot;main&quot;: &quot;index.html&quot;&#125; 也可以根据需要配置一些其他的参数如下（仅作为参考，无需写在demo）：1234567891011121314151617181920212223&#123; "main": "index.html", "name": "nw-demo", "description": "demo app of node-webkit", "version": "0.1.0", "keywords": [ "demo", "node-webkit" ], "window": &#123; "title": "node-webkit demo", "icon": "link.png", "toolbar": true, "frame": false, "width": 800, "height": 500, "position": "mouse", "min_width": 400, "min_height": 200, "max_width": 800, "max_height": 600 &#125;, "webkit": &#123; "plugin": true &#125;&#125; 3.创建 .nw 文件1234把index.html和package.json压缩在一个文件里*确保两个文件都在根目录下把压缩文件后缀改成 .nw此demo命名为 app.nw 4.下载windows版本的node-webkit,解压后得到一个文件夹：5.用nw.exe来执行app.nw,直接把app.nw拖到nw.exe上就可以执行了。12345因为nw文件的运行需要node-webkit环境的支持，所以我们还需要把app.nw这个文件跟node-webkit的环境文件一起打包成一个可执行文件。首先打开windows的cmd,然后输入如下命令：cd 文件所在目录copy /b nw.exe+app.nw app.exe执行命令后我们得到了 app.exe 这个可执行文件。 6.删除无用的文件只保留 app.exe，appboxed.exe，ffmpegsumo.dll，icudtl.dat ，libEGL.dll，libGLESv2.dll，nw.pak 这七个文件即可 执行app.exe就可以运行我们的demo了 1234已经得到了app.exe这个文件，但如果只有app.exe这个文件还是不够的，这个可执行文件的运行还需要几个dll文件的支持。其中 nw.pak 与 icudt.dll 这个两个文件是必须要的。ffmpegsumo.dll 文件是媒体支持文件，如果你的html页面中用到了&lt;video&gt;或&lt;audio&gt;或其它与媒体相关的东西，则必须带上这个文件。libEGL.dll 和 libGLESv2.dll 这个两个文件则是使用webGL或GPU必须要的 但我们大多数人想的是给用户一个exe文件，用户就可以使用了，不用再附带一些其他文件。嗯，所以我们还可以把app.exe跟其他的文件再打包一次，把上图中的所有文件变成一个可执行文件，用户只要得到这个文件，就能运行我们的应用了。做这步我们需要一个软件叫Enigma Virtual Box。 首先下载和安装这个软件。 然后打开它。在Enter Input File Name那里输入我们的app.exe的路径，在Enter Output File Name那里填写我们要把打包出来的可执行文件输出到哪里。最后是把除app.exe外的其它文件拖入到Files那里，遇到提示的话默认就可以了 node-webkit虽然方便，但有个很大的缺点是得到的可执行文件有点大，衡量利弊后决定使不使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Less封装flex布局常用方法及小工具]]></title>
      <url>%2F2016%2F03%2F14%2FLess%E5%B0%81%E8%A3%85flex%E5%B8%83%E5%B1%80%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[Less封装flex布局常用方法及小工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//flex 布局.flex-main()&#123; width: 100%; display: inline-flex; display: flex; display: -ms-flexbox; display: -webkit-flex; display: -moz-box; position: relative;&#125;//宽度100% 垂直居中 自左到右 不换行.flex-nomal()&#123; .flex-main; align-items: center; -webkit-align-items: center; -moz-align-items: center;&#125;//宽度100% 垂直居中 两端对齐 不换行.flex-between()&#123; .flex-nomal; justify-content: space-between; -webkit-justify-content: space-between; -moz-justify-content: space-between; align-items: center; -webkit-align-items: center; -moz-align-items: center;&#125;//宽度100% 垂直居中 右对齐 不换行.flex-end()&#123; .flex-nomal; justify-content: flex-end; -webkit-justify-content: flex-end; -moz-justify-content: flex-end; align-items: center; -webkit-align-items: center; -moz-align-items: center;&#125;//宽度100% 垂直居中 两端有空隙对齐 不换行.flex-around()&#123; .flex-between; justify-content: space-around; -webkit-justify-content: space-around; -moz-justify-content: space-around;&#125;//宽度100% 垂直居中 两端对齐 换行.flex-wrap()&#123; .flex-between; flex-wrap: wrap; -webkit-flex-wrap: wrap; -moz-flex-wrap: wrap;&#125;//宽度100% 垂直居中 两端有空隙对齐 换行.flex-wrap()&#123; .flex-around; flex-wrap: wrap; -webkit-flex-wrap: wrap; -moz-flex-wrap: wrap;&#125;//垂直 靠左.flex-colum()&#123; .flex-main; flex-direction: column; -webkit-flex-direction: column; -moz-flex-direction: column;&#125;//垂直排列 水平居中.flex-colum_c()&#123; .flex-colum; align-items: center; -webkit-align-items: center; -moz-align-items: center;&#125;//垂直排列 水平居中 垂直居中c.flex-colum_cc()&#123; .flex-colum_c; justify-content: space-between; -webkit-justify-content: space-between; -moz-justify-content: space-between;&#125;//垂直排列 水平靠左 垂直居中c.flex_colum_l()&#123; .flex_colum; align-items: flex-start; -webkit-align-items: flex-start; -moz-align-items: flex-start;&#125;三个常用小方法//图片自适应.img_free()&#123; width: 100%; max-width: 100%; display: block;&#125;//文字省略号.font_over()&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;//不能选择复制.noselect&#123; -moz-user-select: none; -khtml-user-select: none; user-select: none;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[less 入门笔记]]></title>
      <url>%2F2016%2F03%2F06%2Fless%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[什么是LessLess是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。 LessCss可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。 变量变量允许我们单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。 1234567891011121314151617//less 源码 @color: #4D926F; #header &#123; color: @color; &#125; h2 &#123; color: @color; &#125; //编译后的CSS： #header &#123; color: #4D926F; &#125; h2 &#123; color: #4D926F; &#125; 混合（Mixins）混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。 1234567891011121314151617181920212223242526272829//LESS源码： .rounded-corners (@radius: 5px) &#123; -webkit-border-radius: @radius; -moz-border-radius: @radius; -ms-border-radius: @radius; -o-border-radius: @radius; border-radius: @radius; &#125; #header &#123; .rounded-corners; &#125; #footer &#123; .rounded-corners(10px); &#125;//编译后的CSS： #header &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; &#125; #footer &#123; -webkit-border-radius: 10px; -moz-border-radius: 10px; -ms-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px; &#125; 嵌套我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。 123456789101112131415161718192021222324252627282930//LESS源码： #header &#123; h1 &#123; font-size: 26px; font-weight: bold; &#125; p &#123; font-size: 12px; a &#123; text-decoration: none; &amp;:hover &#123; border-width: 1px &#125; &#125; &#125; &#125;//编译后的CSS： #header h1 &#123; font-size: 26px; font-weight: bold; &#125; #header p &#123; font-size: 12px; &#125; #header p a &#123; text-decoration: none; &#125; #header p a:hover &#123; border-width: 1px; &#125; 函数和运算运算提供了加，减，乘，除操作；我们可以做属性值和颜色的运算，这样就可以实现属性值之间的复杂关系。LESS中的函数一一映射了JavaScript代码，如果你愿意的话可以操作属性值。 1234567891011121314151617181920212223//LESS源码： @the-border: 1px; @base-color: #111; @red: #842210; #header &#123; color: (@base-color * 3); border-left: @the-border; border-right: (@the-border * 2); &#125; #footer &#123; color: (@base-color + #003300); border-color: desaturate(@red, 10%); &#125;//编译后的CSS： #header &#123; color: #333; border-left: 1px; border-right: 2px; &#125; #footer &#123; color: #114411; border-color: #7d2717; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用宽度高度]]></title>
      <url>%2F2016%2F02%2F13%2F%E5%B8%B8%E7%94%A8%E5%AE%BD%E5%BA%A6%E9%AB%98%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[常见的基本宽高数据网页可见区域宽1document.body.clientWidth; 网页可见区域高1document.body.clientHeight; 网页正文全文宽1document.body.scrollWidth; 网页正文全文高1document.body.scrollHeight; 网页被卷去的高1document.body.scrollTop; 网页被卷去的左1document.body.scrollLeft; 网页正文部分上1window.screenTop; 网页正文部分左1window.screenLeft; 屏幕分辨率的高1window.screen.height; 屏幕分辨率的宽1window.screen.width; 屏幕可用工作区高度：1window.screen.availHeight; 屏幕可用工作区宽度：1window.screen.availWidth; 屏幕可用工作区高度1window.screen.availHeight; 屏幕可用工作区宽度1window.screen.availWidth; 常用基本数据获取方法scrollHeight: 获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置event.clientX 相对文档的水平座标event.clientY 相对文档的垂直座标event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标document.documentElement.scrollTop 垂直方向滚动的值event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量12345678910要获取当前页面的滚动条纵坐标位置，用：document.documentElement.scrollTop;而不是：document.body.scrollTop;documentElement 对应的是 html 标签，而 body 对应的是 body 标签。在标准w3c下，document.body.scrollTop恒为0，需要用document.documentElement.scrollTop来代替;如果你想定位鼠标相对于页面的绝对位置时，你会发现google里面1000篇文章里面有999.99篇会让你使用 event.clientX+document.body.scrollLeft，event.clientY+document.body.scrollTop， 如果你发现你的鼠标定位偏离了你的想象，请不要奇怪，这是再正常不过的事情。ie5.5之后已经不支持document.body.scrollX对象了。 常用方法一般在开发的时候加上下面这段代码12345678910 if (document.body &amp;&amp; document.body.scrollTop &amp;&amp; document.body.scrollLeft)&#123;top=document.body.scrollTop;left=document.body.scrollleft; &#125;if (document.documentElement &amp;&amp; document.documentElement.scrollTop &amp;&amp; document.documentElement.scrollLeft)&#123;top=document.documentElement.scrollTop;left=document.documentElement.scrollLeft;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有趣的css图形]]></title>
      <url>%2F2016%2F01%2F31%2F%E6%9C%89%E8%B6%A3%E7%9A%84css%E5%9B%BE%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[1.圆形12345#circle&#123; width: 150px; height: 150px; border-radius: 50%; background-color: #232323;&#125; 2.椭圆形12345#elipse&#123; width: 200px; height: 100px; border-radius: 50%; background-color: #232323;&#125; 3.三角形123456#triangle&#123; width: 0; height: 0; border-left: 100px solid transparent; border-right: 100px solid transparent; border-bottom: 150px solid #232323;&#125; 4.平行四边形1234567#parallelogram&#123; width: 200px; height: 100px; background: #232323; -webkit-transform: skew(-45deg); -moz-transform: skew(-45deg); -o-transform: skew(-45deg); transform: skew(-45deg);&#125; 5.梯形1234567#trapezoid&#123; width: 100px; height: 0; border-bottom: 100px solid #232323; border-left: 50px solid transparent; border-right: 50px solid transparent;&#125; 6.六角星123456789101112131415161718#six-star&#123; width: 0; height: 0; position: relative; border-bottom: 100px solid #232323; border-left: 50px solid transparent; border-right: 50px solid transparent;&#125;#six-star:after&#123; content: ""; width: 0; height: 0; position: absolute; left: -50px; top: 35px; border-top: 100px solid #232323; border-left: 50px solid transparent; border-right: 50px solid transparent;&#125; 7.五角星12345678910111213141516171819202122232425262728293031323334#five-star&#123; width: 0px; height: 0px; margin: 50px 0; position: relative; display: block; color: #232323; border-right: 100px solid transparent; border-bottom: 70px solid #232323; border-left:100px solid transparent; -moz-transform:rotate(35deg); -webkit-transform: rotate(35deg); -ms-transform:rotate(35deg); -o-transform:rotate(35deg);&#125;#five-star:before&#123; border-bottom: 80px solid #232323;; border-left: 30px solid transparent; border-right: 30px solid transparent; position: absolute; height: 0; width: 0; top: -45px; left: -63px; display: block; content: ''; -webkit-transform: rotate(-35deg); -moz-transform:rotate(-35deg); -ms-transform:rotate(-35deg); -o-transform:rotate(-35deg);&#125;#five-star:after&#123; position: absolute; display: block; color: #232323; top: 3px; left: -105px; width: 0px; height: 0px; border-right: 100px solid transparent; border-bottom: 70px solid #232323; border-left: 100px solid transparent; -webkit-transform: rotate(-70deg); -moz-transform:rotate(-70deg); -ms-transform:rotate(-70deg); -o-transform:rotate(-70deg); content: '';&#125; 8.十二角星123456789101112131415161718192021222324252627282930#burst-12 &#123; background: red; width: 80px; height: 80px; position: relative; text-align: center; &#125; #burst-12:before, #burst-12:after &#123; content: ""; position: absolute; top: 0; left: 0; height: 80px; width: 80px; background: red; &#125; #burst-12:before &#123; -webkit-transform: rotate(30deg); -moz-transform: rotate(30deg); -ms-transform: rotate(30deg); -o-transform: rotate(30deg); transform: rotate(30deg); &#125; #burst-12:after &#123; -webkit-transform: rotate(60deg); -moz-transform: rotate(60deg); -ms-transform: rotate(60deg); -o-transform: rotate(60deg); transform: rotate(60deg); &#125; 9.八角星1234567891011121314151617181920212223242526#burst-8 &#123; background: red; width: 80px; height: 80px; position: relative; text-align: center; -webkit-transform: rotate(20deg); -moz-transform: rotate(20deg); -ms-transform: rotate(20deg); -o-transform: rotate(20eg); transform: rotate(20deg); &#125; #burst-8:before &#123; content: ""; position: absolute; top: 0; left: 0; height: 80px; width: 80px; background: red; -webkit-transform: rotate(135deg); -moz-transform: rotate(135deg); -ms-transform: rotate(135deg); -o-transform: rotate(135deg); transform: rotate(135deg); &#125; 10.五边形123456789101112131415#pentagon &#123; position: relative; width: 54px; border-width: 50px 18px 0; border-style: solid; border-color: #232323 transparent;&#125;#pentagon:before &#123; content: ""; position: absolute; height: 0; width: 0; top: -85px; left: -18px; border-width: 0 45px 35px; border-style: solid; border-color: transparent transparent #232323;&#125; 11.六边形123456789101112131415161718192021222324#hexagon &#123; width: 100px; height: 55px; background: #232323; position: relative;&#125;#hexagon:before &#123; content: ""; position: absolute; top: -25px; left: 0; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 25px solid #232323; &#125;#hexagon:after &#123; content: ""; position: absolute; bottom: -25px; left: 0; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 25px solid #232323; &#125; 12.爱心12345678910111213141516171819202122232425262728293031323334353637383940#heart &#123; position: relative; width: 100px; height: 90px; &#125; #heart:before, #heart:after &#123; position: absolute; content: ""; left: 50px; top: 0; width: 50px; height: 80px; background: red; -moz-border-radius: 50px 50px 0 0; border-radius: 50px 50px 0 0; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -ms-transform-origin: 0 100%; -o-transform-origin: 0 100%; transform-origin: 0 100%; &#125; #heart:after &#123; left: 0; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); -webkit-transform-origin: 100% 100%; -moz-transform-origin: 100% 100%; -ms-transform-origin: 100% 100%; -o-transform-origin: 100% 100%; transform-origin :100% 100%; &#125; 13.无穷大符号123456789101112131415161718192021222324252627282930313233#infinity &#123; position: relative; width: 212px; height: 100px; &#125; #infinity:before, #infinity:after &#123; content: ""; position: absolute; top: 0; left: 0; width: 60px; height: 60px; border: 20px solid red; -moz-border-radius: 50px 50px 0 50px; border-radius: 50px 50px 0 50px; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); &#125; #infinity:after &#123; left: auto; right: 0; -moz-border-radius: 50px 50px 50px 0; border-radius: 50px 50px 50px 0; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); &#125; 14.鸡蛋12345678#egg &#123; display:block; width: 126px; height: 180px; background-color: red; -webkit-border-radius: 63px 63px 63px 63px / 108px 108px 72px 72px; border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; &#125; 15.食逗人（Pac-Man）123456789101112#pacman &#123; width: 0px; height: 0px; border-right: 60px solid transparent; border-top: 60px solid red; border-left: 60px solid red; border-bottom: 60px solid red; border-top-left-radius: 60px; border-top-right-radius: 60px; border-bottom-left-radius: 60px; border-bottom-right-radius: 60px; &#125; 16.提示对话框1234567891011121314151617181920#talkbubble &#123; width: 120px; height: 80px; background: red; position: relative; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; &#125; #talkbubble:before &#123; content:""; position: absolute; right: 100%; top: 26px; width: 0; height: 0; border-top: 13px solid transparent; border-right: 26px solid red; border-bottom: 13px solid transparent; &#125; 17.钻石1234567891011121314151617181920#cut-diamond &#123; border-style: solid; border-color: transparent transparent red transparent; border-width: 0 25px 25px 25px; height: 0; width: 50px; position: relative; margin: 20px 0 50px 0; &#125; #cut-diamond:after &#123; content: ""; position: absolute; top: 25px; left: -25px; width: 0; height: 0; border-style: solid; border-color: red transparent transparent transparent; border-width: 70px 50px 0 50px; &#125; 18.阴阳八卦（霸气的这个）1234567891011121314151617181920212223242526272829303132#yin-yang &#123; width: 96px; height: 48px; background: #eee; border-color: red; border-style: solid; border-width: 2px 2px 50px 2px; border-radius: 100%; position: relative; &#125; #yin-yang:before &#123; content: ""; position: absolute; top: 50%; left: 0; background: #eee; border: 18px solid red; border-radius: 100%; width: 12px; height: 12px; &#125; #yin-yang:after &#123; content: ""; position: absolute; top: 50%; left: 50%; background: red; border: 18px solid #eee; border-radius:100%; width: 12px; height: 12px; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片转换为base64]]></title>
      <url>%2F2016%2F01%2F19%2F%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BAbase64%E7%9A%84demo%2F</url>
      <content type="text"><![CDATA[base64编码介绍base64是一种网络上常用的8bit字节代码的编码方式，base64可以用于http环境下传递较长的标识信息，同时可以放在url当中使用，因为base64不惧可读性，所以具有一定的 加密 功能。 为什么要把图片转换成base64编码？将图片转换成base64代码可以减少http请求，因为图片可以以字符编码的形式直接传递到客户端，而文件形式都需要进行http请求。但是也会有一个小缺点，就是图片编码化base64的时候大小会变大，但是通过gzip优化以后基本差不多。所以在应用的过程当中较小的图片可以直接编码成base64，较大的图片则不建议如此使用。 html5如何将图片转换成base64？html5如果要将图片转换成base64需要使用到一个html5的接口FileReader.readAsDataURL()接口说明,这个接口可以将文件转换成base64编码格式，并且再以data：URL的形式展现出来。 应用实例demo123456789101112131415161718192021222324252627282930313233343536&lt;!Doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;html5 image to base64&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; //获取dom节点 var img_upload=document.getElementById("img_upload") ,base64_code=document.getElementById("base64_code") ,img_area=document.getElementById("img_area"); // 添加一个监听事件，如果上传文件发生变化就执行readFile函数。 img_upload.addEventListener('change',readFile,false);&#125; //调用接口，将图片转换成base64再输出 function readFile()&#123; var file=this.files[0]; //获取上传的对象 if(!/image\/\w+/.test(file.type))&#123; alert("请确保文件为图像类型"); return false; &#125; var reader=new FileReader(); reader.readAsDataURL(file); reader.onload=function()&#123; base64_code.innerHTML = this.result; img_area.innerHTML = '&lt;div&gt;图片展示：&lt;/div&gt;&lt;img src="'+this.result+'" alt=""/&gt;'; &#125; &#125; &lt;/script&gt; &lt;input type="file" id="img_upload"/&gt;//上传图片 &lt;textarea id="base64_code" rows="30" cols="360"&gt;&lt;/textarea&gt;//base64代码显示 &lt;p id="img_area"&gt;&lt;/p&gt;//图片显示&lt;/body&gt;&lt;/html&gt; 注：this.result这个result是FileReader.readAsDataURL()接口当中转换完图片输出的base64结果存放在result当中。在代码当中添加console.log(reader);查看一下FileReader对象就可以看到。(reader是我自己起的对象的名称)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-基础补充_02]]></title>
      <url>%2F2015%2F06%2F08%2F15-js%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85-02%2F</url>
      <content type="text"><![CDATA[1.ECMAScript是一种标准和规范，JavaScript和JScript是这种规范的实现和扩展。2.ECMAScript5中关于对象(Object)的新方法：(1)获取对象某个属性的描述符：Object.getOwnPropertyDescriptor(对象, “属性名”) 。(2)定义或修改对象某个属性的属性特征(不常用)：描述符.value/writable/enumerable/configurable=”值”/true/false Object.defineProperty(对象,”属性名”,描述符); 注意：这种方法不常用。若使用，则需要两步：修改描述符—→定义/修改属性(3)定义或修改对象某个自有属性的属性特征(常用)： 123456Object.defineProperty(对象,"属性名",&#123; value:"属性值", writable:true/false, enumerable:true/false, configurable:true/false, &#125;); 注意:这种方法只能定义对象自有属性的属性特征，而不能定义对象原型属性的属性特征。(4) Object.preventExtensions(对象)—属性不可添加、可删除、可修改Object.seal(对象) —属性不可添加、不可删除、可修改Object.freeze(对象) —属性不可添加、不可删除、不可修改 注意：(3)为定义或修改对象某个属性的属性特征，(4)为定义或修改对象所有属性的特征。定义或修改对象某个属性的属性特征时，有四个可定义/修改项：属性值、可修改、可枚举、可删除。定义或修改对象所有属性的特征时，有三个可定义/修改项：可添加、可删除、可修改。 (5) Object.getPrototypeOf(对象) 得到对象的proto属性值。 3.ECMAScript5中关于数组(Array)的新方法：ECMAScript5中，大部分数组新方法的参数为一个匿名函数，并且数组的每一个元素调用一次该匿名函数，该匿名函数一般有两个参数:数组元素和索引值。 (1)数组.forEach():从头到位遍历数组，每个元素都调用指定的函数（该方法的参数），该方法在元素遍历结束之前无法终止。1234567891011var arr=[1,3,5,7,9];var sum=0arr.forEach(function(item,index)&#123; sum=sum+item;&#125;);alert(sum);//弹出25。arr.forEach(function(item,index)&#123;// item=item+1;语法错误，只能通过arr[index]改变数组元素的值。 arr[index]=item+1;&#125;);alert(arr[1]);//弹出4。 注意：数组.forEach()可以取代for循环在数组中的应用，无返回值(return)。 (2)数组.map():调用数组的每一个元素传递给指定函数，并返回一个数组，它包含该函数的返回值。12345var arr = [1, 2, 3, 4, 5]var arr1 = arr.map(function(item) &#123; return item * item;&#125;);alert(arr1) //弹出1,4,9,16,25 (3)数组.filter():创建一个新的匹配过滤条件的数组。123456var arr1 = ['Charles', 'Mark', 'Bill', 'Vincent', 'William', 'Joseph']var arr2 = arr1.filter(function(item, index) &#123; return item.indexOf("ll") &gt; -1&#125;);alert(arr2); //弹出Bill、William。 (4)数组.some()查看数组是否有符合条件的元素1234567891011var arr1 = "Charles,Mark,Bill,Vincent,William,Joseph".split(",");alert(arr1.some( function(item, index) &#123; return item.length &lt; 5; &#125;)); //true alert(arr1.some( function(item, index) &#123; return item.length &lt; 10; &#125;)) //true (5)数组.every()查看数组元素是否全部符合条件。1234567891011var arr1 = "Charles,Mark,Bill,Vincent,William,Joseph".split(",");alert(arr1.every( function(item, index) &#123; return item.length &lt; 5; &#125;)); //false alert(arr1.every( function(item, index) &#123; return item.length &lt; 10;&#125;)) //true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生ajax]]></title>
      <url>%2F2015%2F05%2F23%2F14-js%E5%8E%9F%E7%94%9Fajax%2F</url>
      <content type="text"><![CDATA[Json属性值的访问方式12345678var person=&#123;a:1,'b':2,'c':function()&#123;alert(3)&#125;&#125;alert(person.a);//弹出1alert(person['a']);//弹出1alert(person[a]);//语法错误alert(person.b);//弹出2alert(person['b']);//弹出2alert(person.'b');//语法错误person.c();//弹出3 注意：①无论Json中属性名有无引号，通过对象点属性名访问时属性名不可有引号，通过对象中括号属性名访问时属性名必须加引号。②对象的属性名、属性值以及方法名应该加引号，对象的方法值不可加引号。③若调用对象的方法，则只能用对象点方法名小括号的调用方式。Ajax库12345678910111213141516171819202122232425262728293031function ajax(obj) &#123; var xhr = new XMLHttpRequest(); obj.url = obj.url + '?rand=' + Math.random(); xhr.open(obj.method, obj.url, obj.async); xhr.send(null); if (obj.async === false) &#123; callback(); &#125; if (obj.async === true) &#123; xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; callback(); &#125; &#125;; &#125;; function callback() &#123; if (xhr.status == 200) &#123; obj.success(xhr.responseText); //回调 &#125; else &#123; alert('数据返回失败！状态代码：' + xhr.status + '，状态信息：' + xhr.statusText); &#125;; &#125;;&#125;;ajax(&#123; 'method': 'GET', 'url': 'a.txt', 'async': true, 'success': function(a) &#123; alert(a) &#125;&#125;) 注意：执行对象作为参数的函数时调用了该对象的一个方法。 ajax()为一个函数，函数的实参为一个对象，对象有一个success方法。 对象作为实参调用ajax()函数→执行ajax()函数代码→xhr.responseText作为实参调用对象的success方法。 即：对象是ajax()函数的实参，xhr.responseText是对象success方法的实参。 应用实例(Ajax——省市联级)1234567891011121314151617181920212223242526272829303132333435363738394041424344//本json一共有三层：数组[—对象&#123;—数组[。&lt;body&gt; &lt;select id="sel1"&gt; &lt;option&gt;请选择&lt;/option&gt; &lt;/select&gt; &lt;select id="sel2"&gt; &lt;option&gt;请选择&lt;/option&gt; &lt;/select&gt;&lt;script&gt;var xhr = new XMLHttpRequest();xhr.open('GET', 'http://localhost:3000/api/5', true);xhr.send(null);xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; ojson = JSON.parse(xhr.responseText); &#125;; for (var i = 0; i &lt; ojson.length; i++) &#123; //进入第一层内部。 for (var j in ojson[i]) &#123; //进入第二层内部。 sel1.add(new Option(j, j)); //将第二层内部的键插入到sel1。 &#125;; &#125;;&#125;;sel1.onchange = function() &#123; sel2.options.length = 1; for (var i = 0; i &lt; ojson.length; i++) &#123; //进入第一层内部。 for (var j in ojson[i]) &#123; //进入第二层内部。 if (this.value == j) &#123; //判断第二层内部的键是否等于sel1被选项的value值。 for (var n = 0; n &lt; ojson[i][j].length; n++) &#123; //进入第三层内部。 sel2.add(new Option(ojson[i][j][n], ojson[i][j][n])); //将第三层内部的值插入到sel2。 &#125;; &#125;; &#125;; &#125;;&#125;;&lt;/script&gt;&lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMLHttpRequest对象]]></title>
      <url>%2F2015%2F05%2F10%2F13-jsXMLHttpRequest%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[1.XMLHttpRequest对象：发送请求到服务器并获得返回结果。 2.aJax使用步骤：①创建一个XMLHttpRequest对象； ②使用open方法设置ajax参数； ③与服务器建立连接，发送数据到服务端； ④在onreadystatechange事件函数中接收服务器数据。 3.onreadyStatechange事件：当XMLHttpRequest对象的readyState属性值发生变化时，触发该事件。 4.readyState属性:XMLHttpRequest对象的状态信息0——XMLHttpRequest对象没有完成初始化。1——XMLHttpRequest对象开始发送请求。2——XMLHttpRequest对象请求发送完成，已收到全部响应内容。3——XMLHttpRequest对象开始读取响应，还没有结束4——XMLHttpRequest对象读取响应结束。(0)未初始化—→(1)发送请求—→(2)发送完成—→(3)读取响应—→(4)读取结束new XMLHttpRequest()—(0)→open()—(1)→send()—(1)—(4)→responseText 5.status属性:XMLHttpRequest对象的状态码200——服务器响应正常400——无法找到请求的资源403——没有访问权限404——访问的资源不存在500——服务器内部错误new XMLHttpRequest()—(0)→open()—(0)→send()—(0)—(200)→responseText 6.responseText获得响应的文本内容；responseXML获得响应的XML文档对象7.创建一个服务器，并在页面上输出:”hello world!”12345678910111213141516//加载和返回内置的HTTP模块var http = require("http");//创建一个http的服务器http.createServer(function(request, response) &#123; //向请求的客户端发送响应,其中第一个参数为状态码，第二个参数为设置信息的键值对 response.writeHead(200, &#123; "context-type": "text/html" &#125;); //页面上打印的内容 response.write("hello world!"); //结束请求响应 response.end(); //服务器运行在8080端口&#125;).listen(8080);//控制台上输出Server running at localhost:8080 console.log("Server running at localhost:8080");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-实现单例模式的几种方法]]></title>
      <url>%2F2015%2F04%2F29%2F12-js%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1.构造函数内部判断实现单例模式123456789101112131415161718192021function Person() &#123; if (Person.unique !== undefined) &#123; return Person.unique; //若构造函数Person的unique属性值已定义，则返回构造函数Person的unique属性值。 //否则执行以下代码。 &#125;; this.name = 'Jake'; //给实例对象添加属性。 this.say = function() &#123; alert('hello') &#125;; //给实例对象添加方法。 Person.unique = this; //定义构造函数的uneque属性，将构造函数的实例对象赋值给构造函数的unique属性。 &#125;; var p1 = new Person(); var p2 = new Person(); alert(p1 === p2); //弹出true alert(Person.unique === p1); //弹出true。 Person.unique.say() //弹出hello。&#125; 2. 闭包方式实现单例模式123456789101112131415161718192021var single=(function()&#123; //声明一个全局变量singe，single的值为匿名函数的返回值unique。 var unique;//在匿名函数内声明局部变量unique。 function Person()&#123; this.age='20'; this.say=function()&#123; alert('hello') &#125;; &#125;;//在匿名函数内创建构造函数Person。 if (unique===undefined) &#123; unique=new Person(); &#125;;//如果局部变量unique未定义，则将构造函数的实例对象赋值给该局部变量。 return unique;//返回该局部变量（实例对象）。&#125;)()var p1=single;var p2=single;alert(p1===p2);//弹出true。 3.重写构造方式实现单例模式123456789101112131415161718192021222324252627282930原理： function demo()&#123; alert(1); demo=function()&#123; alert(2); &#125;; &#125;; demo();//弹出1 demo();//弹出2 demo();//弹出2 demo();//弹出2 过程：第一次执行函数有两步：①弹出1。②改变变量demo所指向的函数体。 function Person()&#123; this.age='20'; //给实例对象添加属性。 this.say=function()&#123; alert('hello') &#125;; //给实例对象添加方法。 var instance = this; //声明一个局部变量instance，将Person构造函数的实例对象赋值给该变量。 Person=function()&#123; return instance; &#125;; //改变构造函数内部的函数体，使第一次之后实例对象时直接返回变量instance。 &#125;; var p1=new Person(); var p2=new Person(); alert(p1===p2);//弹出true。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-数据交互]]></title>
      <url>%2F2015%2F04%2F21%2F11-js%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%2F</url>
      <content type="text"><![CDATA[1.可以使用eval函数将字符串转换为JSON对象。1eval('('+string+')'); 高级版本的浏览器中将字符串转为JSON格式：JSON.parse(string);高级版本的浏览器中将JSON转为字符串：JSON.stringify(obj) 2.用for in解析JSON数据。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 var people = &#123; "programmers": [&#123; "firstName": "Brett", "lastName": "McLaughlin", "email": "aaaa" &#125;, &#123; "firstName": "Jason", "lastName": "Hunter", "email": "bbbb" &#125;, &#123; "firstName": "Elliotte", "lastName": "Harold", "email": "cccc" &#125;], "authors": [&#123; "firstName": "Isaac", "lastName": "Asimov", "genre": "science fiction" &#125;, &#123; "firstName": "Tad", "lastName": "Williams", "genre": "fantasy" &#125;, &#123; "firstName": "Frank", "lastName": "Peretti", "genre": "christian fiction" &#125;], "musicians": [&#123; "firstName": "Eric", "lastName": "Clapton", "instrument": "guitar" &#125;, &#123; "firstName": "Sergei", "lastName": "Rachmaninoff", "instrument": "piano" &#125;] &#125;;for (i in people) &#123; for (n = 0; n &lt; people[i].length; n++) &#123; var tr = document.createElement('tr'); for (m in people[i][n]) &#123; var td = document.createElement('td'); td.innerHTML = people[i][n][m]; tr.appendChild(td); &#125;; document.getElementById(i).appendChild(tr); &#125;; &#125;; 注意：var people = {“programmers”: [{“firstName”: “Brett”,……12345678910111213141516171819202122 第一步：利用for循环(数组)和for in(json)打通每一层通道。 for (var i in people) &#123;进入第一层内部for (var j=0;j&lt; people[i].length;j++)&#123;进入第二层内部 for (var n in people[i][j]) &#123;进入第三层内部 &#125;; &#125;; &#125;;第二步：最内层内创建插入单元格，最内层外创建插入行。 for (var i in people) &#123; for (var j=0;j&lt; people[i].length;j++) &#123; var tr=document.createElement('tr'); for (var n in people[i][j]) &#123; var td=document.createElement('td'); td.innerHTML=people[i][j][n]; tr.appendChild(td); &#125;; document.getElementById(i).appendChild(tr); &#125;; &#125;; jq 数据交互方法12345678910111213141516171819202122232425262728293031323334353637383940function getData(ID,urls,pages)&#123;//ajax请求 $.ajax(&#123; url:urls, type:"POST", dataType:"json", data:&#123;page:pages&#125;, async: false, success:function(data)&#123; if(data &amp;&amp; data.code=='success')&#123; var dataD=data.data; var str=""; if(dataD.length==0&amp;&amp;pages==1)&#123; $(ID).html('&lt;li&gt;'+"暂时没有数据"+'&lt;/li&gt;').css(&#123; "text-align":"center", "color":"#ccc" &#125;); return false; &#125;else if(dataD.length==0&amp;&amp;pages!=1)&#123; return; &#125; else&#123; $.each(dataD,function(index,val)&#123; str +='&lt;li&gt;&lt;span class="money"&gt;'+val.money+'元'+'&lt;/span&gt;&lt;span class="dates"&gt;'+val.time+'&lt;/span&gt;' if(val.state==0)&#123; str+='&lt;span class="state state0"&gt;'+'提现失败'+'&lt;/span&gt;&lt;/li&gt;' &#125;else if(val.state==1)&#123; str+='&lt;span class="state state1"&gt;'+'提现成功'+'&lt;/span&gt;&lt;/li&gt;' &#125;else if(val.state==2)&#123; str+='&lt;span class="state state2"&gt;'+'审核中'+'&lt;/span&gt;&lt;/li&gt;' &#125; &#125;) &#125; $(ID).append(str); &#125;else&#123; &#125; &#125; &#125;)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-继承]]></title>
      <url>%2F2015%2F04%2F10%2F10-js%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[继承默认情况：子类—prototype→子类的原型 123子类的原型—constructor→子类 Student.prototype=Student.prototype Student.prototype.constructor=Student; 1.继承的第一种方法：call、apply、bind1234567call、apply、bind 略有不同；call和apply主要是传递参数的方法不同call(对象，实参1，实参2……)apply(对象，[实参1，实参2……])bind 与call和apply的区别是需要自执行(方法后加个小口号“()”)，如下两种方式否可以实现用bind继承：bind(对象，实参1，实参2……)()bind(对象，[实参1，实参2……])() 2.继承的第二种方法：子类—prototype→父类实例123子类原型指向父类实例 父类实例（子类原型）—constructor→子类Student.prototype=new Person(); Student.prototype.constructor=Student; 3.继承的第三种方法： 子类—prototype→父类原型子类原型指向父类原型 父类原型（子类原型）—constructor→子类Student.prototype=Person.prototype;Student.prototype.constructor=Student; 4.继承的第四种方法： 定义一个空类12345678定义空类作为桥梁 空类—prototype→父类 子类—prototype→空类实例空类实例（子类原型）—constructor→子类 var F=function()&#123;&#125; F.prototype=Parent.prototype; Child.prototype=new F; Child.prototype.constructor=Child; 5.继承的第五种方法： ①拷贝类的原型属性for in12345678910111213141516171819①for (i in Parent.prototype) &#123; Child.prototype[i]=Parent.prototype[i]; &#125;;②拷贝对象的所有属性（浅拷贝）for infor (i in p1) &#123; c1[i]=p1[i]; &#125;; ③拷贝对象的所有属性（深拷贝） for in实现数组与对象数据本身的拷贝，而不仅复制栈地址。function extend(child, parent) &#123; //深拷贝封装函数 for (i in parent) &#123; if ((typeof parent[i]) === 'object') &#123; child[i] = (parent[i].constructor === Array) ? [] : &#123;&#125;; extend(child[i], parent[i]) &#125; else &#123; child[i] = parent[i]; &#125;; &#125;; &#125; 6. 继承的第六种方法：对象继承对象的属性，与类无关。1234567891011121314语法：var 子对象=Object.create(父对象，子对象的自有属性) 。举例：var 子对象名 = Object.create(父对象名, &#123; 属性名1: &#123; writable: true,//该属性是否可修改 enumerable: true,//该属性是否可枚举 configurable: true,//该属性是否可删除 value: ‘属性值’, //该属性的属性值。 &#125;, 属性名2: &#123; writable: true, enumerable: true, configurable: true, value: ‘属性值’ &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-闭包]]></title>
      <url>%2F2015%2F03%2F25%2F09-js%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[闭包1.概念：将父函数的局部变量放在子函数中，将子函数作为父函数的返回值，扩展局部变量的访问范围，使函数外可以访问和修改局部变量。 2.任何一个函数都是一个对象的方法，函数中的this指代该函数作为一个方法所属于的对象。一个自由函数是全局变量window的方法。3.对象属性的访问权限：①私有变量(var a=1;)只能被私有函数或特权方法访问。 ②私有函数(var fn=function(){};)只能被特权方法访问。 ③特权方法(this.say=function(){})可以在对象外部访问。 特点：1.逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑。 2.方便调用上下文的局部变量。 3.加强封装性，第2点的延伸，可以达到对变量的保护作用。 优点：1.保护函数内的变量安全,加强了封装性 2.在内存中维持一个变量(用的太多就变成了缺点，占内存) 缺点：闭包有一个非常严重的问题，那就是内存浪费问题， 这个内存浪费不仅仅因为它常驻内存，更重要的是， 对闭包的使用不当会造成无效内存的产生。 闭包之所以会占用资源是当父函数执行结束后，子函数扩展的变量不随着销毁。以为执行子函数的时候需要依赖父函数中的变量。不适合场景：返回闭包的函数是个非常大的函数 应用：闭包的典型框架应该就是jquery了。 闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。 这在做框架的时候体现更明显，有些方法和属性只是运算逻辑过程中的使用的，不想让外部修改这些属性，因此就可以设计一个闭包来只提供方法获取。 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-基础补充_01]]></title>
      <url>%2F2015%2F03%2F13%2F08-js%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85-01%2F</url>
      <content type="text"><![CDATA[1.parseInt(‘n进制数字’,n) ——将n进制数字转化为10进制数字，当n等于10时，可以简写为parseInt(‘10进制数字’)。1234alert(parseInt('23',10)) //弹出23。alert(parseInt('23',16)) //弹出35。alert(parseInt('11',2)) //弹出3。alert(parseInt('23',8)) //弹出19。 2.当未将函数赋值给一个变量时，函数名即代表函数整体，通过函数名加括号()调用函数执行；当将函数赋值给一个变量时，该变量代表函数整体，通过变量名加括号()调用函数执行。在书写代码时，如果想调用函数执行，通过函数名加括号或者变量名加括号的方式，如果想要引入函数整体，则通过函数名不加括号、变量名不加括号或者直接写整个函数整体的方式。 应用：①DOM2级事件处理程序中addEventListener(“事件”,demo)，demo表示引入函数整体，而不是调用函数执行，因此不可加括号。 ②事件函数有两种写法，一种是事件等于函数整体，一种是事件等于函数名无括号（等价于函数整体）。 123456789101112131415&lt;script&gt; function demo()&#123; alert('1') &#125; demo()//弹出1 alert(demo) //弹出function demo()&#123;alert('1')&#125;。&lt;/script&gt;&lt;script&gt; var a=function demo()&#123; alert('1') &#125; a()//弹出1 alert(a)//弹出function demo()&#123;alert('1')&#125; alert(demo) //语法错误：demo is not defined&lt;/script&gt; 3.构造函数也是一个对象，既可以给构造函数添加属性，又可以给构造函数实例出的对象添加属性。123456789101112131415161718192021222324252627&lt;script&gt;function Person(age)&#123; Person.age1='10'; //构造函数也是一个对象，给构造函数添加属性，与实例出的对象无关。 this.age=age; //给构造函数实例出的对象添加属性，与构造函数无关。&#125;alert(typeof Person);//弹出functionvar p1=new Person(20);alert(p1.age1); //弹出undefined。alert(p1.age); //弹出20。alert(Person.age1); //弹出10。alert(Person.age);//弹出undefined。&lt;/script&gt;//给构造函数自身添加属性：只有函数被调用之后，函数内的代码才会被执行，构造函数才会被添加属性。&lt;script&gt;function Person()&#123; Person.age=1;&#125;;alert(Person.age);//此时构造函数内代码未执行，构造函数的age属性未添加，弹出undefined。Person();alert(Person.age);//此时构造函数内代码已执行，构造函数的age属性已添加，弹出1。&lt;/script&gt; 4.检测及遍历对象的属性语法：①”属性名” in 对象——判断该属性是否是该对象的属性（自有属性或者原型属性），返回值为布尔类型。②对象.hasOwnProperty(“属性名”);——判断该属性是否是该对象的自有属性，返回值为布尔类型。 ③for(变量 in 对象){}遍历对象的属性（自有属性或者原型属性），在花括号中，变量指代该对象的属性名，对象[变量]指代该对象的属性值。 ④delete 对象.属性名;——删除对象的该属性。 注意：在方法①和方法②中，引号不可省略。 1234567891011121314151617181920212223242526272829303132333435363738例题：&lt;script&gt;function Person(name,age)&#123; Person.type="函数"; //给构造函数添加自有属性 this.name=name; //给实例对象添加自有属性 this.age=age; //给实例对象添加自有属性 this.say=function()&#123; //给实例对象添加自有属性 alert('你好') &#125;&#125;Person.prototype.height="1.8米";//给构造函数的prototype（实例对象的_proto_）添加属性//此处应注意：构造函数的prototype不等价于构造函数的_proto_var p1=new Person("Jake","26");//从构造函数中实例出对象p1alert('type' in Person);//弹出truealert('type' in p1);//弹出falsealert('age' in Person);//弹出falsealert('name' in p1);//弹出truealert('height' in Person);//弹出false。因为Person.prototype指向Person原型对象，指向p1的_proto_原型对象，Person的_proto_指向上一级构造函数的原型对象alert(p1.hasOwnProperty('age'))//弹出truealert(p1.hasOwnProperty('height'))//弹出falsealert(Person.hasOwnProperty('type'))//弹出true//属性名要加引号for(pro1 in p1)&#123; document.write("属性名："+pro1+";属性值："+p1[pro1]+"&lt;br /&gt;") //弹出name、age、say、height属性名及对应属性值&#125;for(pro2 in Person)&#123; document.write("属性名："+pro2+";属性值："+Person[pro2]+"&lt;br /&gt;") //弹出type属性名及对应属性值（无height属性）&#125;delete p1.name;//删除实例对象p1的name属性 for(pro1 in p1)&#123; document.write("属性名："+pro1+";属性值："+p1[pro1]+"&lt;br /&gt;") //弹出age、say、height属性名及对应属性值&#125;&lt;/script&gt; 5.每一个栈空间中存放的可能是基本数据类型（Number、string、……）的数据本身，也可能是引用数据类型在堆中存放的数据地址。(栈:stack;堆:heap)6.对于基本数据类型而言，每一个变量名与每一个栈空间与每一个数据本身都是一一对应的关系，并不存在多个变量名对应一个数据的情况。对于引用数据类型而言，每一个变量名对应每一个栈空间，多个栈空间可能存放同一个堆地址，指向同一个数据本身。即：对于基本数据类型，变量名与数据本身一一对应，相互并不影响。对于引用数据类型，多个变量名可能对应同一个数据本身，独自都可以修改堆空间中存放的数据本身。对于基本数据类型，a=b的含义为将变量b对应栈空间中存放的数据本身复制一份存放在变量a对应的栈空间中，数据本身发生复制。 对于引用数据类型以及自定义对象，a=b的含义为将变量b对应栈空间中存放的堆地址复制一份存放在变量a对应的栈空间中，堆地址对应的堆空间中存放的数据本身并未发生复制。对于引用数据类型以及自定义对象，即使a=b，变量a与变量b也并不对应同一块栈空间，只是它们所对应的不同栈空间中存放的是同一个堆地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 例题1-1： &lt;script&gt; var a=[1]; var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 a=a.push(2); //修改变量a对应栈空间中存放的堆地址对应的堆空间中的数据本身。 alert(b); //弹出1,2 &lt;/script&gt;例题1-2： &lt;script&gt; var a=new Object(); var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 a.age=12; //修改变量a对应栈空间中存放的堆地址对应的堆空间中的数据本身。 alert(b.age);//弹出12 &lt;/script&gt;例题1-3： &lt;script&gt; var a=[1]; var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 b.age=2; //修改变量b对应栈空间中存放的堆地址对应的堆空间中的数据本身。 a.age=1; //修改变量a对应栈空间中存放的堆地址对应的堆空间中的数据本身。 alert(b.age);//弹出1 &lt;/script&gt;注意：只有点能够修改堆空间中存放的数据本身，只有等号则重新开辟一块堆空间存放新数据。例题2-1： &lt;script&gt; var a=[1]; var b=[1]; //与b=a的含义不同。此时虽然数组b与数组a的数值相等，但是含义为新申请一块堆空间，存放数据[1],在变量b对应的栈空间中存放该堆地址。此时有两个堆空间都存放数据[1]。变量a与变量b对应不同的数据，互不影响。 a.age=23; alert(b.age);//弹出undefined。 &lt;/script&gt;例题2-2： &lt;script&gt; var a=[1]; var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 a=[1,2]; //注意:这一步为重新申请一块堆空间，存放数据[1,2]，并在变量名a对应栈空间中清除老的堆地址，存放该新申请的堆地址。——①并未改变变量名a对应的栈空间以前存放的堆地址对应的数据本身。②并未改变变量名b对应的栈空间中所存放的堆地址。 alert(b);//弹出1。 &lt;/script&gt; 7.全局变量的作用范围：从当前全局变量的声明位置到最后一个script标签的结束位置。123456789101112131415161718192021222324 例题1-1： &lt;script&gt; var a=1; alert(a);//弹出1。 &lt;/script&gt;例题1-2： &lt;script&gt; alert(a);//弹出undefined。 var a=1; &lt;/script&gt;例题1-3： &lt;script&gt; var a=1; &lt;/script&gt; &lt;script&gt; alert(a);//弹出1。 &lt;/script&gt;例题1-4： &lt;script&gt; alert(a);//运行错误：a is not defined &lt;/script&gt; &lt;script&gt; var a=1; &lt;/script&gt; 8.JavaScript预解析是把变量、函数以及函数的参数预解析到他们能调用的环境中，并将其赋一个初始值。预解析对象：①var 变量名 ②function 变量名(){} ③函数形式参数（等价于var 变量名） 预解析结果：var 变量 ——解析为—→ 变量名=undefined function 变量名(){} ——解析为—→ 变量名=function 变量名(){} 同一变量名:②预解析结果优先级高于①预解析结果undefined的优先级。 所有变量声明在预解析阶段完成，当开始逐行解读代码后只能通过表达式（赋值运算符）来改变变量的值和类型。（动态语言） 注意：JavaScript不会预解析的两种情况 ①无var的变量。②变量名=function (){} 12345678910111213141516171819202122232425262728293031例题1-1： &lt;script&gt; alert(a);//弹出undefined。 var a=1; &lt;/script&gt;例题1-2： &lt;script&gt; alert(demo);//弹出undefined。 var demo=function()&#123; alert(1) &#125; &lt;/script&gt;例题1-3： &lt;script&gt; alert(a);//运行错误，a is not defined。 a=1; &lt;/script&gt;例题1-4： &lt;script&gt; alert(demo); //弹出function demo()&#123;alert(1)&#125;。 function demo()&#123; alert(1) &#125; &lt;/script&gt;例题1-5： &lt;script&gt; alert(demo);//运行错误：demo is not defined。 demo=function()&#123; alert(1) &#125; &lt;/script&gt; 9.变量预解析与变量值修改预解析的意义———生成当前环境中的变量对象。 变量预解析：①var 变量名 ②function 变量名(){} ③函数形式参数 变量值修改：①var 变量名= ②变量名=（赋值运算符是修改变量值的标志） 注意：①var 变量名=function(){} 可预解析可修改，预解析结果为变量名=undefined，修改后结果为变量名=function(){}②function 变量名(){}这种写法虽然也表示变量名等于整个函数体，但是由于没有赋值运算符，所以只会在预解析过程中修改变量值，不会在代码执行过程中修改变量的值。 1234567891011121314151617181920212223242526272829303132333435例子1： &lt;script&gt; alert(a);//弹出function a()&#123; alert ("better");&#125;; var a=1;//可预解析，可修改。 alert (a);//弹出1。 var a=function ()&#123; alert("good"); &#125;; //可预解析，可修改。 alert (a);//弹出function ()&#123; alert("good");&#125;; a=3;//不可预解析，可修改。 alert(a);//弹出3。 function a()&#123; alert ("better"); &#125;;//可预解析，不可修改。 alert (a) //弹出3。 &lt;/script&gt;例子2： &lt;script&gt; alert(a);//预解析之后，a=function a() &#123;alert("pleased")&#125;; //故弹出 function a() &#123;alert("pleased")&#125;; function a() &#123; alert("bad") &#125;; //可预解析，不可修改，a=function a() &#123;alert("pleased")&#125; a();//弹出pleased。 var a = 3;//可预解析，可修改。a=3; alert(a);//弹出3。 var a = function() &#123; alert("happy") &#125;;//可预解析，可修改。 a = function() &#123;alert("happy")&#125;; a();//弹出happy。 function a() &#123; alert("pleased") &#125;;//可预解析，不可修改。a = function() &#123;alert("happy")&#125;; a();//弹出happy。 &lt;/script&gt; //注意：①关注代码执行过程中变量名a对应的值是否发生改变，只有出现赋值运算符时，变量a的值才会被修改。②只有当变量名a对应的值是一个函数体的时候，a()才会执行，并且执行变量名a当前对应函数体中的代码。 10.执行环境——每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。也是一个环境。变量对象——存放当前所在环境中的所有变量和函数； 作用域——变量可产生作用的区域，基本相当于当前执行环境； 作用域链(由内向外搜索变量)——当代码进入一个新环境时，会产生新的变量对象，变量对象有新的作用域，新的作用域与上一级作用域链接形成作用域链。 函数形参预解析过程——函数的形式参数在函数调用过程中第一次被赋值，在函数执行过程中可能会被多次赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566举例1-1: &lt;button id="btn"&gt;111&lt;/button&gt; &lt;script&gt; btn.onclick = function() &#123; name = 10;//这里的name未声明，为全局变量 b(name); //等价于b(10),10为实参,调用函数b时赋值 alert(name); //弹出全局变量name等于10 &#125;; function b(name) &#123; //隐含条件:var name=“实参(10)”;此时name为局部变量 name = 20; //变量name已声明,为局部变量name=20 &#125;; &lt;/script&gt;举例1-2: &lt;button id="btn"&gt;222&lt;/button&gt; &lt;script&gt; btn.onclick = function() &#123; name = 10;//这里的name未声明，为全局变量 b(name); //等价于b(10),10为实参,调用函数b时赋值 alert(name); //弹出全局变量name等于20 &#125;; function b(n) &#123; //隐含条件:var n=“实参”;此时n为局部变量。 name = 20; //变量name未声明，为全局变量name=20 &#125;; &lt;/script&gt;例题2-1： &lt;script&gt; var a = 1; //外层执行环境(全局)变量a=1 function fn1() &#123; alert(a); //内层执行环境预解析结束，无a，调用外层执行环境(全局)变量a=1 a = 2; //改变外层执行环境(全局)变量a=2 &#125;; fn1();//弹出1 alert(a)//弹出2 &lt;/script&gt;例题2-2： &lt;script&gt; var a = 1; //外层执行环境(全局)变量a=1 function fn2() &#123; alert(a); //内层执行环境预解析结束，内层环境变量a=undefined var a = 2; //改变内层环境变量a=2 &#125;; fn2();//弹出undefined alert(a) //弹出外层环境(全局)变量a=1 &lt;/script&gt; 例题2-3： &lt;script&gt; var a = 1;//全局变量a=1 function fn1(a) &#123;//隐含条件:var a=“实参”;此时a为局部变量,未传入实参,局部变量a=undefined alert(a); a = 2;//改变局部变量a=2 &#125; fn1();//执行函数，弹出局部变量a等于undefined alert(a);//弹出全局变量a=1 &lt;/script&gt;例题2-4： &lt;script&gt; var a = 1;//全局变量a=1。 function fn1(a) &#123;//隐含条件:var a=“实参”;此时a为局部变量,传入实参1,局部变量a=1 alert(a); a = 2;//改变局部变量a=2 &#125; fn1(a);//执行函数，弹出局部变量a等于1 alert(a);//弹出全局变量a=1 &lt;/script&gt; 11.元素.scrollTop含义为元素滚动条的向下滚动的距离、元素可视区向下移动的距离、元素向上卷动的距离。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-原型与原型链]]></title>
      <url>%2F2015%2F03%2F08%2F07-js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
      <content type="text"><![CDATA[1.原型与构造函数（类）一一对应。原型与构造函数的名字相同，都为构造函数名，但是构造函数的数据类型为function，而原型数据类型为Object注意：原型与构造函数不一定一一对应。赋值—— 若：Worker.prototype=Person.prototype则：Person类、Worker类—→Person原型过程：此时Person、Worker两个构造函数的prototype都指向Person原型，而Person原型的constructor指向Person构造函数。（P31蓝色箭线起始位置分叉）继承——若：for (i in Person.prototype) {Worker.prototype[i] = Person.prototype[i]}则：Person原型—→Person类；Worker原型—→Worker类过程：此时Person构造函数的prototype都指向Person原型，Worker构造函数的prototype都指向Worker原型。其实，Person与Worker在原型链中是平行的关系，而不是后代的关系。 2.对象和原型都可以定义属性和方法，构造函数（类）没有对象或原型的属性和方法，构造函数中的this指代的不是构造函数自身，而是构造函数所实例出的对象。3.给原型添加新属性，与该原型相对应（原型—构造函数—对象）的所有对象都拥有该属性；给对象添加新属性，不会在对应原型中添加对应的属性；修改对象从原型中继承属性的属性值，该对象会有两个同名属性，一个是该对象自有的属性，一个是从原型中继承的属性，两个同名属性的属性值不同，自有属性的属性值优先级高于原型属性的属性值，自有属性的属性值不影响原型同名属性的属性值，原型同名属性的属性值不变；修改原型中已有属性的属性值，如果对象已定义同名属性的新的属性值，则对象的属性值不变，如果对象没有定义同名属性的新的属性值，对象的属性值随原型属性值的改变而改变即：修改原型属性，不一定影响对象；修改对象属性，一般不影响原型。注意：所有的自定义对象都可以通过对象直接给原型添加属性，也都可以添加自有属性，所有的内置对象（包括：1，“abc”）都可以通过对象直接给原型添加属性，但并不是所有的内置对象都可以添加自有属性——①Object对象数据类型既可以添加自有属性，又可以给原型添加属性：数组new Array、函数function、元素（例外情况：null为Object数据类型但既不可以添加自有属性属性，又不可以给原型添加属性。）。②直接写的基本数据类型不可以添加自有属性，但可以通过直接写的基本数据类型给原型添加属性：boolean、number、string。（例外情况：undefined为基本数据类型但既不可以添加自有属性属性，又不可以给原型添加属性。）③从类中new出来的基本数据类型为Object，既可以添加自有属性，又可以给原型添加属性。 4.既可以通过构造函数（类）给原型添加或修改属性和方法，又可以通过对象直接给原型添加或修改属性和方法。原型由两部分组成，一部分是原型属性与属性值组成的键值对集合，一部分是原型的constructor属性，该属性指向对应的构造函数（类）（每一个函数都有一个prototype原型属性，这个属性是一个指针，指向该函数的原型对象）。构造函数有三个作用，一个作用是给原型添加或修改属性，第二个作用是实例出对象，第三个作用是给构造函数实例出的对象添加各自不同的属性值。构造函数在原型构造对象过程中存在的最大意义即是实例出对象，在对象与原型之间搭建桥梁；第二意义是对实例出的对象添加各自不同的属性值，第三意义是给原型添加或修改属性，由于构造函数实例出的对象也可以直接给原型添加或修改属性，所以这一过程虽然很常用，但意义并不重大。 5.构造函数（类）.prototype.属性名=属性值。——含义为给构造函数、实例对象的原型添加（修改）一个属性。构造函数（类）.prototype={}——含义为用一个新的对象覆盖构造函数的原型对象。此时新原型对象的constructor属性值无法指向当前构造函数，需要定义新原型对象的constructor属性为当前构造函数。 6.对象.proto.属性名=属性值。——含义为给实例对象、构造函数的原型添加（修改）一个属性。7.在JavaScript中，一切对象都有proto属性，而只有函数有Prototype属性。三条原型链：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 ①由字面量或工厂方式定义的对象到Object： 字面量构造对象/工厂方式构造对象P3—_ptoto_→Object ②由构造函数（类）到Object: Person构造函数（类）—_ptoto_→function()—_ptoto_→Object ③由构造函数实例出的对象到Object： P1、P2—_ptoto_→Person(Person构造函数(类)的prototype属性属性值)—_ptoto_→Object 原型链： ①第一行矩形中内容表示原型对象，底行矩形中内容表示构造函数。 ②箭头起始矩形中内容为对象，箭头上的椭圆表示该对象的属性名，箭头指向矩形中内容为该对象的属性值。 ③没有椭圆的箭头表示该对象的_proto_属性值，没有椭圆的箭头组成原型链。 过程： ①所有对象都有_proto_属性，所有的_proto_属性都指向原型。 ②所有原型的_proto_属性都指向object原型，所有构造函数的_proto_属性都指向上一级原型。 ③只有函数有prototype属性，函数的prototype属性指向它的原型。 结论： ①函数的prototype指向它的原型、函数的_proto_指向上一级原型，原型的_proto_指向Object原型。 ②函数—prototype→同级原型；函数—_proto_→上一级原型；原型—construct→同级函数；原型—_proto_→object原型。 ③类即是一个函数，原型的原型即是一个对象（Object），可以设置对象的原型指向一个明确的Object（原型或实例对象）。 例子1： &lt;script&gt; var p1=&#123;name:'Jake'&#125; //字面量 function Person(a)&#123; //工厂方式 var o=new Object(); o.name=a; return o; &#125; p2=Person('Jake') function demo(a)&#123; //构造函数 this.name=a; &#125; p3=new demo('Jake'); &lt;/script&gt; &lt;script&gt; function Person()&#123;&#125; var person1=new Person(); person1.__proto__.name='Jake';//通过对象给原型添加属性。 alert(Person.prototype.name);//通过构造函数访问原型的属性，弹出Jake。 Person.prototype.age='26';//通过构造函数给原型添加属性。 alert(person1.__proto__.age);//通过对象访问原型的属性，弹出26。 alert(person1.name);//访问对象的原型属性，弹出Jake。 alert(Person.age);//弹出undefined，构造函数没有继承原型的属性。注意：每一个函数都有一个name属性，该属性的属性值是指向该函数的函数名。每一个函数都有一个prototype属性，该属性的属性值指向该函数的原型对象。 person1.name='Jason';//给对象新添加一个在原型中同名的自有属性。 alert(person1.name);//弹出Jason。 alert(person1.__proto__.name)//弹出jake，原型对象的同名name属性的属性值并未改变。 &lt;/script&gt;注意：对象可以访问原型的属性，可以继承原型的属性，可以直接给原型添加（修改）属性，可以新添加原型中同名的自有属性，也可以创建原型中所没有的自有属性；构造函数可以访问原型的属性，可以给原型添加（修改）属性，可以给对象添加（修改）自有属性，也可以实例出对象。例子2： &lt;script&gt; function Person()&#123;&#125; Person.prototype=&#123; //创建新的原型，覆盖之前的原型。 constructor:'Person',//定义新原型的构造方法指向Person。 name:[1,2], //给原型对象添加name属性。 &#125; var p1=new Person();//在构造函数中实例（new）出对象p1。 var p2=new Person();//在构造函数中实例（new）出对象p2。 p1.name.push(4);//这种方式并不是给对象p1新添加一个在原型中同名的name自有属性，而是修改p1的原型的name属性值。 alert(p1.name); //获取对象p1的name属性值，弹出1,2,4。 alert(p2.name); //获取对象p2的name属性值，弹出1,2,4。说明原型的name属性值被改变。 &lt;/script&gt;例子3： &lt;script&gt; function Person()&#123;&#125; Person.prototype=&#123; //新的原型覆盖之前的原型。 constructor:'Person', //定义新原型的构造方法指向Person。 name:[1,2], //给原型添加name属性。 say:function()&#123; //给原型添加say属性。 return this.name;//返回原型对象的name属性值。 &#125; &#125; var p1=new Person();//在构造函数中实例（new）出对象p1。 var p2=new Person();//在构造函数中实例（new）出对象p2。 alert(p1.say()); //获取对象p1在原型中继承的say属性，弹出1,2。 p1.name=[1,2,3];//给对象P1新添加一个在原型中同名的name自有属性，属性值为[1,2,3]。 alert(p1.name); //获取p1的name属性值，由于name自有属性的属性值优先级高于原型中继承的同名name属性的属性值，所以弹出1,2,3。 alert(p2.name); //弹出1,2。说明原型的name属性值未被改变。 p1.name.push(4);//通过这种方式修改对象p1的name自有属性的属性值。 alert(p1.name);//弹出1,2,3,4。 alert(p2.name); //弹出1,2。说明原型的name属性值仍未被改变。 p1.name1=['a','b','c'];//在对象p1中增加name1属性。 alert(p1.name1);//弹出a,b,c alert(p2.name1);//弹出undefined。说明原型中并未添加name1属性。 &lt;/script&gt;例子4（对象自定义原型1）： &lt;script&gt; var a = &#123; x: 10,calculate: function(z) &#123; return this.x + this.y + z &#125; &#125;;//字面量构造对象a，未自定义对象a的原型，对象a的原型指向Object。 var b = &#123; y: 20,__proto__: a&#125;;//字面量构造对象b，自定义对象b的原型为对象a。 var c = &#123; y: 30&#125;;//字面量构造对象c，未自定义对象c的原型，对象c的原型指向Object。 alert(b.calculate(30));//弹出60 &lt;/script&gt;例子5（对象自定义原型2）： &lt;script&gt; var a=&#123;age:10,say:function()&#123; alert('hello') &#125;&#125;; var b=&#123;age:20,__proto__:a&#125;; b.say();//弹出hello。 var c=&#123;age:30,__proto__:b&#125;; c.say();//弹出hello。 &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-函数]]></title>
      <url>%2F2015%2F03%2F01%2F06-js%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[函数基础学习总结1.递归：函数调用自身的编程技巧称为递归。注意：①如果要用递归得到数学运算的最终结果，每一个递归函数的返回值即是当前递归次数的最终数学运算结果。②用历史递归函数所有的返回值（函数值）和参数（即递归次数）表示当前递归函数的返回值（函数值）。 例子1：求1+2+3+……10012345678function getSum(n)&#123; if (n==1) &#123; return 1; &#125; else&#123; return getSum(n-1)+n &#125; &#125; alert(getSum(100)) 例子2：求1,1,2,3,5,8……的第25项12345678function getNum(n)&#123; if (n==1||n==2) &#123; return 1; &#125; else&#123; return getNum(n-1)+getNum(n-2); &#125;&#125;alert(getNum(25)) 例子3：求1！+2！+3！+……+10！1234567891011function getSum(n) &#123; if (n == 0) &#123; return 0; &#125; else if (n == 1) &#123; return 1; &#125; else &#123; return getSum(n - 1) + (getSum(n - 1) - getSum(n - 2)) * n; //用上一次和上上一次递归函数的返回值（函数值）以及n表示当前递归函数的返回值（函数值）。 &#125;&#125;alert(getSum(10)) 2.创建一个函数，将html元素的id名作为函数的参数，将该html元素作为函数相对应的返回值。123456789&lt;p id="pid"&gt;123&lt;/p&gt;&lt;div id="div"&gt;abc&lt;/div&gt;&lt;script&gt; function id(a)&#123; return document.getElementById(a) &#125; alert(id("pid").innerHTML) //弹出123 alert(id("div").innerHTML) //弹出abc&lt;/script&gt; 注意：在调用此函数时，实际参数的赋值必须为带引号的ID名。3.创建一个insertAfter(新子节点，旧子节点)函数，该函数可以使新子节点插入到旧子节点之后。12345678910111213141516171819&lt;div id="div1"&gt;第一个DIV&lt;/div&gt;&lt;div id="div2"&gt;第一个DIV&lt;/div&gt;&lt;div id="div3"&gt;第一个DIV&lt;/div&gt;&lt;script&gt; var p=document.createElement("p"); p.innerHTML="这是新增的p元素"; var div1=document.getElementById("div1"); var div2=document.getElementById("div2"); var div3=document.getElementById("div3"); function insertAfter(new1,old1)&#123; var parent=old1.parentNode if (old1==parent.lastChild) &#123; parent.appendChild(new1) &#125; else&#123; parent.insertBefore(new1,old1.nextSibling) &#125; &#125; insertAfter(p,div2);&lt;/script&gt; 注意：createElement()创建元素节点；parentNode父节点；childNodes子节点集；firstChild第一个子节点；lastChild最后个子节点；previousSibling前一个兄弟节点；nextSibling后一个兄弟节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM 基础知识总结]]></title>
      <url>%2F2015%2F02%2F25%2F05-jsDOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1.获取当前文档URL的两个方法：12alert(document.URL); alert(location.href) 2.childNodeschildNodes返回的是所有子节点的集合（不包括子节点的子节点）。这些子节点中可能有元素节点、文本节点、注释节点，而不可能有属性节点（属性节点不是任何节点的子节点）。节点有三个属性：nodeName、nodeType、nodeValue。 我们可以通过节点的nodeName属性获取节点名，nodeType属性获取节点类型，nodeValue属性获取节点值。只有元素节点有子节点（子节点可能是元素节点、文本节点以及注释节点），而元素节点、文本节点、注释节点都有父节点，属性节点既没有子节点又没有父节点。script标签属于元素节点，script标签内所有代码（包括注释内容）为script标签的一个子节点， 并且此子节点类型为文本节点。即： script标签内只有一个子节点，为文本节点，注释内容不被认为是一个注释节点，而被认为是此文本节点的一部分。 注意节点的属性与元素的属性的区别： ①节点有三个属性：nodeName、nodeType、nodeValue。 ②在HTML中，元素和元素的属性都属于节点。 例题：遍历一个元素节点的所有属性节点名、值、类型。 12345&lt;input id="ipt" type="text" value="123" name="qer" /&gt; var ipt=document.getElementById("ipt").attributes; for (n=0;n&lt;ipt.length;n++) &#123; document.write(ipt[n].nodeName+";"+ipt[n].nodeValue+';'+ipt[n].nodeType+"&lt;br /&gt;") &#125; 注意：①ipt为input元素节点的属性节点集合。②for(){}循环遍历input每一个属性节点的名、值、类型。3.一切事物皆对象，对象都拥有属性和方法。属性即对象带有的一些特定性质，方法即对象的使用方式。获取属性（特定性质）不加括号，调用方法（使用方式）要加括号。4.把某个元素节点的非空白子节点存入数组123456789101112131415161718192021var html=document.getElementsByTagName("html")[0];var son=html.childNodes;var arr=new Array();for (n=0;n&lt;html.childNodes.length;n++) &#123; if (son[n].nodeType==3&amp;&amp;son[n].nodeValue.trim()=='') &#123; continue; &#125; else&#123; arr.push(son[n]); &#125;; &#125;;alert(arr.length) //弹出2注意：字符串.trim()方法，将字符串两边的空格删去。字符串.trimleft()方法，将字符串左边的空格删去。字符串.trimright()方法，将字符串右边的空格删去。例子：var str=" ad2cd "alert(str.length);//弹出13alert(str.trimLeft().length);//弹出11alert(str.trimRight().length);//弹出7alert(str.trim().length);//弹出5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BOM 基础知识总结]]></title>
      <url>%2F2015%2F02%2F17%2F04-jsBOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1.window对象的conform方法：显示一个带有提示信息、确认和取消按钮的对话框。语法：conform(“提示信息”)注意：如果将conform方法赋值给一个变量，当处理该对话框时，若点击确认，该变量为布尔数据类型true，若点击取消，该变量为布尔数据类型false。12345678910111213141516原理：var a=confirm(); //弹出对话框alert(a); //若对话框点击确认，则弹出ture；若对话框点击取消，则弹出false。例子：&lt;p id="pid"&gt;文字&lt;/p&gt; &lt;button id="btn"&gt;删除&lt;/button&gt;&lt;script&gt;var p=document.getElementById("pid"),btn=document.getElementById("btn");btn.addEventListener("click",demo)function demo()&#123;var a=confirm("确认删除吗？") if(a)&#123; p.innerHTML=""; alert("已经删除") &#125;&#125; 注意：DOM2级事件处理程序中addEventListener(“事件”,demo)，demo不可加括号。2.script标签中的代码无法操作(document)文档流上方的HTML元素对象。3.计时器123456789101112131415161718192021222324&lt;p id="pid"&gt;&lt;/p&gt;&lt;button onclick="demo2()"&gt;按钮&lt;/button&gt;function demo()&#123; p=document.getElementById("pid") var d=new Date(); var year=d.getFullYear(); var month=d.getMonth(); var dates=d.getDate(); //获得的是日期号 var h=d.getHours(); var m=d.getMinutes(); var s=d.getSeconds(); var fulltime=year+"年"+month+"月"+dates+"日"+h+":"+m+":"+s p.innerHTML=fulltime;&#125;var begin=setInterval(demo,1000); //计时器中调用函数的第一种写法，无括号无引号。 //在句柄中添加函数只能用这种方法，无括号无引号。 // setInterval("demo()",1000); //计时器中调用函数的第二种写法，有括号有引号。 // setInterval(function()&#123;demo()&#125;,1000); //计时器中调用函数的第三种写法。function demo2()&#123; clearInterval(begin)&#125; 注意：var begin=setInterval(demo,1000); begin是统计setInterval函数的个数用的，指明是第几个setInterval函数。在本例题中，begin===1。如果不声明begin变量，clearInterval(begin)中的begin改为1，代码运行效果不变。4.BOM浏览器对象模型(Browser Object Model)：使用对象描述了浏览器的各部分内容。Window对象、计时器、History对象、Location对象、Screen对象、Navigator对象、弹出窗口、Cookies。页面刷新: location.reload(); DOM文档对象模型(Document Object Model)：当一个html页面加载到浏览器的时候，那么浏览器会为每个标签都创建一个对应的对象描述该标签的所有信息，那么我们看到的网页信息实际上就是看到了这些标签对象的信息，如果我们需要操作页面数据，那么我们就可以通过这些标签对象进行操作。 5.Location对象用来更改当前页面的URL123456&lt;button id="btn1"&gt;按钮&lt;/button&gt;document.getElementById("btn1").addEventListener("click",demo)//在句柄中添加函数只能用这种方法，无括号无引号。function demo()&#123; location.href="new_file.html"&#125; 6.在服务器通过location.search获取数据（键值对）。12345678910111213141516171819 &lt;form method="get" action="new_file.html"&gt; &lt;input type="text" name="usename" /&gt; &lt;input type="password" name="passord" /&gt; &lt;input type="submit" /&gt; &lt;/form&gt;页面2(new_file.html)代码： &lt;button id="btn"&gt;按钮&lt;/button&gt; var btn= document.getElementById("btn"); btn.addEventListener("click", demo) function demo() &#123; var a = location.search //取得当前 URL的查询字串(?符号及后面的部分)（字符串格式） alert(a) var b = a.substring(1)//截取从第二位开始的查询字串(substring:子串、子链) var c = b.split("&amp;") //将查询字串以"&amp;"为分隔符分隔为数组 for (i = 0; i &lt; c.length; i++) &#123; alert(c[i]) //逐个弹出每一个数组元素 alert(c[i].split("=")[1])//弹出每一个键值对的结果 &#125;; &#125;; JavaScript中的For…in 声明1234567 for...in 声明用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。for ... in 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作。语法：for (变量 in 对象)&#123;代码块&#125;注意：for ... in 循环在遍历数组时，变量指每一个数组的下标值，对象[变量]指每一个数组元素。for ... in 循环在遍历对象时，变量指每一个对象的属性名，对象[变量]指每一个对象的属性值。例子：获取浏览器(window)对象导航(navigator)子对象的所有属性名和属性值。for (i in window.navigator) &#123; document.write(i+"="+window.navigator[i]+"&lt;br /&gt;")&#125;; 8.B/S结构(Browser/Serve，浏览器/服务器模式)、C/S结构(Client/Serve，客户端和服务器模式)：B/S结构是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。C/S结构是软件系统体系结构，通过它可以充分利用两端环境的优势，将任务合理分配到Client客户端和Serve服务端来实现。 9.document.images：获取文档上所有的img标签的集合。123456789 document.images[0]：获取文档上第1个img标签。 document.forms：获取文档上所有的form标签的集合。 document.forms[n]：获取文档上第n+1个form标签。//举例： &lt;img src="img/shili.jpg" /&gt; &lt;script&gt; document.images[0].style.border="3px solid red" &lt;/script&gt;//注意：这种写法只适用于forms、images两种情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-数组]]></title>
      <url>%2F2015%2F02%2F13%2F03-js%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[数组arry1.随机产生一个大于0小于1的数值(0&lt;x&lt;1)方法为：1Math.random() 随机产生一个大于0小于n的数值(0&lt;x&lt;n)方法为：1Math.random()*n 随机产生一个大于0小于n+1的数值(0&lt;x&lt;n+1)方法为：1Math.random()*(n+1) 随机产生一个从0到n-1的整数(0&lt;=x&lt;=n-1)方法为：1Math.floor(Math.random()*n) Math.round(Math.random()*(n-1)) 随机产生一个从0到n的整数(0&lt;=x&lt;=n)方法为：1Math.floor(Math.random()*(n+1)) Math.round(Math.random()*n) 2.数组的属性：length属性表示数组的长度，即其中元素的个数。3. 数组的常用方法：（1）concat()连结两个或更多的数组12345concatenate连结 语法：数组1.concat(数组2,数组3,……数组n) 返回值：连结后的新数组 var arr1=[1,"2",4]; var arr2=[5,new Object,6] var arr3=arr1.concat(arr2) document.write(arr3+"&lt;br /&gt;") //页面输出返回值1,2,4,5,[object Object],6 （2）join()将数组的所有元素放入一个字符串，元素通过指定的字符串进行分隔。（即是将数组转化为一个字符串，数组元素之间可设置分隔符）。123456语法：数组.join(“分隔符”)，若不设置分隔符join()，默认分隔符为逗号。 返回值：生成的字符串 var arr=[1,"2",4,5,new Object,6] var arr1=arr.join("") document.write(arr1)//页面输出新字符串及返回值 //1245[object Object]6，无空格。 document.write(typeof arr) //页面输出Object 3）pop()删除并返回数组最后一个元素12345语法：数组.pop() 删除数组最后一个元素，并返回数组最后一个元素 返回值：最后一个元素 var arr = [1, "2", 4, 5, new Object, 6] var arr1 = arr.pop() document.write(arr1+"&lt;br/&gt;") //页面输出返回值6。 document.write(arr) //页面输出新数组1,2,4,5,[object Object]。 （4）push()向数组的末尾添加一个或更多的元素，并返回新的长度1234567语法：数组.push(元素1，元素2，……) 返回值：新的长度 例子： var arr=[1,"2",4,5,new Object,6] var arr1=arr.push("12",new Object,3) document.write(arr1+"&lt;br/&gt;") //页面输出返回值9。 document.write(arr) //页面输出新数组1,2,4,5,[object Object],6,12,[object Object],3 含义：arr添加了三个元素，而arr1为数值9。 （5）reverse()颠倒数组中元素的顺序123456789101112语法：数组.reverse() 返回值：颠倒后的数组 例子： var arr=[1,"2",4,5,new Object,6] arr.reverse(); document.write(arr) //页面输出6,[object Object],5,4,2,1 注意：数组.reverse()语法正确，而字符串.reverse()语法错误。 注解：字符串转化为数组的方法为：字符串.split(“分隔符”) 例子： var str=window.prompt("请输入数值") //prompt提示框输入字符串str。 var arr=str.split(""); //字符串str转化为数值arr。 arr.reverse(); //颠倒数组arr元素中的顺序。 var str2=arr.join("") //将数组arr转化为字符串str2，并且没有分隔符。document.write(str+"&lt;br /&gt;"); //页面输出字符串str：546285753 document.write(arr+"&lt;br /&gt;"); //页面输出颠倒顺序后的数组arr：3,5,7,5,8,2,6,4,5 document.write(str2) //页面输出字符串str2：357582645 （6）shift()删除并返回数组的第一个元素语法：数组.shift() 删除数组第一个元素。 返回值：删除的第一个元素。var arr = [&quot;a&quot;, &quot;2&quot;, 4, 5, new Object, 6] var arr1 = arr.shift() document.write(arr1+&quot; “) //页面输出返回值a。 document.write(arr) //页面输出新数组2,4,5,[object Object],6。 （7）slice()从某个指定的数组返回选定的元素，不会修改数组。123456语法：数组.slice(选择元素的起始底，选择元素的结束次序) 返回值：选择的元素。 var arr = ["a", "2", 4, 5, new Object, 6] var arr1 = arr.slice(2,5) document.write(arr1+"&lt;br/&gt;") //页面输出返回值4, 5, new Object document.write(arr) //页面输出a,4,5,[object Object],6。 注意：该方法并不会修改数组。 （8）sort()对数组的元素进行排序1234语法：数组.sort() 返回值：排序之后的数组。 var arr = [21,11,-4,9,45,6] arr.sort() document.write(arr+"&lt;br /&gt;") //页面输出-4,11,21,45,6,9 var t=function (a,b)&#123; return a-b &#125;; arr.sort(t); document.write(arr) //页面输出-4,6,9,11,21,45 （9）splice()从数组中添加/删除元素，然后返回被删除的元素。12345语法：数组.splice(删除元素的起始底，删除元素的个数，增加的元素1，增加的元素2……) 返回值：被删除的元素。 var arr = ["a", "2", 4, 5, new Object, 6] var arr1 = arr.splice(2,1,"bc",3) document.write(arr1+"&lt;br /&gt;")//页面输出4 document.write(arr) //页面输出a,2,bc,3,5,[object Object],6。 （10）tostring()将数组转化为字符串1234语法：数组.tostring() 返回值：字符串 var arr = ["a","2",new Object,6] arr.toString() document.write(arr) //页面输出a,2,[object Object],6 （11）unshift()向数组开头添加一个或更多元素，并返回新的长度12语法：数组.unshift(“元素1”,”元素2”,”元素3”) 返回值：新的长度 var arr = ["a","2",new Object,6] var arr1=arr.unshift(1,"bc") document.write(arr1+"&lt;br /&gt;")//页面输出6 document.write(arr) //页面输出1,bc,a,2,[object Object],6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础语法]]></title>
      <url>%2F2015%2F02%2F09%2F02-js%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[js基本语法1.prompt(“信息提示”,”默认值”)。prompt：提示注意：prompt(“信息提示”,”默认值”)，即使输入number类型内容，提交的也是string数据类型。2.switch条件语句中的条件表达式(case 值:)默认的判断过程是全等（===）判断，即认为”3”不全等于3。（在if else条件语句中，==不识别数据类型，===识别数据类型。）例子：123var a="2" switch(a)&#123; case 2: //不满足该条件表达式alert("a"+"==="+2); //不执行，不弹出 break;default: alert("a"+"!=="+2) //弹出a！==2 &#125; 3.if else条件语句从前向后执行，当满足第一个条件表达式时，执行对应的条件语句，之后跳出if else条件语句。此时即使后面仍有满足条件的表达式，也不再执行相对应的条件语句。4.switch条件语句从前向后执行，break语句用来跳出当前switch语句。switch条件语句中不同的条件表达式(case 值:)之间为或(||)的关系。如果满足一个条件表达(case 值:)式的条件语句后没有break语句，则执行该条件语句和之后第一个break语句之前的所有条件语句。注意：由于不同的条件表达式(case 值:)之间为或(||)的关系，认为该条件表达式和之后第一个break之前所有的条件表达式返回true，执行之间所有的条件语句。5.求1！+2！+3！+……+10！123456var n=1 ;var num= 1;var sum= 0;while(n&lt;=10)&#123; num=num*n;sum=sum+num; n++; &#125;alert(sum) 注意：写循环体时最重要的是明确每一个变量所代表的含义（在Hbuild中标注每一个变量的含义）。求和循环核心三变量：循环次数n、各项数值num、各项总和sum。for循环1234567var num=初值;var sum=0;for (n=1;n&lt;=循环次数;n++) &#123; num=表达式; sum=sum+num; &#125; alert(sum)&#125; 过程：①项数赋值循环次数。②求解各项数值表达式。③初值赋值。while循环1234567var n=1 ;var num=初值;var sum= 0;while(n&lt;=循环次数)&#123; num=表达式; sum=sum+num; n++;&#125;alert(sum) 过程：①项数赋值循环次数。②求解各项数值表达式。③初值赋值。do while循环####12345678var n=1;var num= 初值;var sum=0; do&#123; num=表达式; sum=sum+num; n=n+1; &#125;while(n&lt;=循环次数) alert(sum) 过程：①项数赋值循环次数。②求解各项数值表达式。③初值赋值。6.求和 sum=2+22+222+22222+…..+2222222212345678var n = 1;var num = 0;var sum = 0;while (n &lt;= 8) &#123; num = num*10+2; sum = sum + num; n++; &#125; alert(sum)&#125; 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。7.求和 sum=1/1!+1/2!+1/3!+1/4!+1/5!+…..+1/10!12345678var n = 1;var num = 1;var sum = 0;while (n &lt;=10 ) &#123; num =1/((1/num)*n); sum = sum + num; n++;&#125;alert(sum) 8.有一只猴子吃一堆果子，已知每天吃昨天剩下的果子的一半再多一个，直到第10天才吃完。问原来这堆果子有多少个？12345678910var n = 1;var num = 0;var sum = 0;while (n &lt;= 10) &#123; num =2*num+2; sum = sum + num; n++; &#125; alert(num)&#125; 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。9.国际象棋棋盘有64格，若在第1格放1粒谷；第2格放2粒谷；第3格放4粒谷；第4格放8粒谷……如此一直放到第64格。假设2000000粒谷有一顿重，问需要多少吨谷才够放？123456789var n = 1;var num = 0.5;var sum = 0;while (n &lt;= 64) &#123; num =num*2; sum = sum + num; n++; &#125; alert(sum)&#125; 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。10.求出1-100之间所有除以3余1的数,并求和12345678910var n=1;var num=1;var sum=0;while (n&lt;=100)&#123; num=n; if(num%3==1)&#123; sum=sum+num; &#125; n++; &#125;alert(sum); 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript简介]]></title>
      <url>%2F2015%2F01%2F12%2F01-js%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[js基本特点1. 弱类型语言：没有明确的数据类型声明，所有变量都用var声明。2. 脚本语言：计算机可以直接执行源代码。3. JavaScript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言,可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。4. JavaScript——最流行的脚本语言:弱类型语言、动态性语言、解释性语言。5. JavaScript 组成：ECMAScript（语法）、DOM（文档对象模型）、BOM（浏览器对象模型）。 BOM（Browser Object Model）js初识代码（文档输出的几种写法）1234567document.write("Hello JavaScript1&lt;br/&gt;");//文档输出时换行的第一种写法。 document.write("Hello JavaScript2"+"&lt;br /&gt;");//文档输出时换行的第二种写法。document.writeln("Hello JavaScript2"); //文档输出时文本后加一个空格。alert("Hello\nJavaScript"); //弹出对话框时换行的第一种方法。alert("Hello"+"\n"+"JavaScript"); //弹出对话框时换行的第二种方法。console.log("Hello\nJavaScript"); //控制台输出文本换行的第一种写法。 console.log("Hello"+"\n"+"JavaScript"); //控制台输出文本换行的第二种写法。 注意：①window是一个全局对象，在书写时一般省略。例如：window.document；window.alert；window.consolejs运算符简介加号（+）有两种含义：①算数运算符；②字符串拼接；当相加的各数据全部为数字数据类型时，加号的含义为算数运算符。当相加的各数据有字符串数据类型时，加号的含义在第一个字符串之前为算数运算符，在第一个字符串之后为字符串拼接（括号中的数字为加法）。例子：12var a=2+3+15+"12"+4+"abc"+(2+3)+9+1;console.log(a);//20124abc591; 注意：字符串数据类型必须用双引号包裹script标签script标签可以放在文档的任何位置，通常放在head中，建议写在body之前，使浏览器先加载标签，再运行JavaScript代码，增强用户体验。 script标签必须成对出现，同一个页面中可以出现多对，且从上往下执行。 如果一个script标签用来引入外部JavaScript文件，此标签内不能再写JavaScript代码。(标签内部写代码的时候注意script不能有src属性，值为空也不可以) script标签的type属性可以不写，也可以写text/javascript属性值，这种写法不标准，但是最通用，浏览器支持较好，也可以写application/javascript属性值，这种写法浏览器支持不是特别好。 script标签的async用来设置脚本是否支持异步，默认属性值为“false”，可定义“true”或“async”。 外链JavaScript文件的script标签添加async属性，使下一个script标签的起始执行时间无需等待当前script标签的外链JavaScript执行结束。 标识符（变量、函数、属性的名字，或者函数的参数）JavaScript的变量用来保存值或者表达式，变量的值是可以改变。变量就是计算机在内存中申请一块空间地址的别名，便于程序员识别。变量三要素：①变量名 ②变量值 ③变量类型####（1）当一个变量已声明未赋值时，变量的值为undefined。 （2）变量可以先声明后赋值，也可以声明和赋值同时进行。var a;a=10; （3）可以同时声明多个变量，变量之间用逗号隔开。var a=10,b=37,c=53; （4）所有变量都用var声明，没有严格区分数据类型，属于弱类型语言。 （5）用typeof 来确定变量的数据类型。 var a=1;alert(typeof a);//等价于alert(typeof(a)); （6）语法中可以省略var。 注意：当声明一个变量时，如果没有给他赋值，无法明确知道变量的类型，这样的语言称作弱类型语言。JavaScript是一种弱类型的语言，把所有的变量类型都用var声明，而不用明确声明数据类型，只有真正给变量赋值时，变量的类型才决定，也就是说变量的数据类型是由变量的值的类型来决定的。js数据类型ECMAScript中有5种基本数据类型：undefined、null、boolean、number 、string,还有一种复杂数据类型。 也叫引用数据类型object和函数类型function，当然，function也可以看做object类型。ECMAScript不支持 任何创建自定义类型的机制，所有值都成为以上7 种数据类型之一。在JavaScript中，用typeof()检测变量 的数据类型。对于值或变量使用typeof 操作符会返回如下字符串： 123456789101112131415undefined： 未定义 boolean ：布尔值 string： 字符串 number ：数值 object： 对象或null function ：函数 基本数据类型：数字、字符串、布尔、未定义 var a=1; alert(typeof(a)); //返回number 数字var a="1"; alert(typeof a); //返回string 字符串 var a; alert(typeof (a)) //返回undefined 未定义 var a=false; alert(typeof(a)); //返回boolean 布尔 引用数据类型：函数、数组、对象、日期、空 var a=null; alert(typeof(a)); //返回object 空 var a=function ()&#123;&#125;; alert(typeof a); //返回function（属于object的一种） var a=new Array ; alert(typeof a); //返回object 数组 var a=new Object(); alert(typeof a); //返回object 对象 关键字在JavaScript语法中有特定用途，不能用作标识符，保留字未来可能成为关键字。]]></content>
    </entry>

    
  
  
</search>
