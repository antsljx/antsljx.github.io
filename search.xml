<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript-基础补充_01]]></title>
      <url>%2F2017%2F03%2F13%2F08-js%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85-01%2F</url>
      <content type="text"><![CDATA[1.parseInt(‘n进制数字’,n) ——将n进制数字转化为10进制数字，当n等于10时，可以简写为parseInt(‘10进制数字’)。1234alert(parseInt('23',10)) //弹出23。alert(parseInt('23',16)) //弹出35。alert(parseInt('11',2)) //弹出3。alert(parseInt('23',8)) //弹出19。 2.当未将函数赋值给一个变量时，函数名即代表函数整体，通过函数名加括号()调用函数执行；当将函数赋值给一个变量时，该变量代表函数整体，通过变量名加括号()调用函数执行。在书写代码时，如果想调用函数执行，通过函数名加括号或者变量名加括号的方式，如果想要引入函数整体，则通过函数名不加括号、变量名不加括号或者直接写整个函数整体的方式。 应用：①DOM2级事件处理程序中addEventListener(“事件”,demo)，demo表示引入函数整体，而不是调用函数执行，因此不可加括号。 ②事件函数有两种写法，一种是事件等于函数整体，一种是事件等于函数名无括号（等价于函数整体）。 123456789101112131415&lt;script&gt; function demo()&#123; alert('1') &#125; demo()//弹出1 alert(demo) //弹出function demo()&#123;alert('1')&#125;。&lt;/script&gt;&lt;script&gt; var a=function demo()&#123; alert('1') &#125; a()//弹出1 alert(a)//弹出function demo()&#123;alert('1')&#125; alert(demo) //语法错误：demo is not defined&lt;/script&gt; 3.构造函数也是一个对象，既可以给构造函数添加属性，又可以给构造函数实例出的对象添加属性。123456789101112131415161718192021222324252627&lt;script&gt;function Person(age)&#123; Person.age1='10'; //构造函数也是一个对象，给构造函数添加属性，与实例出的对象无关。 this.age=age; //给构造函数实例出的对象添加属性，与构造函数无关。&#125;alert(typeof Person);//弹出functionvar p1=new Person(20);alert(p1.age1); //弹出undefined。alert(p1.age); //弹出20。alert(Person.age1); //弹出10。alert(Person.age);//弹出undefined。&lt;/script&gt;//给构造函数自身添加属性：只有函数被调用之后，函数内的代码才会被执行，构造函数才会被添加属性。&lt;script&gt;function Person()&#123; Person.age=1;&#125;;alert(Person.age);//此时构造函数内代码未执行，构造函数的age属性未添加，弹出undefined。Person();alert(Person.age);//此时构造函数内代码已执行，构造函数的age属性已添加，弹出1。&lt;/script&gt; 4.检测及遍历对象的属性语法：①”属性名” in 对象——判断该属性是否是该对象的属性（自有属性或者原型属性），返回值为布尔类型。②对象.hasOwnProperty(“属性名”);——判断该属性是否是该对象的自有属性，返回值为布尔类型。 ③for(变量 in 对象){}遍历对象的属性（自有属性或者原型属性），在花括号中，变量指代该对象的属性名，对象[变量]指代该对象的属性值。 ④delete 对象.属性名;——删除对象的该属性。 注意：在方法①和方法②中，引号不可省略。 1234567891011121314151617181920212223242526272829303132333435363738例题：&lt;script&gt;function Person(name,age)&#123; Person.type="函数"; //给构造函数添加自有属性 this.name=name; //给实例对象添加自有属性 this.age=age; //给实例对象添加自有属性 this.say=function()&#123; //给实例对象添加自有属性 alert('你好') &#125;&#125;Person.prototype.height="1.8米";//给构造函数的prototype（实例对象的_proto_）添加属性//此处应注意：构造函数的prototype不等价于构造函数的_proto_var p1=new Person("Jake","26");//从构造函数中实例出对象p1alert('type' in Person);//弹出truealert('type' in p1);//弹出falsealert('age' in Person);//弹出falsealert('name' in p1);//弹出truealert('height' in Person);//弹出false。因为Person.prototype指向Person原型对象，指向p1的_proto_原型对象，Person的_proto_指向上一级构造函数的原型对象alert(p1.hasOwnProperty('age'))//弹出truealert(p1.hasOwnProperty('height'))//弹出falsealert(Person.hasOwnProperty('type'))//弹出true//属性名要加引号for(pro1 in p1)&#123; document.write("属性名："+pro1+";属性值："+p1[pro1]+"&lt;br /&gt;") //弹出name、age、say、height属性名及对应属性值&#125;for(pro2 in Person)&#123; document.write("属性名："+pro2+";属性值："+Person[pro2]+"&lt;br /&gt;") //弹出type属性名及对应属性值（无height属性）&#125;delete p1.name;//删除实例对象p1的name属性 for(pro1 in p1)&#123; document.write("属性名："+pro1+";属性值："+p1[pro1]+"&lt;br /&gt;") //弹出age、say、height属性名及对应属性值&#125;&lt;/script&gt; 5.每一个栈空间中存放的可能是基本数据类型（Number、string、……）的数据本身，也可能是引用数据类型在堆中存放的数据地址。(栈:stack;堆:heap)6.对于基本数据类型而言，每一个变量名与每一个栈空间与每一个数据本身都是一一对应的关系，并不存在多个变量名对应一个数据的情况。对于引用数据类型而言，每一个变量名对应每一个栈空间，多个栈空间可能存放同一个堆地址，指向同一个数据本身。即：对于基本数据类型，变量名与数据本身一一对应，相互并不影响。对于引用数据类型，多个变量名可能对应同一个数据本身，独自都可以修改堆空间中存放的数据本身。对于基本数据类型，a=b的含义为将变量b对应栈空间中存放的数据本身复制一份存放在变量a对应的栈空间中，数据本身发生复制。 对于引用数据类型以及自定义对象，a=b的含义为将变量b对应栈空间中存放的堆地址复制一份存放在变量a对应的栈空间中，堆地址对应的堆空间中存放的数据本身并未发生复制。对于引用数据类型以及自定义对象，即使a=b，变量a与变量b也并不对应同一块栈空间，只是它们所对应的不同栈空间中存放的是同一个堆地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 例题1-1： &lt;script&gt; var a=[1]; var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 a=a.push(2); //修改变量a对应栈空间中存放的堆地址对应的堆空间中的数据本身。 alert(b); //弹出1,2 &lt;/script&gt;例题1-2： &lt;script&gt; var a=new Object(); var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 a.age=12; //修改变量a对应栈空间中存放的堆地址对应的堆空间中的数据本身。 alert(b.age);//弹出12 &lt;/script&gt;例题1-3： &lt;script&gt; var a=[1]; var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 b.age=2; //修改变量b对应栈空间中存放的堆地址对应的堆空间中的数据本身。 a.age=1; //修改变量a对应栈空间中存放的堆地址对应的堆空间中的数据本身。 alert(b.age);//弹出1 &lt;/script&gt;注意：只有点能够修改堆空间中存放的数据本身，只有等号则重新开辟一块堆空间存放新数据。例题2-1： &lt;script&gt; var a=[1]; var b=[1]; //与b=a的含义不同。此时虽然数组b与数组a的数值相等，但是含义为新申请一块堆空间，存放数据[1],在变量b对应的栈空间中存放该堆地址。此时有两个堆空间都存放数据[1]。变量a与变量b对应不同的数据，互不影响。 a.age=23; alert(b.age);//弹出undefined。 &lt;/script&gt;例题2-2： &lt;script&gt; var a=[1]; var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 a=[1,2]; //注意:这一步为重新申请一块堆空间，存放数据[1,2]，并在变量名a对应栈空间中清除老的堆地址，存放该新申请的堆地址。——①并未改变变量名a对应的栈空间以前存放的堆地址对应的数据本身。②并未改变变量名b对应的栈空间中所存放的堆地址。 alert(b);//弹出1。 &lt;/script&gt; 7.全局变量的作用范围：从当前全局变量的声明位置到最后一个script标签的结束位置。123456789101112131415161718192021222324 例题1-1： &lt;script&gt; var a=1; alert(a);//弹出1。 &lt;/script&gt;例题1-2： &lt;script&gt; alert(a);//弹出undefined。 var a=1; &lt;/script&gt;例题1-3： &lt;script&gt; var a=1; &lt;/script&gt; &lt;script&gt; alert(a);//弹出1。 &lt;/script&gt;例题1-4： &lt;script&gt; alert(a);//运行错误：a is not defined &lt;/script&gt; &lt;script&gt; var a=1; &lt;/script&gt; 8.JavaScript预解析是把变量、函数以及函数的参数预解析到他们能调用的环境中，并将其赋一个初始值。预解析对象：①var 变量名 ②function 变量名(){} ③函数形式参数（等价于var 变量名） 预解析结果：var 变量 ——解析为—→ 变量名=undefined function 变量名(){} ——解析为—→ 变量名=function 变量名(){} 同一变量名:②预解析结果优先级高于①预解析结果undefined的优先级。 所有变量声明在预解析阶段完成，当开始逐行解读代码后只能通过表达式（赋值运算符）来改变变量的值和类型。（动态语言） 注意：JavaScript不会预解析的两种情况 ①无var的变量。②变量名=function (){} 12345678910111213141516171819202122232425262728293031例题1-1： &lt;script&gt; alert(a);//弹出undefined。 var a=1; &lt;/script&gt;例题1-2： &lt;script&gt; alert(demo);//弹出undefined。 var demo=function()&#123; alert(1) &#125; &lt;/script&gt;例题1-3： &lt;script&gt; alert(a);//运行错误，a is not defined。 a=1; &lt;/script&gt;例题1-4： &lt;script&gt; alert(demo); //弹出function demo()&#123;alert(1)&#125;。 function demo()&#123; alert(1) &#125; &lt;/script&gt;例题1-5： &lt;script&gt; alert(demo);//运行错误：demo is not defined。 demo=function()&#123; alert(1) &#125; &lt;/script&gt; 9.变量预解析与变量值修改预解析的意义———生成当前环境中的变量对象。 变量预解析：①var 变量名 ②function 变量名(){} ③函数形式参数 变量值修改：①var 变量名= ②变量名=（赋值运算符是修改变量值的标志） 注意：①var 变量名=function(){} 可预解析可修改，预解析结果为变量名=undefined，修改后结果为变量名=function(){}②function 变量名(){}这种写法虽然也表示变量名等于整个函数体，但是由于没有赋值运算符，所以只会在预解析过程中修改变量值，不会在代码执行过程中修改变量的值。 1234567891011121314151617181920212223242526272829303132333435例子1： &lt;script&gt; alert(a);//弹出function a()&#123; alert ("better");&#125;; var a=1;//可预解析，可修改。 alert (a);//弹出1。 var a=function ()&#123; alert("good"); &#125;; //可预解析，可修改。 alert (a);//弹出function ()&#123; alert("good");&#125;; a=3;//不可预解析，可修改。 alert(a);//弹出3。 function a()&#123; alert ("better"); &#125;;//可预解析，不可修改。 alert (a) //弹出3。 &lt;/script&gt;例子2： &lt;script&gt; alert(a);//预解析之后，a=function a() &#123;alert("pleased")&#125;; //故弹出 function a() &#123;alert("pleased")&#125;; function a() &#123; alert("bad") &#125;; //可预解析，不可修改，a=function a() &#123;alert("pleased")&#125; a();//弹出pleased。 var a = 3;//可预解析，可修改。a=3; alert(a);//弹出3。 var a = function() &#123; alert("happy") &#125;;//可预解析，可修改。 a = function() &#123;alert("happy")&#125;; a();//弹出happy。 function a() &#123; alert("pleased") &#125;;//可预解析，不可修改。a = function() &#123;alert("happy")&#125;; a();//弹出happy。 &lt;/script&gt; //注意：①关注代码执行过程中变量名a对应的值是否发生改变，只有出现赋值运算符时，变量a的值才会被修改。②只有当变量名a对应的值是一个函数体的时候，a()才会执行，并且执行变量名a当前对应函数体中的代码。 10.执行环境——每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。也是一个环境。变量对象——存放当前所在环境中的所有变量和函数； 作用域——变量可产生作用的区域，基本相当于当前执行环境； 作用域链(由内向外搜索变量)——当代码进入一个新环境时，会产生新的变量对象，变量对象有新的作用域，新的作用域与上一级作用域链接形成作用域链。 函数形参预解析过程——函数的形式参数在函数调用过程中第一次被赋值，在函数执行过程中可能会被多次赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566举例1-1: &lt;button id="btn"&gt;111&lt;/button&gt; &lt;script&gt; btn.onclick = function() &#123; name = 10;//这里的name未声明，为全局变量 b(name); //等价于b(10),10为实参,调用函数b时赋值 alert(name); //弹出全局变量name等于10 &#125;; function b(name) &#123; //隐含条件:var name=“实参(10)”;此时name为局部变量 name = 20; //变量name已声明,为局部变量name=20 &#125;; &lt;/script&gt;举例1-2: &lt;button id="btn"&gt;222&lt;/button&gt; &lt;script&gt; btn.onclick = function() &#123; name = 10;//这里的name未声明，为全局变量 b(name); //等价于b(10),10为实参,调用函数b时赋值 alert(name); //弹出全局变量name等于20 &#125;; function b(n) &#123; //隐含条件:var n=“实参”;此时n为局部变量。 name = 20; //变量name未声明，为全局变量name=20 &#125;; &lt;/script&gt;例题2-1： &lt;script&gt; var a = 1; //外层执行环境(全局)变量a=1 function fn1() &#123; alert(a); //内层执行环境预解析结束，无a，调用外层执行环境(全局)变量a=1 a = 2; //改变外层执行环境(全局)变量a=2 &#125;; fn1();//弹出1 alert(a)//弹出2 &lt;/script&gt;例题2-2： &lt;script&gt; var a = 1; //外层执行环境(全局)变量a=1 function fn2() &#123; alert(a); //内层执行环境预解析结束，内层环境变量a=undefined var a = 2; //改变内层环境变量a=2 &#125;; fn2();//弹出undefined alert(a) //弹出外层环境(全局)变量a=1 &lt;/script&gt; 例题2-3： &lt;script&gt; var a = 1;//全局变量a=1 function fn1(a) &#123;//隐含条件:var a=“实参”;此时a为局部变量,未传入实参,局部变量a=undefined alert(a); a = 2;//改变局部变量a=2 &#125; fn1();//执行函数，弹出局部变量a等于undefined alert(a);//弹出全局变量a=1 &lt;/script&gt;例题2-4： &lt;script&gt; var a = 1;//全局变量a=1。 function fn1(a) &#123;//隐含条件:var a=“实参”;此时a为局部变量,传入实参1,局部变量a=1 alert(a); a = 2;//改变局部变量a=2 &#125; fn1(a);//执行函数，弹出局部变量a等于1 alert(a);//弹出全局变量a=1 &lt;/script&gt; 11.元素.scrollTop含义为元素滚动条的向下滚动的距离、元素可视区向下移动的距离、元素向上卷动的距离。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-原型与原型链]]></title>
      <url>%2F2015%2F03%2F08%2F07-js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
      <content type="text"><![CDATA[1.原型与构造函数（类）一一对应。原型与构造函数的名字相同，都为构造函数名，但是构造函数的数据类型为function，而原型数据类型为Object注意：原型与构造函数不一定一一对应。赋值—— 若：Worker.prototype=Person.prototype则：Person类、Worker类—→Person原型过程：此时Person、Worker两个构造函数的prototype都指向Person原型，而Person原型的constructor指向Person构造函数。（P31蓝色箭线起始位置分叉）继承——若：for (i in Person.prototype) {Worker.prototype[i] = Person.prototype[i]}则：Person原型—→Person类；Worker原型—→Worker类过程：此时Person构造函数的prototype都指向Person原型，Worker构造函数的prototype都指向Worker原型。其实，Person与Worker在原型链中是平行的关系，而不是后代的关系。 2.对象和原型都可以定义属性和方法，构造函数（类）没有对象或原型的属性和方法，构造函数中的this指代的不是构造函数自身，而是构造函数所实例出的对象。3.给原型添加新属性，与该原型相对应（原型—构造函数—对象）的所有对象都拥有该属性；给对象添加新属性，不会在对应原型中添加对应的属性；修改对象从原型中继承属性的属性值，该对象会有两个同名属性，一个是该对象自有的属性，一个是从原型中继承的属性，两个同名属性的属性值不同，自有属性的属性值优先级高于原型属性的属性值，自有属性的属性值不影响原型同名属性的属性值，原型同名属性的属性值不变；修改原型中已有属性的属性值，如果对象已定义同名属性的新的属性值，则对象的属性值不变，如果对象没有定义同名属性的新的属性值，对象的属性值随原型属性值的改变而改变即：修改原型属性，不一定影响对象；修改对象属性，一般不影响原型。注意：所有的自定义对象都可以通过对象直接给原型添加属性，也都可以添加自有属性，所有的内置对象（包括：1，“abc”）都可以通过对象直接给原型添加属性，但并不是所有的内置对象都可以添加自有属性——①Object对象数据类型既可以添加自有属性，又可以给原型添加属性：数组new Array、函数function、元素（例外情况：null为Object数据类型但既不可以添加自有属性属性，又不可以给原型添加属性。）。②直接写的基本数据类型不可以添加自有属性，但可以通过直接写的基本数据类型给原型添加属性：boolean、number、string。（例外情况：undefined为基本数据类型但既不可以添加自有属性属性，又不可以给原型添加属性。）③从类中new出来的基本数据类型为Object，既可以添加自有属性，又可以给原型添加属性。 4.既可以通过构造函数（类）给原型添加或修改属性和方法，又可以通过对象直接给原型添加或修改属性和方法。原型由两部分组成，一部分是原型属性与属性值组成的键值对集合，一部分是原型的constructor属性，该属性指向对应的构造函数（类）（每一个函数都有一个prototype原型属性，这个属性是一个指针，指向该函数的原型对象）。构造函数有三个作用，一个作用是给原型添加或修改属性，第二个作用是实例出对象，第三个作用是给构造函数实例出的对象添加各自不同的属性值。构造函数在原型构造对象过程中存在的最大意义即是实例出对象，在对象与原型之间搭建桥梁；第二意义是对实例出的对象添加各自不同的属性值，第三意义是给原型添加或修改属性，由于构造函数实例出的对象也可以直接给原型添加或修改属性，所以这一过程虽然很常用，但意义并不重大。 5.构造函数（类）.prototype.属性名=属性值。——含义为给构造函数、实例对象的原型添加（修改）一个属性。构造函数（类）.prototype={}——含义为用一个新的对象覆盖构造函数的原型对象。此时新原型对象的constructor属性值无法指向当前构造函数，需要定义新原型对象的constructor属性为当前构造函数。 6.对象.proto.属性名=属性值。——含义为给实例对象、构造函数的原型添加（修改）一个属性。7.在JavaScript中，一切对象都有proto属性，而只有函数有Prototype属性。三条原型链：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 ①由字面量或工厂方式定义的对象到Object： 字面量构造对象/工厂方式构造对象P3—_ptoto_→Object ②由构造函数（类）到Object: Person构造函数（类）—_ptoto_→function()—_ptoto_→Object ③由构造函数实例出的对象到Object： P1、P2—_ptoto_→Person(Person构造函数(类)的prototype属性属性值)—_ptoto_→Object 原型链： ①第一行矩形中内容表示原型对象，底行矩形中内容表示构造函数。 ②箭头起始矩形中内容为对象，箭头上的椭圆表示该对象的属性名，箭头指向矩形中内容为该对象的属性值。 ③没有椭圆的箭头表示该对象的_proto_属性值，没有椭圆的箭头组成原型链。 过程： ①所有对象都有_proto_属性，所有的_proto_属性都指向原型。 ②所有原型的_proto_属性都指向object原型，所有构造函数的_proto_属性都指向上一级原型。 ③只有函数有prototype属性，函数的prototype属性指向它的原型。 结论： ①函数的prototype指向它的原型、函数的_proto_指向上一级原型，原型的_proto_指向Object原型。 ②函数—prototype→同级原型；函数—_proto_→上一级原型；原型—construct→同级函数；原型—_proto_→object原型。 ③类即是一个函数，原型的原型即是一个对象（Object），可以设置对象的原型指向一个明确的Object（原型或实例对象）。 例子1： &lt;script&gt; var p1=&#123;name:'Jake'&#125; //字面量 function Person(a)&#123; //工厂方式 var o=new Object(); o.name=a; return o; &#125; p2=Person('Jake') function demo(a)&#123; //构造函数 this.name=a; &#125; p3=new demo('Jake'); &lt;/script&gt; &lt;script&gt; function Person()&#123;&#125; var person1=new Person(); person1.__proto__.name='Jake';//通过对象给原型添加属性。 alert(Person.prototype.name);//通过构造函数访问原型的属性，弹出Jake。 Person.prototype.age='26';//通过构造函数给原型添加属性。 alert(person1.__proto__.age);//通过对象访问原型的属性，弹出26。 alert(person1.name);//访问对象的原型属性，弹出Jake。 alert(Person.age);//弹出undefined，构造函数没有继承原型的属性。注意：每一个函数都有一个name属性，该属性的属性值是指向该函数的函数名。每一个函数都有一个prototype属性，该属性的属性值指向该函数的原型对象。 person1.name='Jason';//给对象新添加一个在原型中同名的自有属性。 alert(person1.name);//弹出Jason。 alert(person1.__proto__.name)//弹出jake，原型对象的同名name属性的属性值并未改变。 &lt;/script&gt;注意：对象可以访问原型的属性，可以继承原型的属性，可以直接给原型添加（修改）属性，可以新添加原型中同名的自有属性，也可以创建原型中所没有的自有属性；构造函数可以访问原型的属性，可以给原型添加（修改）属性，可以给对象添加（修改）自有属性，也可以实例出对象。例子2： &lt;script&gt; function Person()&#123;&#125; Person.prototype=&#123; //创建新的原型，覆盖之前的原型。 constructor:'Person',//定义新原型的构造方法指向Person。 name:[1,2], //给原型对象添加name属性。 &#125; var p1=new Person();//在构造函数中实例（new）出对象p1。 var p2=new Person();//在构造函数中实例（new）出对象p2。 p1.name.push(4);//这种方式并不是给对象p1新添加一个在原型中同名的name自有属性，而是修改p1的原型的name属性值。 alert(p1.name); //获取对象p1的name属性值，弹出1,2,4。 alert(p2.name); //获取对象p2的name属性值，弹出1,2,4。说明原型的name属性值被改变。 &lt;/script&gt;例子3： &lt;script&gt; function Person()&#123;&#125; Person.prototype=&#123; //新的原型覆盖之前的原型。 constructor:'Person', //定义新原型的构造方法指向Person。 name:[1,2], //给原型添加name属性。 say:function()&#123; //给原型添加say属性。 return this.name;//返回原型对象的name属性值。 &#125; &#125; var p1=new Person();//在构造函数中实例（new）出对象p1。 var p2=new Person();//在构造函数中实例（new）出对象p2。 alert(p1.say()); //获取对象p1在原型中继承的say属性，弹出1,2。 p1.name=[1,2,3];//给对象P1新添加一个在原型中同名的name自有属性，属性值为[1,2,3]。 alert(p1.name); //获取p1的name属性值，由于name自有属性的属性值优先级高于原型中继承的同名name属性的属性值，所以弹出1,2,3。 alert(p2.name); //弹出1,2。说明原型的name属性值未被改变。 p1.name.push(4);//通过这种方式修改对象p1的name自有属性的属性值。 alert(p1.name);//弹出1,2,3,4。 alert(p2.name); //弹出1,2。说明原型的name属性值仍未被改变。 p1.name1=['a','b','c'];//在对象p1中增加name1属性。 alert(p1.name1);//弹出a,b,c alert(p2.name1);//弹出undefined。说明原型中并未添加name1属性。 &lt;/script&gt;例子4（对象自定义原型1）： &lt;script&gt; var a = &#123; x: 10,calculate: function(z) &#123; return this.x + this.y + z &#125; &#125;;//字面量构造对象a，未自定义对象a的原型，对象a的原型指向Object。 var b = &#123; y: 20,__proto__: a&#125;;//字面量构造对象b，自定义对象b的原型为对象a。 var c = &#123; y: 30&#125;;//字面量构造对象c，未自定义对象c的原型，对象c的原型指向Object。 alert(b.calculate(30));//弹出60 &lt;/script&gt;例子5（对象自定义原型2）： &lt;script&gt; var a=&#123;age:10,say:function()&#123; alert('hello') &#125;&#125;; var b=&#123;age:20,__proto__:a&#125;; b.say();//弹出hello。 var c=&#123;age:30,__proto__:b&#125;; c.say();//弹出hello。 &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-函数]]></title>
      <url>%2F2015%2F03%2F01%2F06-js%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[函数基础学习总结1.递归：函数调用自身的编程技巧称为递归。注意：①如果要用递归得到数学运算的最终结果，每一个递归函数的返回值即是当前递归次数的最终数学运算结果。②用历史递归函数所有的返回值（函数值）和参数（即递归次数）表示当前递归函数的返回值（函数值）。 例子1：求1+2+3+……10012345678function getSum(n)&#123; if (n==1) &#123; return 1; &#125; else&#123; return getSum(n-1)+n &#125; &#125; alert(getSum(100)) 例子2：求1,1,2,3,5,8……的第25项12345678function getNum(n)&#123; if (n==1||n==2) &#123; return 1; &#125; else&#123; return getNum(n-1)+getNum(n-2); &#125;&#125;alert(getNum(25)) 例子3：求1！+2！+3！+……+10！1234567891011function getSum(n) &#123; if (n == 0) &#123; return 0; &#125; else if (n == 1) &#123; return 1; &#125; else &#123; return getSum(n - 1) + (getSum(n - 1) - getSum(n - 2)) * n; //用上一次和上上一次递归函数的返回值（函数值）以及n表示当前递归函数的返回值（函数值）。 &#125;&#125;alert(getSum(10)) 2.创建一个函数，将html元素的id名作为函数的参数，将该html元素作为函数相对应的返回值。123456789&lt;p id="pid"&gt;123&lt;/p&gt;&lt;div id="div"&gt;abc&lt;/div&gt;&lt;script&gt; function id(a)&#123; return document.getElementById(a) &#125; alert(id("pid").innerHTML) //弹出123 alert(id("div").innerHTML) //弹出abc&lt;/script&gt; 注意：在调用此函数时，实际参数的赋值必须为带引号的ID名。3.创建一个insertAfter(新子节点，旧子节点)函数，该函数可以使新子节点插入到旧子节点之后。12345678910111213141516171819&lt;div id="div1"&gt;第一个DIV&lt;/div&gt;&lt;div id="div2"&gt;第一个DIV&lt;/div&gt;&lt;div id="div3"&gt;第一个DIV&lt;/div&gt;&lt;script&gt; var p=document.createElement("p"); p.innerHTML="这是新增的p元素"; var div1=document.getElementById("div1"); var div2=document.getElementById("div2"); var div3=document.getElementById("div3"); function insertAfter(new1,old1)&#123; var parent=old1.parentNode if (old1==parent.lastChild) &#123; parent.appendChild(new1) &#125; else&#123; parent.insertBefore(new1,old1.nextSibling) &#125; &#125; insertAfter(p,div2);&lt;/script&gt; 注意：createElement()创建元素节点；parentNode父节点；childNodes子节点集；firstChild第一个子节点；lastChild最后个子节点；previousSibling前一个兄弟节点；nextSibling后一个兄弟节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM 基础知识总结]]></title>
      <url>%2F2015%2F02%2F25%2F05-jsDOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1.获取当前文档URL的两个方法：12alert(document.URL); alert(location.href) 2.childNodeschildNodes返回的是所有子节点的集合（不包括子节点的子节点）。这些子节点中可能有元素节点、文本节点、注释节点，而不可能有属性节点（属性节点不是任何节点的子节点）。节点有三个属性：nodeName、nodeType、nodeValue。 我们可以通过节点的nodeName属性获取节点名，nodeType属性获取节点类型，nodeValue属性获取节点值。只有元素节点有子节点（子节点可能是元素节点、文本节点以及注释节点），而元素节点、文本节点、注释节点都有父节点，属性节点既没有子节点又没有父节点。script标签属于元素节点，script标签内所有代码（包括注释内容）为script标签的一个子节点， 并且此子节点类型为文本节点。即： script标签内只有一个子节点，为文本节点，注释内容不被认为是一个注释节点，而被认为是此文本节点的一部分。 注意节点的属性与元素的属性的区别： ①节点有三个属性：nodeName、nodeType、nodeValue。 ②在HTML中，元素和元素的属性都属于节点。 例题：遍历一个元素节点的所有属性节点名、值、类型。 12345&lt;input id="ipt" type="text" value="123" name="qer" /&gt; var ipt=document.getElementById("ipt").attributes; for (n=0;n&lt;ipt.length;n++) &#123; document.write(ipt[n].nodeName+";"+ipt[n].nodeValue+';'+ipt[n].nodeType+"&lt;br /&gt;") &#125; 注意：①ipt为input元素节点的属性节点集合。②for(){}循环遍历input每一个属性节点的名、值、类型。3.一切事物皆对象，对象都拥有属性和方法。属性即对象带有的一些特定性质，方法即对象的使用方式。获取属性（特定性质）不加括号，调用方法（使用方式）要加括号。4.把某个元素节点的非空白子节点存入数组123456789101112131415161718192021var html=document.getElementsByTagName("html")[0];var son=html.childNodes;var arr=new Array();for (n=0;n&lt;html.childNodes.length;n++) &#123; if (son[n].nodeType==3&amp;&amp;son[n].nodeValue.trim()=='') &#123; continue; &#125; else&#123; arr.push(son[n]); &#125;; &#125;;alert(arr.length) //弹出2注意：字符串.trim()方法，将字符串两边的空格删去。字符串.trimleft()方法，将字符串左边的空格删去。字符串.trimright()方法，将字符串右边的空格删去。例子：var str=" ad2cd "alert(str.length);//弹出13alert(str.trimLeft().length);//弹出11alert(str.trimRight().length);//弹出7alert(str.trim().length);//弹出5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BOM 基础知识总结]]></title>
      <url>%2F2015%2F02%2F17%2F04-jsBOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1.window对象的conform方法：显示一个带有提示信息、确认和取消按钮的对话框。语法：conform(“提示信息”)注意：如果将conform方法赋值给一个变量，当处理该对话框时，若点击确认，该变量为布尔数据类型true，若点击取消，该变量为布尔数据类型false。12345678910111213141516原理：var a=confirm(); //弹出对话框alert(a); //若对话框点击确认，则弹出ture；若对话框点击取消，则弹出false。例子：&lt;p id="pid"&gt;文字&lt;/p&gt; &lt;button id="btn"&gt;删除&lt;/button&gt;&lt;script&gt;var p=document.getElementById("pid"),btn=document.getElementById("btn");btn.addEventListener("click",demo)function demo()&#123;var a=confirm("确认删除吗？") if(a)&#123; p.innerHTML=""; alert("已经删除") &#125;&#125; 注意：DOM2级事件处理程序中addEventListener(“事件”,demo)，demo不可加括号。2.script标签中的代码无法操作(document)文档流上方的HTML元素对象。3.计时器123456789101112131415161718192021222324&lt;p id="pid"&gt;&lt;/p&gt;&lt;button onclick="demo2()"&gt;按钮&lt;/button&gt;function demo()&#123; p=document.getElementById("pid") var d=new Date(); var year=d.getFullYear(); var month=d.getMonth(); var dates=d.getDate(); //获得的是日期号 var h=d.getHours(); var m=d.getMinutes(); var s=d.getSeconds(); var fulltime=year+"年"+month+"月"+dates+"日"+h+":"+m+":"+s p.innerHTML=fulltime;&#125;var begin=setInterval(demo,1000); //计时器中调用函数的第一种写法，无括号无引号。 //在句柄中添加函数只能用这种方法，无括号无引号。 // setInterval("demo()",1000); //计时器中调用函数的第二种写法，有括号有引号。 // setInterval(function()&#123;demo()&#125;,1000); //计时器中调用函数的第三种写法。function demo2()&#123; clearInterval(begin)&#125; 注意：var begin=setInterval(demo,1000); begin是统计setInterval函数的个数用的，指明是第几个setInterval函数。在本例题中，begin===1。如果不声明begin变量，clearInterval(begin)中的begin改为1，代码运行效果不变。4.BOM浏览器对象模型(Browser Object Model)：使用对象描述了浏览器的各部分内容。Window对象、计时器、History对象、Location对象、Screen对象、Navigator对象、弹出窗口、Cookies。页面刷新: location.reload(); DOM文档对象模型(Document Object Model)：当一个html页面加载到浏览器的时候，那么浏览器会为每个标签都创建一个对应的对象描述该标签的所有信息，那么我们看到的网页信息实际上就是看到了这些标签对象的信息，如果我们需要操作页面数据，那么我们就可以通过这些标签对象进行操作。 5.Location对象用来更改当前页面的URL123456&lt;button id="btn1"&gt;按钮&lt;/button&gt;document.getElementById("btn1").addEventListener("click",demo)//在句柄中添加函数只能用这种方法，无括号无引号。function demo()&#123; location.href="new_file.html"&#125; 6.在服务器通过location.search获取数据（键值对）。12345678910111213141516171819 &lt;form method="get" action="new_file.html"&gt; &lt;input type="text" name="usename" /&gt; &lt;input type="password" name="passord" /&gt; &lt;input type="submit" /&gt; &lt;/form&gt;页面2(new_file.html)代码： &lt;button id="btn"&gt;按钮&lt;/button&gt; var btn= document.getElementById("btn"); btn.addEventListener("click", demo) function demo() &#123; var a = location.search //取得当前 URL的查询字串(?符号及后面的部分)（字符串格式） alert(a) var b = a.substring(1)//截取从第二位开始的查询字串(substring:子串、子链) var c = b.split("&amp;") //将查询字串以"&amp;"为分隔符分隔为数组 for (i = 0; i &lt; c.length; i++) &#123; alert(c[i]) //逐个弹出每一个数组元素 alert(c[i].split("=")[1])//弹出每一个键值对的结果 &#125;; &#125;; JavaScript中的For…in 声明1234567 for...in 声明用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。for ... in 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作。语法：for (变量 in 对象)&#123;代码块&#125;注意：for ... in 循环在遍历数组时，变量指每一个数组的下标值，对象[变量]指每一个数组元素。for ... in 循环在遍历对象时，变量指每一个对象的属性名，对象[变量]指每一个对象的属性值。例子：获取浏览器(window)对象导航(navigator)子对象的所有属性名和属性值。for (i in window.navigator) &#123; document.write(i+"="+window.navigator[i]+"&lt;br /&gt;")&#125;; 8.B/S结构(Browser/Serve，浏览器/服务器模式)、C/S结构(Client/Serve，客户端和服务器模式)：B/S结构是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。C/S结构是软件系统体系结构，通过它可以充分利用两端环境的优势，将任务合理分配到Client客户端和Serve服务端来实现。 9.document.images：获取文档上所有的img标签的集合。123456789 document.images[0]：获取文档上第1个img标签。 document.forms：获取文档上所有的form标签的集合。 document.forms[n]：获取文档上第n+1个form标签。//举例： &lt;img src="img/shili.jpg" /&gt; &lt;script&gt; document.images[0].style.border="3px solid red" &lt;/script&gt;//注意：这种写法只适用于forms、images两种情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-数组]]></title>
      <url>%2F2015%2F02%2F13%2F03-js%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[数组arry1.随机产生一个大于0小于1的数值(0&lt;x&lt;1)方法为：1Math.random() 随机产生一个大于0小于n的数值(0&lt;x&lt;n)方法为：1Math.random()*n 随机产生一个大于0小于n+1的数值(0&lt;x&lt;n+1)方法为：1Math.random()*(n+1) 随机产生一个从0到n-1的整数(0&lt;=x&lt;=n-1)方法为：1Math.floor(Math.random()*n) Math.round(Math.random()*(n-1)) 随机产生一个从0到n的整数(0&lt;=x&lt;=n)方法为：1Math.floor(Math.random()*(n+1)) Math.round(Math.random()*n) 2.数组的属性：length属性表示数组的长度，即其中元素的个数。3. 数组的常用方法：（1）concat()连结两个或更多的数组12345concatenate连结 语法：数组1.concat(数组2,数组3,……数组n) 返回值：连结后的新数组 var arr1=[1,"2",4]; var arr2=[5,new Object,6] var arr3=arr1.concat(arr2) document.write(arr3+"&lt;br /&gt;") //页面输出返回值1,2,4,5,[object Object],6 （2）join()将数组的所有元素放入一个字符串，元素通过指定的字符串进行分隔。（即是将数组转化为一个字符串，数组元素之间可设置分隔符）。123456语法：数组.join(“分隔符”)，若不设置分隔符join()，默认分隔符为逗号。 返回值：生成的字符串 var arr=[1,"2",4,5,new Object,6] var arr1=arr.join("") document.write(arr1)//页面输出新字符串及返回值 //1245[object Object]6，无空格。 document.write(typeof arr) //页面输出Object 3）pop()删除并返回数组最后一个元素12345语法：数组.pop() 删除数组最后一个元素，并返回数组最后一个元素 返回值：最后一个元素 var arr = [1, "2", 4, 5, new Object, 6] var arr1 = arr.pop() document.write(arr1+"&lt;br/&gt;") //页面输出返回值6。 document.write(arr) //页面输出新数组1,2,4,5,[object Object]。 （4）push()向数组的末尾添加一个或更多的元素，并返回新的长度1234567语法：数组.push(元素1，元素2，……) 返回值：新的长度 例子： var arr=[1,"2",4,5,new Object,6] var arr1=arr.push("12",new Object,3) document.write(arr1+"&lt;br/&gt;") //页面输出返回值9。 document.write(arr) //页面输出新数组1,2,4,5,[object Object],6,12,[object Object],3 含义：arr添加了三个元素，而arr1为数值9。 （5）reverse()颠倒数组中元素的顺序123456789101112语法：数组.reverse() 返回值：颠倒后的数组 例子： var arr=[1,"2",4,5,new Object,6] arr.reverse(); document.write(arr) //页面输出6,[object Object],5,4,2,1 注意：数组.reverse()语法正确，而字符串.reverse()语法错误。 注解：字符串转化为数组的方法为：字符串.split(“分隔符”) 例子： var str=window.prompt("请输入数值") //prompt提示框输入字符串str。 var arr=str.split(""); //字符串str转化为数值arr。 arr.reverse(); //颠倒数组arr元素中的顺序。 var str2=arr.join("") //将数组arr转化为字符串str2，并且没有分隔符。document.write(str+"&lt;br /&gt;"); //页面输出字符串str：546285753 document.write(arr+"&lt;br /&gt;"); //页面输出颠倒顺序后的数组arr：3,5,7,5,8,2,6,4,5 document.write(str2) //页面输出字符串str2：357582645 （6）shift()删除并返回数组的第一个元素语法：数组.shift() 删除数组第一个元素。 返回值：删除的第一个元素。var arr = [&quot;a&quot;, &quot;2&quot;, 4, 5, new Object, 6] var arr1 = arr.shift() document.write(arr1+&quot; “) //页面输出返回值a。 document.write(arr) //页面输出新数组2,4,5,[object Object],6。 （7）slice()从某个指定的数组返回选定的元素，不会修改数组。123456语法：数组.slice(选择元素的起始底，选择元素的结束次序) 返回值：选择的元素。 var arr = ["a", "2", 4, 5, new Object, 6] var arr1 = arr.slice(2,5) document.write(arr1+"&lt;br/&gt;") //页面输出返回值4, 5, new Object document.write(arr) //页面输出a,4,5,[object Object],6。 注意：该方法并不会修改数组。 （8）sort()对数组的元素进行排序1234语法：数组.sort() 返回值：排序之后的数组。 var arr = [21,11,-4,9,45,6] arr.sort() document.write(arr+"&lt;br /&gt;") //页面输出-4,11,21,45,6,9 var t=function (a,b)&#123; return a-b &#125;; arr.sort(t); document.write(arr) //页面输出-4,6,9,11,21,45 （9）splice()从数组中添加/删除元素，然后返回被删除的元素。12345语法：数组.splice(删除元素的起始底，删除元素的个数，增加的元素1，增加的元素2……) 返回值：被删除的元素。 var arr = ["a", "2", 4, 5, new Object, 6] var arr1 = arr.splice(2,1,"bc",3) document.write(arr1+"&lt;br /&gt;")//页面输出4 document.write(arr) //页面输出a,2,bc,3,5,[object Object],6。 （10）tostring()将数组转化为字符串1234语法：数组.tostring() 返回值：字符串 var arr = ["a","2",new Object,6] arr.toString() document.write(arr) //页面输出a,2,[object Object],6 （11）unshift()向数组开头添加一个或更多元素，并返回新的长度12语法：数组.unshift(“元素1”,”元素2”,”元素3”) 返回值：新的长度 var arr = ["a","2",new Object,6] var arr1=arr.unshift(1,"bc") document.write(arr1+"&lt;br /&gt;")//页面输出6 document.write(arr) //页面输出1,bc,a,2,[object Object],6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础语法]]></title>
      <url>%2F2015%2F02%2F09%2F02-js%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[js基本语法1.prompt(“信息提示”,”默认值”)。prompt：提示注意：prompt(“信息提示”,”默认值”)，即使输入number类型内容，提交的也是string数据类型。2.switch条件语句中的条件表达式(case 值:)默认的判断过程是全等（===）判断，即认为”3”不全等于3。（在if else条件语句中，==不识别数据类型，===识别数据类型。）例子：123var a="2" switch(a)&#123; case 2: //不满足该条件表达式alert("a"+"==="+2); //不执行，不弹出 break;default: alert("a"+"!=="+2) //弹出a！==2 &#125; 3.if else条件语句从前向后执行，当满足第一个条件表达式时，执行对应的条件语句，之后跳出if else条件语句。此时即使后面仍有满足条件的表达式，也不再执行相对应的条件语句。4.switch条件语句从前向后执行，break语句用来跳出当前switch语句。switch条件语句中不同的条件表达式(case 值:)之间为或(||)的关系。如果满足一个条件表达(case 值:)式的条件语句后没有break语句，则执行该条件语句和之后第一个break语句之前的所有条件语句。注意：由于不同的条件表达式(case 值:)之间为或(||)的关系，认为该条件表达式和之后第一个break之前所有的条件表达式返回true，执行之间所有的条件语句。5.求1！+2！+3！+……+10！123456var n=1 ;var num= 1;var sum= 0;while(n&lt;=10)&#123; num=num*n;sum=sum+num; n++; &#125;alert(sum) 注意：写循环体时最重要的是明确每一个变量所代表的含义（在Hbuild中标注每一个变量的含义）。求和循环核心三变量：循环次数n、各项数值num、各项总和sum。for循环1234567var num=初值;var sum=0;for (n=1;n&lt;=循环次数;n++) &#123; num=表达式; sum=sum+num; &#125; alert(sum)&#125; 过程：①项数赋值循环次数。②求解各项数值表达式。③初值赋值。while循环1234567var n=1 ;var num=初值;var sum= 0;while(n&lt;=循环次数)&#123; num=表达式; sum=sum+num; n++;&#125;alert(sum) 过程：①项数赋值循环次数。②求解各项数值表达式。③初值赋值。do while循环####12345678var n=1;var num= 初值;var sum=0; do&#123; num=表达式; sum=sum+num; n=n+1; &#125;while(n&lt;=循环次数) alert(sum) 过程：①项数赋值循环次数。②求解各项数值表达式。③初值赋值。6.求和 sum=2+22+222+22222+…..+2222222212345678var n = 1;var num = 0;var sum = 0;while (n &lt;= 8) &#123; num = num*10+2; sum = sum + num; n++; &#125; alert(sum)&#125; 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。7.求和 sum=1/1!+1/2!+1/3!+1/4!+1/5!+…..+1/10!12345678var n = 1;var num = 1;var sum = 0;while (n &lt;=10 ) &#123; num =1/((1/num)*n); sum = sum + num; n++;&#125;alert(sum) 8.有一只猴子吃一堆果子，已知每天吃昨天剩下的果子的一半再多一个，直到第10天才吃完。问原来这堆果子有多少个？12345678910var n = 1;var num = 0;var sum = 0;while (n &lt;= 10) &#123; num =2*num+2; sum = sum + num; n++; &#125; alert(num)&#125; 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。9.国际象棋棋盘有64格，若在第1格放1粒谷；第2格放2粒谷；第3格放4粒谷；第4格放8粒谷……如此一直放到第64格。假设2000000粒谷有一顿重，问需要多少吨谷才够放？123456789var n = 1;var num = 0.5;var sum = 0;while (n &lt;= 64) &#123; num =num*2; sum = sum + num; n++; &#125; alert(sum)&#125; 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。10.求出1-100之间所有除以3余1的数,并求和12345678910var n=1;var num=1;var sum=0;while (n&lt;=100)&#123; num=n; if(num%3==1)&#123; sum=sum+num; &#125; n++; &#125;alert(sum); 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript简介]]></title>
      <url>%2F2015%2F01%2F12%2F01-js%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[js基本特点1. 弱类型语言：没有明确的数据类型声明，所有变量都用var声明。2. 脚本语言：计算机可以直接执行源代码。3. JavaScript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言,可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。4. JavaScript——最流行的脚本语言:弱类型语言、动态性语言、解释性语言。5. JavaScript 组成：ECMAScript（语法）、DOM（文档对象模型）、BOM（浏览器对象模型）。 BOM（Browser Object Model）js初识代码（文档输出的几种写法）1234567document.write("Hello JavaScript1&lt;br/&gt;");//文档输出时换行的第一种写法。 document.write("Hello JavaScript2"+"&lt;br /&gt;");//文档输出时换行的第二种写法。document.writeln("Hello JavaScript2"); //文档输出时文本后加一个空格。alert("Hello\nJavaScript"); //弹出对话框时换行的第一种方法。alert("Hello"+"\n"+"JavaScript"); //弹出对话框时换行的第二种方法。console.log("Hello\nJavaScript"); //控制台输出文本换行的第一种写法。 console.log("Hello"+"\n"+"JavaScript"); //控制台输出文本换行的第二种写法。 注意：①window是一个全局对象，在书写时一般省略。例如：window.document；window.alert；window.consolejs运算符简介加号（+）有两种含义：①算数运算符；②字符串拼接；当相加的各数据全部为数字数据类型时，加号的含义为算数运算符。当相加的各数据有字符串数据类型时，加号的含义在第一个字符串之前为算数运算符，在第一个字符串之后为字符串拼接（括号中的数字为加法）。例子：12var a=2+3+15+"12"+4+"abc"+(2+3)+9+1;console.log(a);//20124abc591; 注意：字符串数据类型必须用双引号包裹script标签script标签可以放在文档的任何位置，通常放在head中，建议写在body之前，使浏览器先加载标签，再运行JavaScript代码，增强用户体验。 script标签必须成对出现，同一个页面中可以出现多对，且从上往下执行。 如果一个script标签用来引入外部JavaScript文件，此标签内不能再写JavaScript代码。(标签内部写代码的时候注意script不能有src属性，值为空也不可以) script标签的type属性可以不写，也可以写text/javascript属性值，这种写法不标准，但是最通用，浏览器支持较好，也可以写application/javascript属性值，这种写法浏览器支持不是特别好。 script标签的async用来设置脚本是否支持异步，默认属性值为“false”，可定义“true”或“async”。 外链JavaScript文件的script标签添加async属性，使下一个script标签的起始执行时间无需等待当前script标签的外链JavaScript执行结束。 标识符（变量、函数、属性的名字，或者函数的参数）JavaScript的变量用来保存值或者表达式，变量的值是可以改变。变量就是计算机在内存中申请一块空间地址的别名，便于程序员识别。变量三要素：①变量名 ②变量值 ③变量类型####（1）当一个变量已声明未赋值时，变量的值为undefined。 （2）变量可以先声明后赋值，也可以声明和赋值同时进行。var a;a=10; （3）可以同时声明多个变量，变量之间用逗号隔开。var a=10,b=37,c=53; （4）所有变量都用var声明，没有严格区分数据类型，属于弱类型语言。 （5）用typeof 来确定变量的数据类型。 var a=1;alert(typeof a);//等价于alert(typeof(a)); （6）语法中可以省略var。 注意：当声明一个变量时，如果没有给他赋值，无法明确知道变量的类型，这样的语言称作弱类型语言。JavaScript是一种弱类型的语言，把所有的变量类型都用var声明，而不用明确声明数据类型，只有真正给变量赋值时，变量的类型才决定，也就是说变量的数据类型是由变量的值的类型来决定的。js数据类型ECMAScript中有5种基本数据类型：undefined、null、boolean、number 、string,还有一种复杂数据类型。 也叫引用数据类型object和函数类型function，当然，function也可以看做object类型。ECMAScript不支持 任何创建自定义类型的机制，所有值都成为以上7 种数据类型之一。在JavaScript中，用typeof()检测变量 的数据类型。对于值或变量使用typeof 操作符会返回如下字符串： 123456789101112131415undefined： 未定义 boolean ：布尔值 string： 字符串 number ：数值 object： 对象或null function ：函数 基本数据类型：数字、字符串、布尔、未定义 var a=1; alert(typeof(a)); //返回number 数字var a="1"; alert(typeof a); //返回string 字符串 var a; alert(typeof (a)) //返回undefined 未定义 var a=false; alert(typeof(a)); //返回boolean 布尔 引用数据类型：函数、数组、对象、日期、空 var a=null; alert(typeof(a)); //返回object 空 var a=function ()&#123;&#125;; alert(typeof a); //返回function（属于object的一种） var a=new Array ; alert(typeof a); //返回object 数组 var a=new Object(); alert(typeof a); //返回object 对象 关键字在JavaScript语法中有特定用途，不能用作标识符，保留字未来可能成为关键字。]]></content>
    </entry>

    
  
  
</search>
