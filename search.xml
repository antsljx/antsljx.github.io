<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[websocket]]></title>
      <url>%2F2017%2F09%2F06%2Fwebsocket%2F</url>
      <content type="text"><![CDATA[WebSocket是HTML5出的东西WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）首先HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，。有交集，但是并不是全部。另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。。通俗来说，你可以用HTTP协议传输非Html数据，就是这样=。=再简单来说，层级不一样。 Websocket是什么样的协议，具体有什么优点首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。1) HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request = Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。 Websocket使用1234567891011121314151617181920212223242526initWebsocket()&#123; let _this = this, qzId = this.$store.state.user_store.data.userInfo.qz_id||0, meetingId = this.$route.query.meetingId||0, wsroot = this.$store.state.config.javaHost.replace(/^(http)/,'ws'), url = wsroot + '/ws-signin?qzId='+qzId+'&amp;meetingId='+meetingId, websocket = new WebSocket(url);//初始化WebSocket // 打开socket websocket.onopen = function (ev) &#123; websocket.send('ping'); &#125;; // 监听socket关闭 websocket.onclose = function (ev) &#123; websocket = null; // _this.initWebsocket(); //当服务端没有搭建的时候 此段代码不要放开 否则会死循环 &#125;; // 监听websocket消息 websocket.onmessage = function (ev) &#123; console.log(ev) websocket.send('ping'); &#125;; websocket.onerror = function (ev) &#123; console.log('error:',ev); &#125;; &#125; 注意IE11才会支持websocket 而且支持上有限制 最多只能连接六个；所以在用完了一定要关闭或者在调用的时候判断是否打开]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[友情链接]]></title>
      <url>%2F2017%2F06%2F01%2Ffriendlink%2F</url>
      <content type="text"><![CDATA[图书ECMAScript 6 入门ECMAScript 6 入门]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用工具方法收集]]></title>
      <url>%2F2017%2F05%2F26%2Ftools01%2F</url>
      <content type="text"><![CDATA[js常用工具post请求1234567891011121314151617//post提交要先实例化 URLSearchParams，然后把要提交数据添加在params中postData : function()&#123; let _this= this; var params = new URLSearchParams(); params.add(this.postData); this.$http.post('/announce/addAnnounce?v=1', params).then(function (data) &#123; _this.data = data.data; &#125;).catch(function (data) &#123; _this.comonvalidation('error',data.msg||'网络请求慢') &#125;)&#125; get请求12345678910111213141516171819202122getData : function()&#123; //格式化url方法 getUrl : function(url, urlData)&#123; let src = url; for(let item in urlData) &#123; src += item + '=' + urlData[item] +'&amp;'; &#125; src = src.substring(0, src.length - 1); return src; &#125;, _this.$http.get(this.getUrl(url,urlData)).then(function(data)&#123; _this.list=data.data.data; if(data.code==0&amp;&amp;data.data.data.length)&#123; _this.total=data.data.total-0; &#125; _this.loading2 =false;//菊花消失 &#125;).catch(function (data) &#123; _this.comonvalidation('error',data.msg||'网络请求慢') &#125;); &#125; 格式化时间12345678910111213formatDate : function(date) &#123; var date = new Date(date*1000); var year = date.getFullYear(); var month = date.getMonth() + 1; var day = date.getDate(); var hour = date.getHours(); var minute = date.getMinutes(); var second = date.getSeconds(); minute = minute&gt;9?minute:'0'+minute; second = second&gt;9?second:'0'+second; var formatDate = year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second; return formatDate; &#125;, html转换1234567891011121314htmlDecode : function(str)&#123; var s = ""; if(!str || !str.length)&#123; return ''; &#125; s = str.replace(/&amp;amp;/g, "&amp;"); s = s.replace(/&amp;lt;/g, "&lt;"); s = s.replace(/&amp;gt;/g, "&gt;"); s = s.replace(/&amp;nbsp;/g, " "); s = s.replace(/&amp;#39;/g, "\'"); s = s.replace(/&amp;quot;/g, "\""); s = s.replace(/&lt;br&gt;/g, "\n"); return s; &#125;, 回退到上一页123goBack:function()&#123; this.$router.back(-1) &#125;, css常用css小工具123word-break:break-all;//长串字母字符不换行word-break : normal; //标点符号不能再开头显示cursor:pointer;//鼠标悬浮小手 超出省略号和box怪异模式12345678910111213 .borderbox()&#123; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; -o-box-sizing: border-box; -ms-box-sizing: border-box;&#125;.words()&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 缩放和旋转12345678910111213 .scale()&#123; -moz-transform:scale(0.5,0.5); -ms-transform:scale(0.5,0.5); -webkit-transform:scale(0.5,0.5); -o-transform:scale(0.5,0.5);&#125;.rotate()&#123; transform:rotate(7deg); -ms-transform:rotate(7deg); /* IE 9 */ -moz-transform:rotate(7deg); /* Firefox */ -webkit-transform:rotate(7deg); /* Safari 和 Chrome */ -o-transform:rotate(7deg); /* Opera */&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue2.0常用语法]]></title>
      <url>%2F2017%2F04%2F25%2Fvue2-0%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[自定义指令 Vue.directive(name,options)指令允许当它的值改变时对元素应用任何DOM操作。比如我们做一个指令v-hidden，当值改变时，更新元素的style值，切换它的可见性。可以这样： 1234567891011121314151617181920&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;button @click="f=!f"&gt;toggle&lt;/button&gt; &lt;input v-hidden="f"&gt;&lt;/input&gt;&lt;/div&gt;&lt;script&gt;Vue.directive('hidden', &#123; update:function(el,binding)&#123; el.style.display = binding.value?'none':'inline' &#125;&#125;)new Vue( &#123; el:'#app', data()&#123; return&#123;f:false&#125; &#125; &#125;)&lt;/script&gt; 解释如下: 通过Vue.directive(name,options)注册一个指令。name为指令名，options为指令选项，其中可以加入钩子函数，比如update，还有更多的钩子函数。 使用指令时，必须在名字前加上前缀v，比如v-hidden。 所有的钩子函数都有如下的参数： el: 指令所绑定的元素，可以用来直接操作 DOM 。binding: 一个对象，包含以下属性：name: 指令名，不包括v-前缀 value: 指令的绑定值 oldValue: 指令绑定的前一个值 expression: 绑定值的未求值形式 arg: 传给指令的参数 modifiers: 包含修饰符的对象。 比如v-my-directive.foo.bar,修饰符对象是{ foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点。 oldVnode: 上一个虚拟节点。 更多到钩子函数：bind: 指令第一次绑定到元素时调用。 inserted: 指令所属元素插入父节点时调用。 update: 指令所属元素绑定值变化是更新。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 指令与元素解绑时调用。 指令可局部化注册到特定组件上，只要在组件内使用：12345678910111213141516171819202122232425262728&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;comp&gt;&lt;/comp&gt;&lt;/div&gt;&lt;script&gt;Vue.component('comp', &#123; template:'&lt;div&gt;&lt;button @click="hate=!hate"&gt;toggle&lt;/button&gt;&lt;div v-hidd="hate"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt;', directives:&#123; hidd:&#123; update:function(el,binding)&#123; console.log(binding.value) el.style.display = binding.value?'none':'block' &#125; &#125; &#125;, data()&#123; return&#123;hate:false,msg:1&#125; &#125;&#125;)new Vue( &#123; el:'#app', data()&#123; return&#123;f:false&#125; &#125; &#125;)&lt;/script&gt; 自定义组件 Vue.component(tag, options)注册一个组件。tag为自定义元素的名字，options同为创建组件的选项。注册完成后，即可以形式引用此组件。如下是一个完整可运行的案例：123456789101112131415161718192021222324252627&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;tag&gt;&lt;/tag&gt;&lt;/div&gt;&lt;script&gt; Vue.component('tag', &#123; template: `&lt;div&gt;one component rule all other&lt;div&gt;` &#125;) new Vue(&#123; el: "#app" &#125;);&lt;/script&gt;//你也可以局部注册，这样注册的组件，仅仅限于执行注册的Vue实例内：&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;tag&gt;&lt;/tag&gt;&lt;/div&gt;&lt;script&gt; var tag = &#123; template: `&lt;div&gt;one component rule all other&lt;div&gt;` &#125; new Vue(&#123; el: "#app", components: &#123;tag&#125; &#125;);&lt;/script&gt; 是HTML本身并不具备的标签，现在由Vue的组件技术引入，因此被称为是自定义标签。这些自定义标签的背后实现常常是标签、脚本、css的集合体。它的内部可以非常复杂，但是对外则以大家习惯的简单的标签呈现。通过本节这个小小案例，组件技术带来的抽象价值已经展现出来一角了。 动态挂接123456789101112131415161718192021222324252627282930313233343536//假设我们有三个组件home、posts、archives，我们可以设置一个定时器，每隔2秒修改一次current，把三个组件的逐个切入到当前挂接点： &lt;component v-bind:is="current"&gt;&lt;/component&gt; &lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;div id="app"&gt; &lt;component v-bind:is="current"&gt; &lt;/component&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; current: 'archive', i :0, b : ['home','posts','archive'] &#125;, components: &#123; home: &#123; template:'&lt;h1&gt;home&lt;/h1&gt;'&#125;, posts: &#123; template:'&lt;h1&gt;posts&lt;/h1&gt;' &#125;, archive: &#123;template:'&lt;h1&gt;archive&lt;/h1&gt;'&#125; &#125;, methods:&#123; a()&#123; this.i = this.i % 3 this.current = this.b[this.i] this.i++ setTimeout(this.a,2000) &#125; &#125;, mounted()&#123; setTimeout(this.a,2000) &#125; &#125;) &lt;/script&gt; 引用组件 子组件设置属性 ref=”属性” 父组件医用子组件值 $refs.属性.内容一个父组件内常常有多个子组件，有时候为了个别处理，需要在父组件代码内引用子组件实例。Vue.js可以通过指令v-ref设置组件的标识符，并在代码内通过$refs+标识符来引用特定组件。接下来举例说明。 1234567891011121314151617181920212223242526272829303132333435//假设一个案例有三个按钮。其中前两个按钮被点击时，每次对自己的计数器累加1；另外一个按//钮可以取得前两个按钮的计数器值，并加总后设置&#123;&#123;total&#125;&#125;的值。此时在第三个按钮的事件代码中，//就需要引用前两个按钮的实例。代码如下： &lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;div id="app"&gt; &#123;&#123; total &#125;&#125; &lt;count ref="b1"&gt;&lt;/count&gt; &lt;count ref="b2"&gt;&lt;/count&gt; &lt;button v-on:click="value"&gt;value&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.component('count', &#123; template: '&lt;button v-on:click="inc"&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123;count: 0&#125; &#125;, methods: &#123; inc: function () &#123; this.count+= 1 &#125; &#125;, &#125;) new Vue(&#123; el: '#app', data: &#123;total:0&#125;, methods: &#123; value: function () &#123; this.total = this.$refs.b1.count+this.$refs.b2.count &#125; &#125; &#125;) &lt;/script&gt; //标签button使用ref设置两个按钮分为为b1、b2，随后在父组件代码内通过$refs引用它们。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack入门]]></title>
      <url>%2F2016%2F11%2F23%2Fwebpack2-2%2F</url>
      <content type="text"><![CDATA[基本命令1234webpack // 最基本的启动webpack的方法webpack -w // 提供watch方法；实时进行打包更新webpack -p // 对打包后的文件进行压缩webpack -d // 提供source map，方便调式代码 全局安装1npm install webpack -g 项目安装 进入项目目录 确定已经有 package.json，没有就通过 npm init 创建 安装 webpack 依赖 1npm install webpack --save-dev 使用ES6123456789//安装 babel-loader： npm install babel-loader --save-dev //安装转码规则： npm install babel-preset-es2015 --save-dev//ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个npm install --save-dev babel-preset-stage-0npm install --save-dev babel-preset-stage-1npm install --save-dev babel-preset-stage-2npm install --save-dev babel-preset-stage-3 参考格式1234&#123; test: /\.js$/, loader: 'babel-loader?presets[]=es2015,presets[]=stage-0'&#125; 编译css1234 //安装css-loader： npm install css-loader --save-dev//安装style-loader npm install style-loader --save-dev 参考格式1234&#123; test: /\.css$/, loaders: ['style-loader', 'css-loader', 'autoprefixer-loader']&#125; 编译less123npm install less --save-dev//安装less-loader： npm install less-loader --save-dev 参考格式1234&#123; test: /\.less/, loaders: ['style-loader', 'css-loader', 'autoprefixer-loader', 'less-loader'],&#125; 使用autoprefixer自动补上浏览器兼容1npm install autoprefixer-loader --save-dev 参考格式12345678&#123; test: /\.css$/, loaders: ['style-loader', 'css-loader', 'autoprefixer-loader'] &#125;, &#123; test: /\.less/, loaders: ['style-loader', 'css-loader', 'autoprefixer-loader', 'less-loader'], &#125; 编译文件12//安装file-loader： npm install file-loader --save-dev 参考格式：1234&#123; test: /\.(eot|woff|svg|ttf|woff2|gif)(\?|$)/, loader: 'file-loader?name=[hash].[ext]'&#125; 编译图片1npm install url-loader --save-dev 参考格式1234&#123; test: /\.(png|jpg)$/, loader: 'url-loader?limit=1200&amp;name=[hash].[ext]'&#125; 编译JSX12npm install jsx-loader --save-devnpm install babel-preset-react --save-dev 参考格式1234&#123; test: /\.jsx$/, loaders: ['jsx-loader', 'babel?presets[]=es2015,presets[]=stage-0,presets[]=react']&#125; webpack.config.js文件代码1234567891011121314151617181920212223242526272829303132333435363738var webpack = require('webpack'); module.exports = &#123; entry: &#123; app: './app', //编译的入口文件 index: './index', //编译的入口文件 &#125;, output: &#123; publicPath: '/build/', //服务器根路径 path: './build', //编译到当前目录 filename: '[name].js' //编译后的文件名字 &#125;, module: &#123; loaders: [&#123; test: /\.js$/, loader: 'babel-loader?presets=es2015' &#125;, &#123; test: /\.css$/, loaders: ['style-loader', 'css-loader', 'autoprefixer-loader'] &#125;, &#123; test: /\.less/, loaders: ['style-loader', 'css-loader', 'autoprefixer-loader', 'less-loader'], &#125;, &#123; test: /\.(eot|woff|svg|ttf|woff2|gif)(\?|$)/, loader: 'file-loader?name=[hash].[ext]' &#125;, &#123; test: /\.(png|jpg)$/, loader: 'url-loader?limit=1200&amp;name=[hash].[ext]' //注意后面那个limit的参数，当你图片大小小于这个限制的时候，会自动启用base64编码图片 &#125; ] &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin('common.js') //将公用模块，打包进common.js ], resolve: &#123; extensions: ['', '.js', '.jsx'] //后缀名自动补全 &#125; &#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 自定义过滤器]]></title>
      <url>%2F2016%2F10%2F17%2Fvue%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
      <content type="text"><![CDATA[基础类似于自定义指令，可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值： 1234&lt;span v-text="message | reverse"&gt;&lt;/span&gt;Vue.filter('reverse', function (value) &#123; return value.split('').reverse().join('')&#125;) 过滤器函数可以接收任意数量的参数： 12345Vue.filter('wrap', function (value, begin, end) &#123; return begin + value + end&#125;)&lt;!-- 'hello' =&gt; 'before hello after' --&gt;&lt;span v-text="message | wrap 'before' 'after'"&gt;&lt;/span&gt; 双向过滤器目前我们使用过滤器都是在把来自模型的值显示在视图之前转换它。不过也可以定义一个过滤器，在把来自视图（input 元素）的值写回模型之前转化它： 12345678910111213Vue.filter('currencyDisplay', &#123; // model -&gt; view // 在更新 `&lt;input&gt;` 元素之前格式化值 read: function(val) &#123; return '$'+val.toFixed(2) &#125;, // view -&gt; model // 在写回数据之前格式化值 write: function(val, oldVal) &#123; var number = +val.replace(/[^\d.]/g, '') return isNaN(number) ? 0 : parseFloat(number.toFixed(2)) &#125;&#125;) 动态参数如果过滤器参数没有用引号包起来，则它会在当前 vm 作用域内动态计算。另外，过滤器函数的 this 始终指向调用它的 vm。例如： 123456&lt;input v-model="userInput"&gt;&lt;span&gt;&#123;&#123;msg | concat userInput&#125;&#125;&lt;/span&gt;Vue.filter('concat', function (value, input) &#123; // `input` === `this.userInput` return value + input&#125;) 也可以用表达式达到相同的结果，但是对于更复杂的逻辑——需要多于一个语句，这时需要将它放到计算属性或自定义过滤器中。内置过滤器 filterBy 和 orderBy，根据所属 Vue 实例的当前状态，过滤/排序传入的数组。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 自定义指令]]></title>
      <url>%2F2016%2F10%2F14%2Fvue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[基础除了内置指令，Vue.js 也允许注册自定义指令。自定义指令提供一种机制将数据的变化映射为 DOM 行为。 可以用 Vue.directive(id, definition) 方法注册一个全局自定义指令，它接收两个参数指令 ID 与定义对象。也可以用组件的 directives 选项注册一个局部自定义指令。 钩子函数定义对象可以提供几个钩子函数（都是可选的）： bind：只调用一次，在指令第一次绑定到元素上时调用。 update： 在 bind 之后立即以初始值为参数第一次调用，之后每当绑定值变化时调用，参数为新值与旧值。 unbind：只调用一次，在指令从元素上解绑时调用。 12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div id="" v-my-directive ='msg'&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.directive('my-directive',&#123; bind:function()&#123; console.log('this bind') &#125;, update:function(value)&#123; this.el.innerHTML = 'name - ' + this.name + '&lt;br&gt;' + 'expression - ' + this.expression + '&lt;br&gt;' + 'argument - ' + this.arg + '&lt;br&gt;' + 'modifiers - ' + JSON.stringify(this.modifiers) + '&lt;br&gt;' + 'value - ' + value &#125;, undind:function()&#123; console.log('unununun') &#125; &#125;) var demo = new Vue(&#123; el:'#app', data:&#123; msg:'hello' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 所有的钩子函数将被复制到实际的指令对象中，钩子内 this 指向这个指令对象。这个对象暴露了一些有用的属性： el: 指令绑定的元素。 vm: 拥有该指令的上下文 ViewModel。 expression: 指令的表达式，不包括参数和过滤器。 arg: 指令的参数。 name: 指令的名字，不包含前缀。 modifiers: 一个对象，包含指令的修饰符。 descriptor: 一个对象，包含指令的解析结果。 你应当将这些属性视为只读的，不要修改它们。你也可以给指令对象添加自定义属性，但是注意不要覆盖已有的内部属性。 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令可以使用任意合法的 JavaScript 表达式： 12345&lt;div v-demo="&#123; color: 'white', text: 'hello!' &#125;"&gt;&lt;/div&gt;Vue.directive('demo', function (value) &#123; console.log(value.color) // "white" console.log(value.text) // "hello!"&#125;) 字面修饰符当指令使用了字面修饰符，它的值将按普通字符串处理并传递给 update 方法。update 方法将只调用一次，因为普通字符串不能响应数据变化。 1234&lt;div v-demo.literal="foo bar baz"&gt;Vue.directive('demo', function (value) &#123; console.log(value) // "foo bar baz"&#125;) 元素指令有时我们想以自定义元素的形式使用指令，而不是以特性的形式。这与 Angular 的 “E” 指令非常相似。元素指令可以看做是一个轻量组件。可以像下面这样注册一个自定义元素指令： 12345678910Vue.elementDirective('my-directive', &#123; // API 同普通指令 bind: function () &#123; // 操作 this.el... &#125;&#125;)//不这样写：&lt;div v-my-directive&gt;&lt;/div&gt;//这样写：&lt;my-directive&gt;&lt;/my-directive&gt; 元素指令不能接受参数或表达式，但是它可以读取元素的特性从而决定它的行为。 迥异于普通指令，元素指令是终结性的，这意味着，一旦 Vue 遇到一个元素指令，它将跳过该元素及其子元素——只有该元素指令本身可以操作该元素及其子元素。 高级选项params自定义指令可以接收一个 params 数组，指定一个特性列表，Vue 编译器将自动提取绑定元素的这些特性。例如 1234567&lt;div v-example a="hi"&gt;&lt;/div&gt; Vue.directive('example', &#123; params: ['a'], bind: function () &#123; console.log(this.params.a) // -&gt; "hi" &#125; &#125;) 此 API 也支持动态属性。this.params[key] 会自动保持更新。另外，可以指定一个回调，在值变化时调用： 123456789&lt;div v-example v-bind:a="someValue"&gt;&lt;/div&gt;Vue.directive('example', &#123; params: ['a'], paramWatchers: &#123; a: function (val, oldVal) &#123; console.log('a changed!') &#125; &#125;&#125;) 类似于 props，指令参数的名字在 JavaScript 中使用 camelCase 风格，在 HTML 中对应使用 kebab-case 风格。例如，假设在模板里有一个参数 disable-effect，在 JavaScript 里以 disableEffect 访问它 deep如果自定义指令用在一个对象上，当对象内部属性变化时要触发 update，则在指令定义对象中指定 deep: true。 123456&lt;div v-my-directive="obj"&gt;&lt;/div&gt;Vue.directive('my-directive', &#123; deep: true, update: function (obj) &#123; // 在 `obj` 的嵌套属性变化时调用&#125;) 如果指令想向 Vue 实例写回数据，则在指令定义对象中指定 twoWay: true 。该选项允许在指令中使用 this.set(value): 123456789101112131415Vue.directive('example', &#123; twoWay: true, bind: function () &#123; this.handler = function () &#123; // 将数据写回 vm // 如果指令这样绑定 v-example="a.b.c" // 它将用给定值设置 `vm.a.b.c` this.set(this.el.value) &#125;.bind(this) this.el.addEventListener('input', this.handler) &#125;, unbind: function () &#123; this.el.removeEventListener('input', this.handler) &#125;&#125;) acceptStatement传入 acceptStatement:true 可以让自定义指令接受内联语句，就像 v-on 那样： 12345678&lt;div v-my-directive="a++"&gt;&lt;/div&gt;Vue.directive('my-directive', &#123; acceptStatement: true, update: function (fn) &#123; // 传入值是一个函数 // 在调用它时将在所属实例作用域内计算 "a++" 语句 &#125;&#125;) 明智地使用，因为通常你要在模板中避免副效应。 terminalVue 通过递归遍历 DOM 树来编译模块。但是当它遇到 terminal 指令时会停止遍历这个元素的后代元素。这个指令将接管编译这个元素及其后代元素的任务。v-if 和 v-for 都是 terminal 指令。 编写自定义 terminal 指令是一个高级话题，需要较好的理解 Vue 的编译流程，但这不是说不可能编写自定义 terminal 指令。用 terminal: true 指定自定义 terminal 指令，可能还需要用 Vue.FragmentFactory 来编译 partial。下面是一个自定义 terminal 指令，它编译它的内容模板并将结果注入到页面的另一个地方： 1234567891011121314151617181920212223242526var FragmentFactory = Vue.FragmentFactoryvar remove = Vue.util.removevar createAnchor = Vue.util.createAnchorVue.directive('inject', &#123; terminal: true, bind: function () &#123; var container = document.getElementById(this.arg) this.anchor = createAnchor('v-inject') container.appendChild(this.anchor) remove(this.el) var factory = new FragmentFactory(this.vm, this.el) this.frag = factory.create(this._host, this._scope, this._frag) this.frag.before(this.anchor) &#125;, unbind: function () &#123; this.frag.remove() remove(this.anchor) &#125;&#125;)&lt;div id="modal"&gt;&lt;/div&gt;...&lt;div v-inject:modal&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;p&gt;body&lt;/p&gt; &lt;p&gt;footer&lt;/p&gt;&lt;/div&gt; 如果你想编写自定义 terminal 指令，建议你通读内置 terminal 指令的源码，如 v-if 和 v-for，以便更好地了解 Vue 的内部机制。 priority可以给指令指定一个优先级。如果没有指定，普通指令默认是 1000， terminal 指令默认是 2000。同一个元素上优先级高的指令会比其它指令处理得早一些。优先级一样的指令按照它在元素特性列表中出现的顺序依次处理，但是不能保证这个顺序在不同的浏览器中是一致的。 可以在 API 中查看内置指令的优先级。另外，流程控制指令 v-if 和 v-for 在编译过程中始终拥有最高的优先级。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 组件]]></title>
      <url>%2F2016%2F09%2F30%2Fvue%E7%BB%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[什么是组件？组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 使用组件注册前面已经提到，可以用 Vue.extend() 创建一个组件构造器： 123var MyComponent = Vue.extend(&#123; // 选项...&#125;) 要把这个构造器用作组件，需要用Vue.component(tag, constructor) 注册 ： 12/ 全局注册组件，tag 为 my-componentVue.component('my-component', MyComponent) 对于自定义标签名字，Vue.js 不强制要求遵循 W3C 规则（小写，并且包含一个短杠）。 组件在注册之后，便可以在父实例的模块中以自定义元素 &lt; my-component &gt; 的形式使用。要确保在初始化根实例之前注册了组件： 123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; //定义 var myComponent = Vue.extend(&#123; template:'&lt;div&gt; component test!&lt;/div&gt;' &#125;) //注册 Vue.component('my-component',myComponent) //创建根实例 new Vue(&#123; el:'#app' &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 渲染为： 1&lt;div&gt; component test!&lt;/div&gt; 注意组件的模板替换了自定义元素，自定义元素的作用只是作为一个挂载点。可以用实例选项 replace 决定是否替换。 局部注册不需要全局注册每个组件。可以让组件只能用在其它组件内，用实例选项 components 注册： 123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;my-parent&gt; &lt;/my-parent&gt; &lt;/div&gt; &lt;script&gt; //定义子组件 var Child = Vue.extend(&#123; template:'&lt;div&gt; component test Child!&lt;/div&gt;' &#125;) //定义父组件 var Parent = Vue.extend(&#123; template:'&lt;div&gt;&lt;my-child&gt;&lt;/my-child&gt;&lt;/div&gt;', components: &#123; // &lt;my-child&gt; 只能用在父组件模板内 'my-child': Child &#125; &#125;) //注册 Vue.component('my-parent',Parent) //创建根实例 new Vue(&#123; el:'#app' &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这种封装也适用于其它资源，如指令、过滤器和过渡 注册语法糖为了让事件更简单，可以直接传入选项对象而不是构造器给 Vue.component() 和 component 选项。Vue.js 在背后自动调用 Vue.extend()： 123456789101112// 在一个步骤中扩展与注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// 局部注册也可以这么做var Parent = Vue.extend(&#123; components: &#123; 'my-component': &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;' &#125; &#125;&#125;) 组件选项问题传入 Vue 构造器的多数选项也可以用在 Vue.extend() 中，不过有两个特例： data 和 el。试想如果我们简单地把一个对象作为 data 选项传给 Vue.extend()： 1234var data = &#123; a: 1 &#125;var MyComponent = Vue.extend(&#123; data: data&#125;) 这么做的问题是 MyComponent 所有的实例将共享同一个 data 对象！这基本不是我们想要的，因此我们应当使用一个函数作为 data 选项，让这个函数返回一个新对象： 12345var MyComponent = Vue.extend(&#123; data: function () &#123; return &#123; a: 1 &#125; &#125;&#125;) 同理，el 选项用在 Vue.extend() 中时也须是一个函数。 模板解析Vue 的模板是 DOM 模板，使用浏览器原生的解析器而不是自己实现一个。相比字符串模板，DOM 模板有一些好处，但是也有问题，它必须是有效的 HTML 片段。一些 HTML 元素对什么元素可以放在它里面有限制。常见的限制： Vue 的模板是 DOM 模板，使用浏览器原生的解析器而不是自己实现一个。相比字符串模板，DOM 模板有一些好处，但是也有问题，它必须是有效的 HTML 片段。一些 HTML 元素对什么元素可以放在它里面有限制。常见的限制： a 不能包含其它的交互元素（如按钮，链接）ul 和 ol 只能直接包含 liselect 只能包含 option 和 optgrouptable 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgrouptr 只能直接包含 th 和 td 在实际中，这些限制会导致意外的结果。尽管在简单的情况下它可能可以工作，但是你不能依赖自定义组件在浏览器验证之前的展开结果。例如 1&lt;my-select&gt;&lt;option&gt;...&lt;/option&gt;&lt;/my-select&gt; 不是有效的模板，即使 my-select 组件最终展开为 1&lt;select&gt;...&lt;/select&gt; 自定义标签（包括自定义元素和特殊标签，如 component 、 template 、 partial ）不能用在 ul, select, table 等对内部元素有限制的标签内。放在这些元素内部的自定义标签将被提到元素的外面，因而渲染不正确。 对于自定义元素，应当使用 is 特性：12345678910&lt;table&gt; &lt;tr is="my-component"&gt;&lt;/tr&gt;&lt;/table&gt;&lt;template&gt; 不能用在 &lt;table&gt; 内，这时应使用 &lt;tbody&gt;，&lt;table&gt; 可以有多个 &lt;tbody&gt;：&lt;table&gt; &lt;tbody v-for="item in items"&gt; &lt;tr&gt;Even row&lt;/tr&gt; &lt;tr&gt;Odd row&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; Props 使用 Props 传递数据组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。 “prop” 是组件数据的一个字段，期望从父组件传下来。子组件需要显式地用 props 选项 声明 props： 123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;my-parent msg='hello'&gt; &lt;/my-parent&gt; &lt;/div&gt; &lt;script&gt; Vue.component('my-parent',&#123; props:['msg'], template:'&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;' &#125;) //创建根实例 new Vue(&#123; el:'#app' &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; HTML 特性不区分大小写。名字形式为 camelCase 的 prop 用作特性时，需要转为 kebab-case（短横线隔开）： 1234567Vue.component('child', &#123; // camelCase in JavaScript props: ['myMessage'], template: '&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'&#125;)&lt;!-- kebab-case in HTML --&gt;&lt;child my-message="hello!"&gt;&lt;/child&gt; 动态 Props类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 绑定动态 Props 到父组件的数据。每当父组件的数据变化时，也会传导给子组件： 12345&lt;div&gt; &lt;input v-model="parentMsg"&gt; &lt;br&gt; &lt;child v-bind:my-message="parentMsg"&gt;&lt;/child&gt;&lt;/div&gt; 使用 v-bind 的缩写语法通常更简单： 1&lt;child :my-message="parentMsg"&gt;&lt;/child&gt; 实例 12345678910111213141516171819202122232425262728&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model = 'mymsg'&gt; &lt;my-parent :msg='mymsg'&gt; &lt;/my-parent&gt; &lt;/div&gt; &lt;script&gt; Vue.component('my-parent',&#123; props:['msg'], template:'&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;' &#125;) //创建根实例 new Vue(&#123; el:'#app', data:&#123; mymsg:'hello' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 字面量语法 vs. 动态语法初学者常犯的一个错误是使用字面量语法传递数值： 12&lt;!-- 传递了一个字符串 "1" --&gt;&lt;comp some-prop="1"&gt;&lt;/comp&gt; 因为它是一个字面 prop，它的值以字符串 “1” 而不是以实际的数字传下去。如果想传递一个实际的 JavaScript 数字，需要使用动态语法，从而让它的值被当作 JavaScript 表达式计算： 12&lt;!-- 传递实际的数字 --&gt;&lt;comp :some-prop="1"&gt;&lt;/comp&gt; Prop 绑定类型prop 默认是单向绑定：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。不过，也可以使用 .sync 或 .once 绑定修饰符显式地强制双向或单次绑定： 比较语法： 123456&lt;!-- 默认为单向绑定 --&gt;&lt;child :msg="parentMsg"&gt;&lt;/child&gt;&lt;!-- 双向绑定 --&gt;&lt;child :msg.sync="parentMsg"&gt;&lt;/child&gt;&lt;!-- 单次绑定 --&gt;&lt;child :msg.once="parentMsg"&gt;&lt;/child&gt; 双向绑定会把子组件的 msg 属性同步回父组件的 parentMsg 属性。单次绑定在建立之后不会同步之后的变化。 注意如果 prop 是一个对象或数组，是按引用传递。在子组件内修改它会影响父组件的状态，不管是使用哪种绑定类型。 Prop 验证组件可以为 props 指定验证要求。当组件给其他人使用时这很有用，因为这些验证要求构成了组件的 API，确保其他人正确地使用组件。此时 props 的值是一个对象，包含验证要求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Vue.component('example', &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 (1.0.21+) propM: [String, Number], // 必需且是字符串 propB: &#123; type: String, required: true &#125;, // 数字，有默认值 propC: &#123; type: Number, default: 100 &#125;, // 对象/数组的默认值应当由一个函数返回 propD: &#123; type: Object, default: function () &#123; return &#123; msg: 'hello' &#125; &#125; &#125;, // 指定这个 prop 为双向绑定 // 如果绑定类型不对将抛出一条警告 propE: &#123; twoWay: true &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125;, // 转换函数（1.0.12 新增） // 在设置值之前转换值 propG: &#123; coerce: function (val) &#123; return val + '' // 将值转换为字符串 &#125; &#125;, propH: &#123; coerce: function (val) &#123; return JSON.parse(val) // 将 JSON 字符串转换为对象 &#125; &#125; &#125;&#125;) type 可以是下面原生构造器： String Number Boolean Function Object Array type 也可以是一个自定义构造器，使用 instanceof 检测。 当 prop 验证失败了，Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。 父子组件通信父链 子组件可以用 this.$parent 访问它的父组件。根实例的后代可以用 this.$root 访问它。父组件有一个数组 this.$children，包含它所有的子元素。 尽管可以访问父链上任意的实例，不过子组件应当避免直接依赖父组件的数据，尽量显式地使用 props 传递数据。另外，在子组件中修改父组件的状态是非常糟糕的做法，因为： 这让父组件与子组件紧密地耦合； 只看父组件，很难理解父组件的状态。因为它可能被任意子组件修改！理想情况下，只有组件自己能修改它的状态。 自定义事件 Vue 实例实现了一个自定义事件接口，用于在组件树中通信。这个事件系统独立于原生 DOM 事件，用法也不同。 每个 Vue 实例都是一个事件触发器： 使用 $on() 监听事件； 使用 $emit() 在它上面触发事件； 使用 $dispatch() 派发事件，事件沿着父链冒泡； 使用 $broadcast() 广播事件，事件向下传导给所有的后代。 不同于 DOM 事件，Vue 事件在冒泡过程中第一次触发回调之后自动停止冒泡，除非回调明确返回 true。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 子组件模板 --&gt;&lt;template id="child-template"&gt; &lt;input v-model="msg"&gt; &lt;button v-on:click="notify"&gt;Dispatch Event&lt;/button&gt;&lt;/template&gt;&lt;!-- 父组件模板 --&gt;&lt;div id="events-example"&gt; &lt;p&gt;Messages: &#123;&#123; messages | json &#125;&#125;&lt;/p&gt; &lt;child&gt;&lt;/child&gt;&lt;/div&gt;// 注册子组件// 将当前消息派发出去Vue.component('child', &#123; template: '#child-template', data: function () &#123; return &#123; msg: 'hello' &#125; &#125;, methods: &#123; notify: function () &#123; if (this.msg.trim()) &#123; this.$dispatch('child-msg', this.msg) this.msg = '' &#125; &#125; &#125;&#125;)// 初始化父组件// 将收到消息时将事件推入一个数组var parent = new Vue(&#123; el: '#events-example', data: &#123; messages: [] &#125;, // 在创建实例时 `events` 选项简单地调用 `$on` events: &#123; 'child-msg': function (msg) &#123; // 事件回调内的 `this` 自动绑定到注册它的实例上 this.messages.push(msg) &#125; &#125;&#125;) 使用 v-on 绑定自定义事件从父组件的代码中不能直观的看到 “child-msg” 事件来自哪里。如果我们在模板中子组件用到的地方声明事件处理器会更好。为此子组件可以用 v-on 监听自定义事件： 1&lt;child v-on:child-msg="handleIt"&gt;&lt;/child&gt; 当子组件触发了 “child-msg” 事件，父组件的 handleIt 方法将被调用。所有影响父组件状态的代码放到父组件的 handleIt 方法中；子组件只关注触发事件。 子组件索引尽管有 props 和 events，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 v-ref 为子组件指定一个索引 ID。例如： 123456&lt;div id="parent"&gt; &lt;user-profile v-ref:profile&gt;&lt;/user-profile&gt;&lt;/div&gt;var parent = new Vue(&#123; el: '#parent' &#125;)// 访问子组件var child = parent.$refs.profile v-ref 和 v-for 一起用时，ref 是一个数组或对象，包含相应的子组件。 使用 Slot 分发内容在使用组件时，常常要像这样组合它们： 1234&lt;app&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;app-footer&gt;&lt;/app-footer&gt;&lt;/app&gt; 注意两点： app 组件不知道它的挂载点会有什么内容，挂载点的内容是由 app 的父组件决定的。 app 组件很可能有它自己的模板。 为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个处理称为内容分发（或 “transclusion”，如果你熟悉 Angular）。Vue.js 实现了一个内容分发 API，参照了当前 Web 组件规范草稿，使用特殊的 slot 元素作为原始内容的插槽。 编译作用域在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为： 123&lt;child-component&gt; &#123;&#123; msg &#125;&#125;&lt;/child-component&gt; msg 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是： 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译 一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法： 12&lt;!-- 无效 --&gt;&lt;child-component v-show="someChildProperty"&gt;&lt;/child-component&gt; 假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。 如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做： 123456789Vue.component('child-component', &#123; // 有效，因为是在正确的作用域内 template: '&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;) 类似地，分发内容是在父组件作用域内编译 单个 Slot父组件的内容将被抛弃，除非子组件模板包含 slot。如果子组件模板只有一个没有特性的 slot，父组件的整个内容将插到 slot 所在的地方并替换它。 标签的内容视为回退内容。回退内容在子组件的作用域内编译，当宿主元素为空并且没有内容供插入时显示这个回退内容。 假定 my-component 组件有下面模板： 123456&lt;div&gt; &lt;h1&gt;This is my component!&lt;/h1&gt; &lt;slot&gt; 如果没有分发内容则显示我。 &lt;/slot&gt;&lt;/div&gt; 父组件模板： 1234&lt;my-component&gt; &lt;p&gt;This is some original content&lt;/p&gt; &lt;p&gt;This is some more original content&lt;/p&gt;&lt;/my-component&gt; 渲染结果： 12345&lt;div&gt; &lt;h1&gt;This is my component!&lt;/h1&gt; &lt;p&gt;This is some original content&lt;/p&gt; &lt;p&gt;This is some more original content&lt;/p&gt;&lt;/div&gt; 具名 Slotslot 元素可以用一个特殊特性 name 配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。 仍然可以有一个匿名 slot，它是默认 slot，作为找不到匹配的内容片段的回退插槽。如果没有默认的 slot，这些找不到匹配的内容片段将被抛弃。 例如，假定我们有一个 multi-insertion 组件，它的模板为： 12345&lt;div&gt; &lt;slot name="one"&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot name="two"&gt;&lt;/slot&gt;&lt;/div&gt; 父组件模板： 12345&lt;multi-insertion&gt; &lt;p slot="one"&gt;One&lt;/p&gt; &lt;p slot="two"&gt;Two&lt;/p&gt; &lt;p&gt;Default A&lt;/p&gt;&lt;/multi-insertion&gt; 渲染结果为： 12345&lt;div&gt; &lt;p slot="one"&gt;One&lt;/p&gt; &lt;p&gt;Default A&lt;/p&gt; &lt;p slot="two"&gt;Two&lt;/p&gt;&lt;/div&gt; 在组合组件时，内容分发 API 是非常有用的机制。 动态组件多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 元素，动态地绑定到它的 is 特性： 1234567891011121314new Vue(&#123; el: 'body', data: &#123; currentView: 'home' &#125;, components: &#123; home: &#123; /* ... */ &#125;, posts: &#123; /* ... */ &#125;, archive: &#123; /* ... */ &#125; &#125;&#125;)&lt;component :is="currentView"&gt; &lt;!-- 组件在 vm.currentview 变化时改变 --&gt;&lt;/component&gt; activate 钩子在切换组件时，切入组件在切入前可能需要进行一些异步操作。为了控制组件切换时长，给切入组件添加 activate 钩子： 123456789101112&lt;!-- 先淡出再淡入 --&gt;&lt;component :is="view" transition="fade" transition-mode="out-in"&gt;&lt;/component&gt;.fade-transition &#123; transition: opacity .3s ease;&#125;.fade-enter, .fade-leave &#123; opacity: 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios倒计时bug解决]]></title>
      <url>%2F2016%2F09%2F26%2Fios%E5%80%92%E8%AE%A1%E6%97%B6bug%E8%A7%A3%E5%86%B3%2F</url>
      <content type="text"><![CDATA[屏幕触摸或者滑动动态效果全部停止页面倒计时在屏幕触摸或者滑动情况下会停止，下一次计时的时候会在上一次开始，计时时间会比实际时间长。 解决办法：##### 通过设置Date()来确定时间过了多久进行计时。具体实现代码，如下：1234567891011121314151617181920212223 &lt;body&gt; &lt;div id="timed"&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; function lefttimes(times,DOM)&#123; var starttime=new Date(),satrtm=starttime.getMinutes(),starts=starttime.getSeconds(),starttimes =Math.floor(60*satrtm)-0+starts,sh,lefttime; function FreshTime()&#123; if(times&lt;=0||lefttime&lt;=0)&#123; clearInterval(sh); &#125;else&#123; var endtime=new Date(),endm=endtime.getMinutes(),ends=endtime.getSeconds(),endtimes =Math.floor(60*endm)-0+ends; lefttime =times - endtimes + starttimes; document.getElementById(DOM).innerHTML=lefttime+"秒"; &#125; &#125; sh=setInterval(FreshTime,1000); &#125; // 调用方法,66:倒计时时间 timed:显示时间的dom节点id lefttimes(66,'timed') &lt;/script&gt; &lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 过渡]]></title>
      <url>%2F2016%2F09%2F21%2Fvue%E8%BF%87%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[为了应用过渡效果，需要在目标元素上使用 transition 特性：1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .dv&#123; width: 200px; height: 100px; background-color: #00D4FB; &#125; .my-transition&#123; transition:all 2s; width: 400px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" id="" v-on:click="showdv" value="showdiv" /&gt; &lt;div id="dv" class="dv" v-if="shows" transition="my"&gt;111111&lt;/div&gt; &#123;&#123;shows&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; shows:true &#125;, methods:&#123; showdv:function()&#123; document.getElementById('dv').style.width='500px'; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; transition 特性可以与下面指令一起用：v-ifv-showv-for （只在插入和删除时触发，使用 vue-animated-list 插件） CSS 过渡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; /* 必需 */ .expand-transition &#123; transition: all .3s ease; height: 30px; padding: 10px; background-color: #eee; overflow: hidden; &#125; /* .expand-enter 定义进入的开始状态 */ /* .expand-leave 定义离开的结束状态 */ .expand-enter, .expand-leave &#123; height: 0; padding: 0 10px; opacity: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div v-if="show" transition="expand"&gt;hello&lt;/div&gt; &lt;input type="button" v-on:click="change" value="change" /&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; show:true &#125;, methods:&#123; change:function()&#123; if(this.show)&#123; this.show=false &#125;else&#123; this.show=true; &#125; &#125; &#125; &#125;) Vue.transition('expand', &#123; beforeEnter: function (el) &#123; el.textContent = 'beforeEnter' &#125;, enter: function (el) &#123; el.textContent = 'enter' &#125;, afterEnter: function (el) &#123; el.textContent = 'afterEnter' &#125;, enterCancelled: function (el) &#123; // handle cancellation &#125;, beforeLeave: function (el) &#123; el.textContent = 'beforeLeave' &#125;, leave: function (el) &#123; el.textContent = 'leave' &#125;, afterLeave: function (el) &#123; el.textContent = 'afterLeave' &#125;, leaveCancelled: function (el) &#123; // handle cancellation &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 过渡的 CSS 类名123456789类名的添加和切换取决于 transition 特性的值。比如 transition=”fade”，会有三个 CSS 类名：.fade-transition 始终保留在元素上。.fade-enter 定义进入过渡的开始状态。只应用一帧然后立即删除。.fade-leave 定义离开过渡的结束状态。在离开过渡开始时生效，在它结束后删除。如果 transition 特性没有值，类名默认是 .v-transition, .v-enter 和 .v-leave。 自定义过渡类名1.0.14 新增 我们可以在过渡的 JavaScript 定义中声明自定义的 CSS 过渡类名。这些自定义类名会覆盖默认的类名。当需要和第三方的 CSS 动画库，比如 Animate.css 配合时会非常有用： 12345&lt;div v-show="ok" class="animated" transition="bounce"&gt;Watch me bounce&lt;/div&gt;Vue.transition('bounce', &#123; enterClass: 'bounceInLeft', leaveClass: 'bounceOutRight'&#125;) 显式声明 CSS 过渡类型1.0.14 新增 Vue.js 需要给过渡元素添加事件侦听器来侦听过渡何时结束。基于所使用的 CSS，该事件要么是 transitionend，要么是 animationend。如果你只使用了两者中的一种，那么 Vue.js 将能够根据生效的 CSS 规则自动推测出对应的事件类型。但是，有些情况下一个元素可能需要同时带有两种类型的动画。比如你可能希望让 Vue 来触发一个 CSS animation，同时该元素在鼠标悬浮时又有 CSS transition 效果。这样的情况下，你需要显式地声明你希望 Vue 处理的动画类型 (animation 或是 transition)：1234Vue.transition('bounce', &#123; // 该过渡效果将只侦听 `animationend` 事件 type: 'animation'&#125;) 过渡流程详解当 show 属性改变时，Vue.js 将相应地插入或删除 div 元素，按照如下规则改变过渡的 CSS 类名： 如果 show 变为 false，Vue.js 将： 调用 beforeLeave 钩子；添加 v-leave 类名到元素上以触发过渡；调用 leave 钩子；等待过渡结束（监听 transitionend 事件）；从 DOM 中删除元素并删除 v-leave 类名；调用 afterLeave 钩子。如果 show 变为 true，Vue.js 将： 调用 beforeEnter 钩子；添加 v-enter 类名到元素上；把它插入 DOM；调用 enter 钩子；强制一次 CSS 布局，让 v-enter 确实生效。然后删除 v-enter 类名，以触发过渡，回到元素的原始状态；等待过渡结束；调用 afterEnter 钩子。另外，如果在它的进入过渡还在进行中时删除元素，将调用 enterCancelled 钩子，以清理变动或 enter 创建的计时器。反过来对于离开过渡亦如是。 上面所有的钩子函数在调用时，它们的 this 均指向其所属的 Vue 实例。编译规则：过渡在哪个上下文中编译，它的 this 就指向哪个上下文。 最后，enter 和 leave 可以有第二个可选的回调参数，用于显式控制过渡如何结束。因此不必等待 CSS transitionend 事件， Vue.js 将等待你手工调用这个回调，以结束过渡。例如： 123456789enter: function (el) &#123; // 没有第二个参数 // 由 CSS transitionend 事件决定过渡何时结束&#125;vs.enter: function (el, done) &#123; // 有第二个参数 // 过渡只有在调用 `done` 时结束&#125; 当多个元素一起过渡时，Vue.js 会批量处理，只强制一次布局。 CSS 动画CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。 示例： (省略了兼容性前缀) 12345678910111213141516171819202122232425262728293031323334&lt;span v-show="show" transition="bounce"&gt;Look at me!&lt;/span&gt;.bounce-transition &#123; display: inline-block; /* 否则 scale 动画不起作用 */&#125;.bounce-enter &#123; animation: bounce-in .5s;&#125;.bounce-leave &#123; animation: bounce-out .5s;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;@keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125;&#125;Look at me! Toggle JavaScript 过渡也可以只使用 JavaScript 钩子，不用定义任何 CSS 规则。当只使用 JavaScript 过渡时，enter 和 leave 钩子需要调用 done 回调，否则它们将被同步调用，过渡将立即结束。 为 JavaScript 过渡显式声明 css: false 是个好主意，Vue.js 将跳过 CSS 检测。这样也会阻止无意间让 CSS 规则干扰过渡。 在下例中我们使用 jQuery 注册一个自定义的 JavaScript 过渡 1234567891011121314151617181920Vue.transition('fade', &#123; css: false, enter: function (el, done) &#123; // 元素已被插入 DOM // 在动画结束后调用 done $(el) .css('opacity', 0) .animate(&#123; opacity: 1 &#125;, 1000, done) &#125;, enterCancelled: function (el) &#123; $(el).stop() &#125;, leave: function (el, done) &#123; // 与 enter 相同 $(el).animate(&#123; opacity: 0 &#125;, 1000, done) &#125;, leaveCancelled: function (el) &#123; $(el).stop() &#125;&#125;) 然后用 transition 特性中： 1&lt;div v-for="item in list" transition="stagger" stagger="100"&gt;&lt;/div&gt; 或者，提供一个钩子 stagger, enter-stagger 或 leave-stagger，以更好的控制1234567Vue.transition('stagger', &#123; stagger: function (index) &#123; // 每个过渡项目增加 50ms 延时 // 但是最大延时限制为 300ms return Math.min(300, index * 50) &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 表单控件绑定]]></title>
      <url>%2F2016%2F09%2F12%2Fvue%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
      <content type="text"><![CDATA[Text12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;span&gt;Message is: &#123;&#123; msg &#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;input type="text" v-model="msg" placeholder="edit me"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; msg:'Hello Message' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Checkbox单个勾选框，逻辑值： 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src=&quot;http://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt; &lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 多个勾选框，绑定到同一个数组： 123456789101112131415161718192021222324252627&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src=&quot;http://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data: &#123; checkedNames: [] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Radio1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="radio" id="one" value="One" v-model="picked"&gt; &lt;label for="one"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type="radio" id="two" value="Two" v-model="picked"&gt; &lt;label for="two"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; select单选 12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;select v-model="selected"&gt; &lt;option selected&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 多选（绑定到一个数组） 1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;select v-model="selected" multiple&gt; &lt;option selected&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected | json &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 动态选项，用 v-for 渲染：123456789101112131415161718192021222324252627282930&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;select v-model="selected"&gt; &lt;option v-for="option in options" v-bind:value="option.value"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 绑定 value对于单选按钮，勾选框及选择框选项，v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）, 但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 v-bind实现，并且这个属性的值可以不是字符串。 Checkbox12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="checkbox" v-model="toggle" v-bind:true-value="a" v-bind:false-value="b"&gt; &lt;p&gt;&#123;&#123;toggle&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; a:'aaa', b:'bbb' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Radio123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="radio" v-model="pick" v-bind:value="a"&gt; &lt;p&gt;&#123;&#123;pick&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; a:'aaa' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;// 当选中时vm.pick === vm.ap标签内的值也也会变化 Select Options1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;select v-model="selected"&gt; &lt;!-- 对象字面量 --&gt; &lt;option v-bind:value="&#123;number: 123&#125;"&gt;123&lt;/option&gt; &lt;/select&gt; &lt;p&gt;&#123;&#123;selected.number&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;// 当选中时typeof vm.selected // -&gt; ‘object’vm.selected.number // -&gt; 123 参数特性lazy在默认情况下，v-model 在input 事件中同步输入框值与数据，可以添加一个特性 lazy，从而改到在 change 事件中同步： 12&lt;!-- 在 "change" 而不是 "input" 事件中更新 --&gt;&lt;input v-model="msg" lazy&gt; number如果想自动将用户的输入转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个特性 number： 1&lt;input v-model="age" number&gt; debouncedebounce 设置一个最小的延时，在每次敲击之后延时同步输入框的值与数据。如果每次更新都要进行高耗操作（例如在输入提示中 Ajax 请求），它较为有用。 1&lt;input v-model="msg" debounce="500"&gt; 注意 debounce 参数不会延迟 input 事件：它延迟“写入”底层数据。因此在使用 debounce 时应当用 vm.$watch() 响应数据的变化。若想延迟 DOM 事件，应当使用 debounce 过滤器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 方法与事件处理器]]></title>
      <url>%2F2016%2F09%2F03%2Fvue%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
      <content type="text"><![CDATA[方法处理器 v-onv-on 指令监听 DOM 事件： 123456789101112131415161718192021222324252627&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" v-on:click="testvon" value="v-on test" /&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; text:'v-on success' &#125;, methods:&#123; testvon:function(e)&#123; alert(this.text);//this指向vm alert(e.target.tagName) &#125; &#125; &#125;) vm.testvon()//可以在外部调用 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 除了直接绑定到一个方法，也可以用内联 JavaScript 语句： 1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" v-on:click="testvon('btn1')" value="v-on test" /&gt; &lt;input type="button" v-on:click="testvon('btn2')" value="v-on test" /&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; text:'v-on success' &#125;, methods:&#123; testvon:function(msg)&#123; alert(msg) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 类似于内联表达式，事件处理器限制为一个语句。 有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法： 12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" v-on:click="testvon('btn1', $event)" value="v-on test" /&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; text:'v-on success' &#125;, methods:&#123; testvon:function(msg,event)&#123; event.preventDefault() &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件修饰符在事件处理器中经常需要调用 event.preventDefault() 或 event.stopPropagation()。尽管我们在方法内可以轻松做到，不过让方法是纯粹的数据逻辑而不处理 DOM 事件细节会更好。 为了解决这个问题，Vue.js 为 v-on 提供两个 事件修饰符：.prevent 与 .stop。你是否还记得修饰符是点号打头的指令后缀？ 12345678910111213141516171819202122&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;1.0.16 添加了两个额外的修饰符：&lt;!-- 添加事件侦听器时使用 capture 模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;按键修饰符在监听键盘事件时，我们经常需要检测 keyCode。Vue.js 允许为 v-on 添加按键修饰符：&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=&quot;submit&quot;&gt;记住所有的 keyCode 比较困难，Vue.js 为最常用的按键提供别名：&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 列表渲染]]></title>
      <url>%2F2016%2F08%2F22%2Fvue%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%2F</url>
      <content type="text"><![CDATA[v-for可以使用 v-for 指令基于一个数组渲染一个列表。 123456789101112131415161718192021222324252627282930313233343536 &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul &gt; &lt;!--item是数组元素的别名 只要与&#123;&#123;&#125;&#125;中的对应即可，itmes是数组名要与data中的一致--&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.msg &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; items: [ &#123; msg: '001' &#125;, &#123; msg: '002' &#125;, &#123; msg: '003' &#125;, &#123; msg: '004' &#125; ] &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;结果：001002003004 另外，可以为索引指定一个别名（如果 v-for 用于一个对象，则可以为对象的键指定一个别名）： 1234567891011121314151617181920212223242526272829303132333435&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul &gt; &lt;!--item是数组元素的别名 只要与&#123;&#123;&#125;&#125;中的对应即可，itmes是数组名要与data中的一致--&gt; &lt;div v-for="(index, item) in items"&gt; &#123;&#123; index &#125;&#125; &#123;&#123; item.msg &#125;&#125; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; items: [ &#123; msg: '001' &#125;, &#123; msg: '002' &#125;, &#123; msg: '003' &#125;, &#123; msg: '004' &#125; ] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;结果：0 0011 0022 0033 004 从 1.0.17 开始可以使用 of 分隔符，更接近 JavaScript 遍历器语法：1&lt;div v-for="item of items"&gt;&lt;/div&gt; template v-fortemplate v-for 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul &gt; &lt;template v-for="item in items"&gt; &lt;li&gt; &#123;&#123; item.msg&#125;&#125; &lt;/li&gt; &lt;li&gt; &#123;&#123; item.msgs &#125;&#125; &lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; items: [ &#123; msg: '1',msgs: '001' &#125;, &#123; msg: '2',msgs: '001' &#125;, &#123; msg: '3',msgs: '001' &#125;, &#123; msg: '4',msgs: '001'&#125; ] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;结果：1001200130014001 Vue 数组方法（这些方法类似js中数组的方法）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748变异方法Vue.js 包装了被观察数组的变异方法，故它们能触发视图更新。被包装的方法有：* push()* pop()* shift()* unshift()* splice()* sort()* reverse()下面是个通用的例子，可以尝试着替换方法进行测试，领悟其中的意义： &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" @click="add" value="change" /&gt; &lt;ul &gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.msg&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; items: [ &#123; msg: '1'&#125;, &#123; msg: '2'&#125;, &#123; msg: '3'&#125;, &#123; msg: '4'&#125; ] &#125;, methods:&#123; add:function()&#123;// this.items.push(&#123;msg: '666'&#125;) this.items.reverse() &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 替换数组filter(), concat() 和 slice()这些方法不会修改原始数组而是返回一个新数组。在使用非变异方法时，可以直接用新数组替换旧数组： 例子如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" @click="add" value="change" /&gt; &lt;ul &gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.msg&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; items: [ &#123; msg: 'test1'&#125;, &#123; msg: '2'&#125;, &#123; msg: '3'&#125;, &#123; msg: 'test4'&#125; ] &#125;, methods:&#123; add:function()&#123; this.items = this.items.filter(function (item) &#123; return item.msg.match(/test/) &#125;) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue.js 并没有弃用已有 DOM 并重新渲染整个列表。 Vue.js 实现了一些启发算法，以最大化复用 DOM 元素，因而用另一个数组替换数组是一个非常高效的操作。 track-by有时需要用全新对象替换数组。因为 v-for 默认通过数据对象的特征来决定对已有作用域和 DOM 元素的复用程度，这可能导致重新渲染整个列表。但是，如果每个对象都有一个唯一 ID 的属性，便可以使用 track-by 特性给 Vue.js 一个提示，Vue.js 因而能尽可能地复用已有实例。然后在替换数组 items 时，如果 Vue.js 遇到一个包含相同uid的 的新对象，它知道它可以复用这个已有对象的作用域与 DOM 元素。 12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" @click="add" value="change" /&gt; &lt;ul &gt; &lt;li v-for="item in items" track-by='uid'&gt; &#123;&#123; item.msg&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; items: [ &#123;uid:'01', msg: 'test1'&#125;, &#123;uid:'02', msg: '2'&#125;, &#123;uid:'03', msg: '3'&#125;, &#123;uid:'04', msg: 'test4'&#125; ] &#125;, methods:&#123; add:function()&#123; this.items = this.items.filter(function (item) &#123; return item.msg.match(/test/) &#125;) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; track-by $index如果没有唯一的键供追踪，可以使用 track-by=”$index”，它强制让 v-for 进入原位更新模式：片断不会被移动，而是简单地以对应索引的新值刷新。这种模式也能处理数据数组中重复的值。 这让数据替换非常高效，但是也会付出一定的代价。因为这时 DOM 节点不再映射数组元素顺序的改变，不能同步临时状态（比如 input 元素的值）以及组件的私有状态。因此，如果 v-for 块包含 input 元素或子组件，要小心使用 track-by=”$index” 限制应对策略因为 JavaScript 的限制，Vue.js 不能检测到下面数组变化： (1)直接用索引设置元素，如 vm.items[0] = {}； 为了解决这个问题，Vue.js 扩展了观察数组，为它添加了一个 $set() 方法： 12// 与 `this.items[0] = ...` 相同，但是能触发视图更新this.items.$set(0, &#123; childMsg: 'Changed!'&#125;) (2)修改数据的长度，如 vm.items.length = 0。 至于这个问题，只需用一个空数组替换 items。 除了 $set()， Vue.js 也为观察数组添加了 $remove() 方法，用于从目标数组中查找并删除元素，在内部它调用 splice() 。 1this.items.$remove(item) 使用 Object.freeze() 在遍历一个数组时，如果数组元素是对象并且对象用 Object.freeze() 冻结，你需要明确指定 track-by。在这种情况下如果 Vue.js 不能自动追踪对象，将给出一条警告。 对象 v-for对象也可以使用 v-for 遍历。除了 $index 之外，作用域内还可以访问另外一个特殊变量 $key。 12345678910111213141516171819202122232425262728293031 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src=&quot;http://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul &gt; &lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; $key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data: &#123; object: &#123; Name: &apos;zhang3&apos;, Age: 80 &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;结果：Name : zhang3Age : 30 也可以给对象的键提供一个别名： 1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul &gt; &lt;div v-for="(key, val) in object"&gt; &#123;&#123; key &#125;&#125; &#123;&#123; val &#125;&#125; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; object: &#123; Name: 'zhang3', Age: 30 &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。 值域 v-forv-for 也可以接收一个整数，此时它将重复模板数次。 12345678910111213141516171819202122 &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div&gt; &lt;span v-for="n in 10"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app' &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;结果：0 1 2 3 4 5 6 7 8 9显示过滤/排序的结果 有时我们想显示过滤/排序过的数组，同时不实际修改或重置原始数据。有两个办法：创建一个计算属性，返回过滤/排序过的数组；使用内置的过滤器 filterBy 和 orderBy。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 条件渲染]]></title>
      <url>%2F2016%2F08%2F08%2FVue%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%2F</url>
      <content type="text"><![CDATA[v-if123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt; &lt;!--下面这句也可以--&gt; &lt;!--&lt;h1 v-else="ok"&gt;No&lt;/h1&gt;--&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; //ok:true ok:false &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-if与js中的if类似 只要判断为真 就会显示这个节点否则就会显示v-else对应的节点。如果没有v-else节点则什么也不显示； template &amp;&amp; v-if因为v-if是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个template元素当做包装元素，并在上面使用 v-if，最终的渲染结果不会包含它。 123456789101112131415161718192021222324252627282930 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src=&quot;http://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;/template&gt; &lt;template v-else=&quot;ok&quot;&gt; &lt;h1&gt;Titles&lt;/h1&gt; &lt;p&gt;Paragraphs 1&lt;/p&gt; &lt;p&gt;Paragraphs 2&lt;/p&gt; &lt;/template&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data: &#123;// ok:true ok:false &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; template标签类似于label标签 把一组标签包在一起 并不在页面上显示此标签 v-show 指令v-show也是根据条件展示元素的指令。用法与v-if基本上一样： 条件渲染1&lt;h1 v-show="ok"&gt;Hello!&lt;/h1&gt; v-show与v-if不同的是有 v-show 的元素会始终渲染并保持在 DOM 中。v-show 是简单的切换元素的 CSS 属性 display。 注：v-show 不支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 绑定样式]]></title>
      <url>%2F2016%2F07%2F22%2FVue%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Vue 样式操作元素的 class 列表和它的内联样式是数据绑定搞的一个常见的需求，用v-bind来处理。在 v-bind 用于 class 和 style 时，表达式的结果类型除了字符串之外，还可以是对象或数组。 绑定class对象语法123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src=&quot;http://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;static&quot; v-bind:class=&quot;&#123;&apos;class-a&apos;:classa, &apos;class-b&apos;:classb&#125;&quot;&gt; Hello v-bind:class &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data: &#123; classa:true, classb:false &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; class值会根据classa和classb的true or false进行改变12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div v-bind:class="classObject"&gt; Hello v-bind:class &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; classObject: &#123; 'class-a': true, 'class-b': false &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 数组方法1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src=&quot;http://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;[classA,classB]&quot;&gt; Hello v-bind:class &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data: &#123; classA: &apos;class-a&apos;, classB: &apos;class-b&apos; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 根据条件判断添加12&lt;div v-bind:class="[classA, isB ? classB : '']"&gt;&lt;div v-bind:class="[classA, &#123; classB: isB, classC: isC &#125;]"&gt; 绑定内联样式（style）对象语法v-bind:style 的对象语法十分直观——看着非常像 CSS，其实它是一个 JavaScript 对象。CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）： 123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; activeColor: 'red', fontSize: 30 &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 直接绑定到一个样式对象通常更好，让模板更清晰：1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div v-bind:style="styleObject"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 数组语法v-bind:style 的数组语法可以将多个样式对象应用到一个元素上： 12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div v-bind:style="[styleObjectA, styleObjectB]"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; styleObjectA: &#123; color: 'red', &#125; styleObjectB: &#123; fontSize: '13px' &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 自动添加前缀当 v-bind:style 使用需要厂商前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 计算属性]]></title>
      <url>%2F2016%2F07%2F15%2FVue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[计算属性在模板中绑定表达式绑定表达式是非常便利的，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。 初识例子123456789101112131415161718192021222324252627282930 &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; a=&#123;&#123; a &#125;&#125;, b=&#123;&#123; b &#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'app', data: &#123; a:1 &#125;, computed : &#123; // 一个计算属性的 getter b:function()&#123; return this.a + 1 &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;结果：a=1, b=2这里我们声明了一个计算属性 b。我们提供的函数将用作属性 vm.b的 getter。 可以像绑定普通属性一样在模板中绑定计算属性。Vue 知道 vm.b 依赖于 vm.a，因此当 vm.a 发生改变时，依赖于 vm.b 的绑定也会更新。 计算属性 vs. $watchVue.js 提供了一个方法 $watch，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， $watch 很诱人 —— 特别是如果你来自 AngularJS。通常更好的办法是使用计算属性而不是一个命令式的 $watch 回调（比较下面的例子）： 12345678910111213141516171819202122232425262728&lt;div id="app"&gt;&#123;&#123;fullName&#125;&#125;&lt;/div&gt;//1 单纯的使用vm.$watch var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125; &#125;) vm.$watch('firstName', function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;) vm.$watch('lastName', function (val) &#123; this.fullName = this.firstName + ' ' + val &#125;)//2 计算属性 var vm = new Vue(&#123; data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) 计算属性 setter计算属性默认只是 getter，不过在需要时你也可以提供一个 setter： 12345678910111213141516171819202122&lt;div id="app"&gt;&#123;&#123;fullName&#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125; &#125;&#125;) 现在在调用 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会有相应更新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 基本语法]]></title>
      <url>%2F2016%2F07%2F03%2FVue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[插值插值是通过“Mustache” 语法（双大括号）,Mustache 标签也可以用在 HTML 特性 (Attributes) 内： 123456789101112131415161718192021222324252627&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; //Mustache 标签会被相应数据对象的 msg 属性的值替换。每当这个属性变化时它也会更新。 &lt;p&gt;message:&#123;&#123;&#123; msg &#125;&#125;&#125;&lt;/p&gt; //只处理单次插值，今后的数据变化就不会再引起插值更新了 &lt;p&gt;message:&#123;&#123;* msg &#125;&#125;&lt;/p&gt; //双 Mustache 标签将数据解析为纯文本而不是 HTML。为了输出真的 HTML 字符串，需要用三 Mustache 标签 &lt;p&gt;message:&#123;&#123;&#123; msg &#125;&#125;&#125;&lt;/p&gt; //Mustache 标签也可以用在 HTML 特性 (Attributes) 内 &lt;div id="item-&#123;&#123; msg &#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: "#app", data:&#123; msg:'Hello hello word!' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意在 Vue.js 指令和特殊特性内不能用插值。 几种常见的绑定表达式1放在 Mustache 标签内的文本称为绑定表达式。在 Vue 中，一般绑定表达式由一个简单的 JavaScript 表达式和可选的一个或多个过滤器构成。 表达式一般模板只绑定到简单的属性键。实际上 Vue 在数据绑定内几乎支持所有的 JavaScript 表达式： 12345&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;// &#123;&#123; var a = 1 &#125;&#125; //这是一个语句，不是一个表达式不能执行// &#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; //流程控制也不可以，可改用三元表达式 这些表达式将在所属的 Vue 实例的作用域内计算。但是每个绑定只能包含单个表达式。 过滤器Vue.js 允许在表达式后添加可选的“过滤器 (Filter) ”，以“管道符”指示（与angular的过滤器基本相同）： 123456789&#123;&#123; message | capitalize &#125;&#125;这里我们将表达式 message 的值“管输（pipe）”到内置的 capitalize 过滤器，这个过滤器其实只是一个 JavaScript 函数，返回大写化的值。Vue.js 提供数个内置过滤器，过滤器也可以根据我们的需要进行自定义。注：管道语法不是 JavaScript 语法，因此不能在表达式内使用过滤器，只能添加到表达式的后面。过滤器可以串联：&#123;&#123; message | filterA | filterB &#125;&#125;过滤器也可以接受参数：&#123;&#123; message | filterA 'arg1' arg2 &#125;&#125;过滤器函数始终以表达式的值作为第一个参数。带引号的参数视为字符串，而不带引号的参数按表达式计算。这里，字符串 'arg1' 将传给过滤器作为第二个参数，表达式 arg2 的值在计算出来之后作为第三个参数。 指令指令 (Directives) 是特殊的带有前缀 v- 的特性。指令的值限定为绑定表达式，因此上面提到的 JavaScript 表达式及过滤器规则在这里也适用。指令的职责就是当其表达式的值改变时把某些特殊的行为应用到 DOM 上： 123456789&lt;p v-if=&quot;greeting&quot;&gt;Hello!&lt;/p&gt;//这里 v-if 指令将根据表达式 greeting 值的真假删除/插入 p 元素。&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;有些指令可以在其名称后面带一个“参数” (Argument)，中间放一个冒号隔开。这里 href 是参数，它告诉 v-bind 指令将元素的 href 特性跟表达式 url 的值绑定。也可以用特性插值 href=&quot;&#123;&#123;url&#125;&#125;&quot; 获得同样的结果。这里仅仅是介绍指令带参数的语法。&lt;a v-on:click=&quot;doSomething&quot;&gt;这里参数是被监听的事件的名字。绑定的是一个方法到点击的时候会触发这个方法。 修饰符修饰符 (Modifiers) 是以半角句号 . 开始的特殊后缀，用于表示指令应当以特殊方式绑定。修饰符的主要作用是告诉指令一种规范。 12&lt;a v-bind:href.literal="/a/b/c"&gt;&lt;/a&gt;.literal 修饰符告诉指令将它的值解析为一个字面字符串而不是一个表达式 v-bind、v-on的缩写v- 前缀是一种标识模板中特定的 Vue 特性的视觉暗示。Vue.js 为两个最常用的指令 v-bind 和 v-on 提供特别的缩写： 1234567891011121314v-bind 缩写&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;&lt;/a&gt;&lt;!-- 完整语法 --&gt;&lt;button v-bind:disabled="someDynamicCondition"&gt;Button&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button :disabled="someDynamicCondition"&gt;Button&lt;/button&gt;v-on 缩写&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;&lt;/a&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 实例]]></title>
      <url>%2F2016%2F06%2F22%2FVue%E5%AE%9E%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[每个vue应用开始都是通过构造函数 Vue创建一个 Vue 的根实例： 123var vm = new Vue(&#123; //Vue的v要大写 // 选项&#125;) 一个 Vue 实例其实正是一个 MVVM 模式中所描述的 ViewModel - 因此习惯上会使用 vm（并不是固定的） 这个变量名。在实例化 Vue 时，需要传入一个对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。全部的选项可以在 API 文档中查看。 可以扩展 Vue 构造器，从而用预定义选项创建可复用的组件构造器： 12345678var MyComponent = Vue.extend(&#123; // 扩展选项 &#125;) var myComponentInstance = new MyComponent() // 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建 //尽管可以命令式地创建扩展实例，不过在多数情况下将组件构造 //器注册为一个自定义元素，然后声明式地用在模板中。我们将在 //后面详细说明组件系统。现在你只需知道所有的Vue.js 组件其实都是被扩展的 Vue 实例。 属性与方法每个 Vue 实例都会代理其 data 对象里所有的属性： 1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123; data: data&#125;)vm.a === data.a // -&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // -&gt; 2// ... 反之亦然data.a = 3vm.a // -&gt; 3 注意只有这些被代理的属性是响应的。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。我们将在后面详细讨论响应系统 除了这些数据属性，Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的数据属性区分。例如：1234567891011var data = &#123; a: 1 &#125; var vm = new Vue(&#123; el: '#example', data: data &#125;) vm.$data === data // -&gt; true vm.$el === document.getElementById('example') // -&gt; true // $watch 是一个实例方法 vm.$watch('a', function (newVal, oldVal) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 实例生命周期Vue 实例在创建时有一系列初始化步骤——例如，它需要建立数据观察，编译模板，创建必要的数据绑定。在此过程中，它也将调用一些生命周期钩子，给自定义逻辑提供运行机会。例如 created 钩子在实例创建后调用： 12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;)// -&gt; "a is: 1" 也有一些其它的钩子，在实例生命周期的不同阶段调用，如 compiled、 ready 、destroyed。钩子的 this 指向调用它的 Vue 实例。Vue.js 是没有有“控制器”的概念的。组件的自定义逻辑可以分割在这些钩子中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vuejs入门篇]]></title>
      <url>%2F2016%2F06%2F13%2Fvuejs%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[hello word12345678910111213141516171819202122&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt;//引入vuejs &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt; &lt;script&gt; new Vue(&#123; el:'#app', //找到存放数据的容器 data: &#123; message:'vue say：Hello World!' &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 运行结果为： 页面显示 vue say：Hello World! 双向绑定12345678910111213141516171819202122&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt;//引入vuejs &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model="message"&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: "#app", data:&#123; message:'vue say：Hello World!' &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 页面初始渲染input内容与message相同，input内容发生改变的时候 p内的内容对应发生变化 列表输出12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="datas in datalist"&gt; &#123;&#123;datas.text&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: "#app", data:&#123; datalist:[ &#123;text: 'data none'&#125;, &#123;text: 'data two'&#125; ] &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-for 类似angular中的ng-repeat指令；循环遍历datalist内的数据渲染在页面上 绑定事件12345678910111213141516171819202122232425262728293031323334353637383940414243//demo01&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello word&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/vue/1.0.11/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input type="button" v-on:click = "changemessage" value="change message" /&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: "#app", data:&#123; message:'Hello hello word!' &#125;, methods:&#123; changemessage:function()&#123; this.message = 'I also have methods!' &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;//demo02 &lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input type="button" v-on:click = "message = 'I also have methods!'" value="change message" /&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: "#app", data:&#123; message:'Hello hello word!' &#125; &#125;) &lt;/script&gt; &lt;/body&gt; vue的v-on:click 类似angular 的 ng-click指令，demo01和demo02实现的效果是一样的 以上几个小栗子初步对vue有个初步的概念 如有不当之处可以评论反馈]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[元素拖放]]></title>
      <url>%2F2016%2F05%2F22%2F%E5%85%83%E7%B4%A0%E6%8B%96%E6%94%BE%2F</url>
      <content type="text"><![CDATA[拖放拖放是一种常见的特性，即抓取对象以后拖到另一个位置。 1、设置元素为可拖放首先，为了使元素可拖动，把 draggable 属性设置为 true ： 2、拖动什么 - ondragstart 和 setData()然后，规定当元素被拖动时，会发生什么。在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。dataTransfer.setData() 方法设置被拖数据的数据类型和值： JavaScript Code复制内容到剪贴板 function drag(ev) { ev.dataTransfer.setData(“Text”,ev.target.id); } 在这个例子中，数据类型是 “Text”，值是可拖动元素的 id (“drag1”)。 3、放到何处 - ondragoverondragover 事件规定在何处放置被拖动的数据。默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。这要通过调用 ondragover 事件的 event.preventDefault() 方法：event.preventDefault() 4、进行放置 - ondrop当放置被拖数据时，会发生 drop 事件。在上面的例子中，ondrop 属性调用了一个函数，drop(event)： 123456function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(“Text”); ev.target.appendChild(document.getElementById(data));&#125; 1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; #div1 &#123;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&#125; &lt;/style&gt; &lt;script&gt; function allowDrop(ev)&#123; ev.preventDefault(); &#125; function drag(ev)&#123; ev.dataTransfer.setData("Text",ev.target.id); &#125; function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData("Text"); ev.target.appendChild(document.getElementById(data)); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;拖动 W3CSchool.cc 图片到矩形框中:&lt;/p&gt; &lt;div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)"&gt;&lt;/div&gt; &lt;br&gt; &lt;img id="drag1" src="/images/logo.png" draggable="true" ondragstart="drag(event)" width="336" height="69"&gt; &lt;/body&gt; &lt;/html&gt; 注：preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）。通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。被拖数据是被拖元素的 id (“drag1”)。把被拖元素追加到放置元素（目标元素）中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本地存储]]></title>
      <url>%2F2016%2F05%2F10%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[html5几种存储形式 本地存储（localStorage &amp;&amp; sessionStorage） 离线缓存（application cache） indexedDB 和 webSQL localStorage与sessionStorage区别及特点过期时间：localStorage 永久存储，永不失效除非手动删除 sessionStorage 浏览器重新打开后就消失了 大小：每个域名是5M localStorage API和sessionStorage API一致 getItem //取记录 setIten//设置记录 removeItem//移除记录 key//取key所对应的值 clear//清除记录 存储的内容： 数组，图片，json，样式，脚本…… localStorage实例12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE&gt; &lt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta http-equiv="Access-Control-Allow-Origin" content="anonymous"&gt; &lt;title&gt;locstorage 图片存储&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var src='images/1.png';//这里一定要在服务器上运行，图片要是当前服务器的图片！ function set(key)&#123; var img = document.createElement('img');//创建图片元素 img.addEventListener('load',function()&#123;//绑定加载时间 var imgcavens = document.createElement('canvas'); imgcontent = imgcavens.getContext('2d'); imgcavens.width = this.width;//设置画布大小为图片本身的大小 imgcavens.height = this.height; imgcontent.drawImage(this,0,0,this.width,this.height); var imgAsDataUrl = imgcavens.toDataURL('image/png');//这个方法一定要在服务器上运行/*对图像数据做出修改以后，可以使用toDataURL方法，将Canvas数据重新转化成一般的图像文件形式。function convertCanvasToImage(canvas) &#123; var image = new Image(); image.src = canvas.toDataURL("image/png"); return image;&#125;上面的代码将Canvas数据，转化成PNG data URI。*/ try&#123; localStorage.setItem(key,imgAsDataUrl);//保存图片地址 &#125;catch(e) &#123; console.log("storageFaild: "+e);//错误信息 &#125; &#125;,false) img.src = src;//指定需要存储的图片地址 &#125; function get(key)&#123; var srcStr = localStorage.getItem(key);//获取本地存储的元素 var imgobj = document.createElement('img'); imgobj.src = srcStr;//指定图片路径 document.body.appendChild(imgobj);//在页面中添加元素 &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以通过调试在资源管理器中进行分析 由于html5没有给本地存储设置过期策略，那么在处理图片的过期策略的时候可以编写自己过期策略程序，如下：12345678910111213141516171819202122232425262728&lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta http-equiv="Access-Control-Allow-Origin" content="anonymous"&gt; &lt;title&gt;locstorage 过期策略&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function set(key,value)&#123; var curtime = new Date().getTime();//获取当前时间 localStorage.setItem(key,JSON.stringify(&#123;val:value,time:curtime&#125;));//转换成json字符串序列 /* 说明： JSON.parse用于从一个字符串中解析出json对象,如 var str = '&#123;"name":"huangxiaojian","age":"23"&#125;' 结果： JSON.parse(str) Object age: "23" name: "huangxiaojian" __proto__: Object 注意：单引号写在&#123;&#125;外，每个属性名都必须用双引号，否则会抛出异常。 JSON.stringify()用于从一个对象解析出字符串，如 var a = &#123;a:1,b:2&#125; 结果： JSON.stringify(a) "&#123;"a":1,"b":2&#125;" */&#125; function get(key,exp)//exp是设置的过期时间 &#123; var val = localStorage.getItem(key);//获取存储的元素 var dataobj = JSON.parse(val);//解析出json对象 if(new Date().getTime() - dataobj.time &gt; exp)//如果当前时间-减去存储的元素在创建时候设置的时间 &gt; 过期时间 &#123; console.log("expires");//提示过期 &#125; else&#123; console.log("val="+dataobj.val); &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[盒子模型及box-sizing属性]]></title>
      <url>%2F2016%2F04%2F22%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%8F%8Abox-sizing%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[盒子模型及box-sizing属性html中的每个dom元素都被描述为矩形的盒子。渲染引擎的目的是判断大小，属性（颜色，背景，边框，边距，位置等信息）。在css中，这些盒子用标准的盒模型来描述。这个模型描述了一个元素所占用的空间。每一个盒子有四条边界，分别是：外边距边界（margin）、边框边界（border）、内边距边界（padding）和内容边界（content） 盒模型盒模型主要分为两种：IE盒模型与标准盒模型 确切的说IE盒模型仅是在IE8以下的情况 在W3C模型中: 总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right 在IE模型中: 总宽度 = margin-left + width + margin-right 在CSS3中引入了box-sizing属性, 它可以允许改变默认的CSS盒模型对元素宽高的计算方式. 共包括两个选项： content-box：标准盒模型，CSS定义的宽高只包含content的宽高(默认) border-box：IE盒模型，CSS定义的宽高包括了content，padding和border 共包括两个选项： content-box：标准盒模型，CSS定义的宽高只包含content的宽高(默认) border-box：IE盒模型，CSS定义的宽高包括了content，padding和border12345678910111213&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .con&#123;width: 100px; height: 100px;background-color:royalblue; border:1px solid red; padding: 10px;&#125; .con1&#123;box-sizing: border-box;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="con"&gt;&lt;/div&gt; &lt;div class="con con1"&gt;&lt;/div&gt; &lt;/body&gt; 通过调试可以一目了然box-sizing两个值得区别。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[md5加密]]></title>
      <url>%2F2016%2F04%2F10%2Fmd5%E5%8A%A0%E5%AF%86%2F</url>
      <content type="text"><![CDATA[md5.js 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212var hexcase = 0; /* hex output format. 0 - lowercase; 1 - uppercase */var b64pad = ""; /* base-64 pad character. "=" for strict RFC compliance */var chrsz = 8; /* bits per input character. 8 - ASCII; 16 - Unicode */function ants_md5(s)&#123; return binl2hex(core_md5(str2binl(s), s.length * chrsz));&#125;function b64_md5(s)&#123; return binl2b64(core_md5(str2binl(s), s.length * chrsz));&#125;function str_md5(s)&#123; return binl2str(core_md5(str2binl(s), s.length * chrsz));&#125;function hex_hmac_md5(key, data) &#123; return binl2hex(core_hmac_md5(key, data)); &#125;function b64_hmac_md5(key, data) &#123; return binl2b64(core_hmac_md5(key, data)); &#125;function str_hmac_md5(key, data) &#123; return binl2str(core_hmac_md5(key, data)); &#125;function md5_vm_test()&#123; return ants_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";&#125;function core_md5(x, len)&#123; /* append padding */ x[len &gt;&gt; 5] |= 0x80 &lt;&lt; ((len) % 32); x[(((len + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = len; var a = 1732584193; var b = -271733879; var c = -1732584194; var d = 271733878; for(var i = 0; i &lt; x.length; i += 16) &#123; var olda = a; var oldb = b; var oldc = c; var oldd = d; a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936); d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586); c = md5_ff(c, d, a, b, x[i+ 2], 17, 606105819); b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330); a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897); d = md5_ff(d, a, b, c, x[i+ 5], 12, 1200080426); c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341); b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983); a = md5_ff(a, b, c, d, x[i+ 8], 7 , 1770035416); d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417); c = md5_ff(c, d, a, b, x[i+10], 17, -42063); b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162); a = md5_ff(a, b, c, d, x[i+12], 7 , 1804603682); d = md5_ff(d, a, b, c, x[i+13], 12, -40341101); c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290); b = md5_ff(b, c, d, a, x[i+15], 22, 1236535329); a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510); d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632); c = md5_gg(c, d, a, b, x[i+11], 14, 643717713); b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302); a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691); d = md5_gg(d, a, b, c, x[i+10], 9 , 38016083); c = md5_gg(c, d, a, b, x[i+15], 14, -660478335); b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848); a = md5_gg(a, b, c, d, x[i+ 9], 5 , 568446438); d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690); c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961); b = md5_gg(b, c, d, a, x[i+ 8], 20, 1163531501); a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467); d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784); c = md5_gg(c, d, a, b, x[i+ 7], 14, 1735328473); b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734); a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558); d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463); c = md5_hh(c, d, a, b, x[i+11], 16, 1839030562); b = md5_hh(b, c, d, a, x[i+14], 23, -35309556); a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060); d = md5_hh(d, a, b, c, x[i+ 4], 11, 1272893353); c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632); b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640); a = md5_hh(a, b, c, d, x[i+13], 4 , 681279174); d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222); c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979); b = md5_hh(b, c, d, a, x[i+ 6], 23, 76029189); a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487); d = md5_hh(d, a, b, c, x[i+12], 11, -421815835); c = md5_hh(c, d, a, b, x[i+15], 16, 530742520); b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651); a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844); d = md5_ii(d, a, b, c, x[i+ 7], 10, 1126891415); c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905); b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055); a = md5_ii(a, b, c, d, x[i+12], 6 , 1700485571); d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606); c = md5_ii(c, d, a, b, x[i+10], 15, -1051523); b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799); a = md5_ii(a, b, c, d, x[i+ 8], 6 , 1873313359); d = md5_ii(d, a, b, c, x[i+15], 10, -30611744); c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380); b = md5_ii(b, c, d, a, x[i+13], 21, 1309151649); a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070); d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379); c = md5_ii(c, d, a, b, x[i+ 2], 15, 718787259); b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551); a = safe_add(a, olda); b = safe_add(b, oldb); c = safe_add(c, oldc); d = safe_add(d, oldd); &#125; return Array(a, b, c, d);&#125;/* * These functions implement the four basic operations the algorithm uses. */function md5_cmn(q, a, b, x, s, t)&#123; return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#125;function md5_ff(a, b, c, d, x, s, t)&#123; return md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#125;function md5_gg(a, b, c, d, x, s, t)&#123; return md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#125;function md5_hh(a, b, c, d, x, s, t)&#123; return md5_cmn(b ^ c ^ d, a, b, x, s, t);&#125;function md5_ii(a, b, c, d, x, s, t)&#123; return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#125;/* * Calculate the HMAC-MD5, of a key and some data */function core_hmac_md5(key, data)&#123; var bkey = str2binl(key); if(bkey.length &gt; 16) bkey = core_md5(bkey, key.length * chrsz); var ipad = Array(16), opad = Array(16); for(var i = 0; i &lt; 16; i++) &#123; ipad[i] = bkey[i] ^ 0x36363636; opad[i] = bkey[i] ^ 0x5C5C5C5C; &#125; var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz); return core_md5(opad.concat(hash), 512 + 128);&#125;/* * Add integers, wrapping at 2^32. This uses 16-bit operations internally * to work around bugs in some JS interpreters. */function safe_add(x, y)&#123; var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF); var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16); return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#125;/* * Bitwise rotate a 32-bit number to the left. */function bit_rol(num, cnt)&#123; return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));&#125;/* * Convert a string to an array of little-endian words * If chrsz is ASCII, characters &gt;255 have their hi-byte silently ignored. */function str2binl(str)&#123; var bin = Array(); var mask = (1 &lt;&lt; chrsz) - 1; for(var i = 0; i &lt; str.length * chrsz; i += chrsz) bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (i%32); return bin;&#125;/* * Convert an array of little-endian words to a string */function binl2str(bin)&#123; var str = ""; var mask = (1 &lt;&lt; chrsz) - 1; for(var i = 0; i &lt; bin.length * 32; i += chrsz) str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (i % 32)) &amp; mask); return str;&#125;/* * Convert an array of little-endian words to a hex string. */function binl2hex(binarray)&#123; var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef"; var str = ""; for(var i = 0; i &lt; binarray.length * 4; i++) &#123; str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8+4)) &amp; 0xF) + hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8 )) &amp; 0xF); &#125; return str;&#125;/* * Convert an array of little-endian words to a base-64 string */function binl2b64(binarray)&#123; var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; var str = ""; for(var i = 0; i &lt; binarray.length * 4; i += 3) &#123; var triplet = (((binarray[i &gt;&gt; 2] &gt;&gt; 8 * ( i %4)) &amp; 0xFF) &lt;&lt; 16) | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * ((i+1)%4)) &amp; 0xFF) &lt;&lt; 8 ) | ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * ((i+2)%4)) &amp; 0xFF); for(var j = 0; j &lt; 4; j++) &#123; if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad; else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F); &#125; &#125; return str;&#125; demo代码123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;md5加密demo&lt;/title&gt;&lt;/head&gt;&lt;script src="md5.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; var timestamp = Math.round(new Date().getTime()/1000);//得到个时间戳进行加密，一般加密的时候都会通过时间戳与要加密的内容结合加密 var sign = ants_md5(timestamp); //调用加密代码 ants是与md5.js中对应的 可以对应一起改变 console.log(sign) //打印md5加密后的内容&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node-webkit把web应用打包成桌面应用]]></title>
      <url>%2F2016%2F03%2F20%2Fnode-webkit%2F</url>
      <content type="text"><![CDATA[用node-webkit把web应用打包成桌面应用node-webkit是一个Chromium和node.js上的结合体，通过它我们可以把建立在chrome浏览器和node.js上的web应用打包成桌面应用，而且还可以跨平台。很显然比起传统的桌面应用，在某些特定领域用html5+css3+js开发的web应用更加简单和高效，而且还可以使用node.js的功能，所以node-webkit还是很有用处的。下面通过一个简单的demo来说明一下（这里只介绍windows环境） 1、首先新建一个index.html文件，作为我们这个demo的入口页面，我们暂且就把这个页面当成一个完整的web应用吧。内容随便写点什么：12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;node-webkite hello word&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 2、创建配置文件 package.json,最简单的参数配置如下：1234&#123; &quot;name&quot;: &quot;demo&quot;, &quot;main&quot;: &quot;index.html&quot;&#125; 也可以根据需要配置一些其他的参数如下（仅作为参考，无需写在demo）：1234567891011121314151617181920212223&#123; "main": "index.html", "name": "nw-demo", "description": "demo app of node-webkit", "version": "0.1.0", "keywords": [ "demo", "node-webkit" ], "window": &#123; "title": "node-webkit demo", "icon": "link.png", "toolbar": true, "frame": false, "width": 800, "height": 500, "position": "mouse", "min_width": 400, "min_height": 200, "max_width": 800, "max_height": 600 &#125;, "webkit": &#123; "plugin": true &#125;&#125; 3.创建 .nw 文件1234把index.html和package.json压缩在一个文件里*确保两个文件都在根目录下把压缩文件后缀改成 .nw此demo命名为 app.nw 4.下载windows版本的node-webkit,解压后得到一个文件夹：5.用nw.exe来执行app.nw,直接把app.nw拖到nw.exe上就可以执行了。12345因为nw文件的运行需要node-webkit环境的支持，所以我们还需要把app.nw这个文件跟node-webkit的环境文件一起打包成一个可执行文件。首先打开windows的cmd,然后输入如下命令：cd 文件所在目录copy /b nw.exe+app.nw app.exe执行命令后我们得到了 app.exe 这个可执行文件。 6.删除无用的文件只保留 app.exe，appboxed.exe，ffmpegsumo.dll，icudtl.dat ，libEGL.dll，libGLESv2.dll，nw.pak 这七个文件即可 执行app.exe就可以运行我们的demo了 1234已经得到了app.exe这个文件，但如果只有app.exe这个文件还是不够的，这个可执行文件的运行还需要几个dll文件的支持。其中 nw.pak 与 icudt.dll 这个两个文件是必须要的。ffmpegsumo.dll 文件是媒体支持文件，如果你的html页面中用到了&lt;video&gt;或&lt;audio&gt;或其它与媒体相关的东西，则必须带上这个文件。libEGL.dll 和 libGLESv2.dll 这个两个文件则是使用webGL或GPU必须要的 但我们大多数人想的是给用户一个exe文件，用户就可以使用了，不用再附带一些其他文件。嗯，所以我们还可以把app.exe跟其他的文件再打包一次，把上图中的所有文件变成一个可执行文件，用户只要得到这个文件，就能运行我们的应用了。做这步我们需要一个软件叫Enigma Virtual Box。 首先下载和安装这个软件。 然后打开它。在Enter Input File Name那里输入我们的app.exe的路径，在Enter Output File Name那里填写我们要把打包出来的可执行文件输出到哪里。最后是把除app.exe外的其它文件拖入到Files那里，遇到提示的话默认就可以了 node-webkit虽然方便，但有个很大的缺点是得到的可执行文件有点大，衡量利弊后决定使不使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Less封装flex布局常用方法及小工具]]></title>
      <url>%2F2016%2F03%2F14%2FLess%E5%B0%81%E8%A3%85flex%E5%B8%83%E5%B1%80%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[Less封装flex布局常用方法及小工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//flex 布局.flex-main()&#123; width: 100%; display: inline-flex; display: flex; display: -ms-flexbox; display: -webkit-flex; display: -moz-box; position: relative;&#125;//宽度100% 垂直居中 自左到右 不换行.flex-nomal()&#123; .flex-main; align-items: center; -webkit-align-items: center; -moz-align-items: center;&#125;//宽度100% 垂直居中 两端对齐 不换行.flex-between()&#123; .flex-nomal; justify-content: space-between; -webkit-justify-content: space-between; -moz-justify-content: space-between; align-items: center; -webkit-align-items: center; -moz-align-items: center;&#125;//宽度100% 垂直居中 右对齐 不换行.flex-end()&#123; .flex-nomal; justify-content: flex-end; -webkit-justify-content: flex-end; -moz-justify-content: flex-end; align-items: center; -webkit-align-items: center; -moz-align-items: center;&#125;//宽度100% 垂直居中 两端有空隙对齐 不换行.flex-around()&#123; .flex-between; justify-content: space-around; -webkit-justify-content: space-around; -moz-justify-content: space-around;&#125;//宽度100% 垂直居中 两端对齐 换行.flex-wrap()&#123; .flex-between; flex-wrap: wrap; -webkit-flex-wrap: wrap; -moz-flex-wrap: wrap;&#125;//宽度100% 垂直居中 两端有空隙对齐 换行.flex-wrap()&#123; .flex-around; flex-wrap: wrap; -webkit-flex-wrap: wrap; -moz-flex-wrap: wrap;&#125;//垂直 靠左.flex-colum()&#123; .flex-main; flex-direction: column; -webkit-flex-direction: column; -moz-flex-direction: column;&#125;//垂直排列 水平居中.flex-colum_c()&#123; .flex-colum; align-items: center; -webkit-align-items: center; -moz-align-items: center;&#125;//垂直排列 水平居中 垂直居中c.flex-colum_cc()&#123; .flex-colum_c; justify-content: space-between; -webkit-justify-content: space-between; -moz-justify-content: space-between;&#125;//垂直排列 水平靠左 垂直居中c.flex_colum_l()&#123; .flex_colum; align-items: flex-start; -webkit-align-items: flex-start; -moz-align-items: flex-start;&#125;三个常用小方法//图片自适应.img_free()&#123; width: 100%; max-width: 100%; display: block;&#125;//文字省略号.font_over()&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;//不能选择复制.noselect&#123; -moz-user-select: none; -khtml-user-select: none; user-select: none;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[less 入门笔记]]></title>
      <url>%2F2016%2F03%2F06%2Fless%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[什么是LessLess是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。 LessCss可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。 变量变量允许我们单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。 1234567891011121314151617//less 源码 @color: #4D926F; #header &#123; color: @color; &#125; h2 &#123; color: @color; &#125; //编译后的CSS： #header &#123; color: #4D926F; &#125; h2 &#123; color: #4D926F; &#125; 混合（Mixins）混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。 1234567891011121314151617181920212223242526272829//LESS源码： .rounded-corners (@radius: 5px) &#123; -webkit-border-radius: @radius; -moz-border-radius: @radius; -ms-border-radius: @radius; -o-border-radius: @radius; border-radius: @radius; &#125; #header &#123; .rounded-corners; &#125; #footer &#123; .rounded-corners(10px); &#125;//编译后的CSS： #header &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; &#125; #footer &#123; -webkit-border-radius: 10px; -moz-border-radius: 10px; -ms-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px; &#125; 嵌套我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。 123456789101112131415161718192021222324252627282930//LESS源码： #header &#123; h1 &#123; font-size: 26px; font-weight: bold; &#125; p &#123; font-size: 12px; a &#123; text-decoration: none; &amp;:hover &#123; border-width: 1px &#125; &#125; &#125; &#125;//编译后的CSS： #header h1 &#123; font-size: 26px; font-weight: bold; &#125; #header p &#123; font-size: 12px; &#125; #header p a &#123; text-decoration: none; &#125; #header p a:hover &#123; border-width: 1px; &#125; 函数和运算运算提供了加，减，乘，除操作；我们可以做属性值和颜色的运算，这样就可以实现属性值之间的复杂关系。LESS中的函数一一映射了JavaScript代码，如果你愿意的话可以操作属性值。 1234567891011121314151617181920212223//LESS源码： @the-border: 1px; @base-color: #111; @red: #842210; #header &#123; color: (@base-color * 3); border-left: @the-border; border-right: (@the-border * 2); &#125; #footer &#123; color: (@base-color + #003300); border-color: desaturate(@red, 10%); &#125;//编译后的CSS： #header &#123; color: #333; border-left: 1px; border-right: 2px; &#125; #footer &#123; color: #114411; border-color: #7d2717; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用宽度高度]]></title>
      <url>%2F2016%2F02%2F13%2F%E5%B8%B8%E7%94%A8%E5%AE%BD%E5%BA%A6%E9%AB%98%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[常见的基本宽高数据网页可见区域宽1document.body.clientWidth; 网页可见区域高1document.body.clientHeight; 网页正文全文宽1document.body.scrollWidth; 网页正文全文高1document.body.scrollHeight; 网页被卷去的高1document.body.scrollTop; 网页被卷去的左1document.body.scrollLeft; 网页正文部分上1window.screenTop; 网页正文部分左1window.screenLeft; 屏幕分辨率的高1window.screen.height; 屏幕分辨率的宽1window.screen.width; 屏幕可用工作区高度：1window.screen.availHeight; 屏幕可用工作区宽度：1window.screen.availWidth; 屏幕可用工作区高度1window.screen.availHeight; 屏幕可用工作区宽度1window.screen.availWidth; 常用基本数据获取方法scrollHeight: 获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置event.clientX 相对文档的水平座标event.clientY 相对文档的垂直座标event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标document.documentElement.scrollTop 垂直方向滚动的值event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量12345678910要获取当前页面的滚动条纵坐标位置，用：document.documentElement.scrollTop;而不是：document.body.scrollTop;documentElement 对应的是 html 标签，而 body 对应的是 body 标签。在标准w3c下，document.body.scrollTop恒为0，需要用document.documentElement.scrollTop来代替;如果你想定位鼠标相对于页面的绝对位置时，你会发现google里面1000篇文章里面有999.99篇会让你使用 event.clientX+document.body.scrollLeft，event.clientY+document.body.scrollTop， 如果你发现你的鼠标定位偏离了你的想象，请不要奇怪，这是再正常不过的事情。ie5.5之后已经不支持document.body.scrollX对象了。 常用方法一般在开发的时候加上下面这段代码12345678910 if (document.body &amp;&amp; document.body.scrollTop &amp;&amp; document.body.scrollLeft)&#123;top=document.body.scrollTop;left=document.body.scrollleft; &#125;if (document.documentElement &amp;&amp; document.documentElement.scrollTop &amp;&amp; document.documentElement.scrollLeft)&#123;top=document.documentElement.scrollTop;left=document.documentElement.scrollLeft;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有趣的css图形]]></title>
      <url>%2F2016%2F01%2F31%2F%E6%9C%89%E8%B6%A3%E7%9A%84css%E5%9B%BE%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[1.圆形12345#circle&#123; width: 150px; height: 150px; border-radius: 50%; background-color: #232323;&#125; 2.椭圆形12345#elipse&#123; width: 200px; height: 100px; border-radius: 50%; background-color: #232323;&#125; 3.三角形123456#triangle&#123; width: 0; height: 0; border-left: 100px solid transparent; border-right: 100px solid transparent; border-bottom: 150px solid #232323;&#125; 4.平行四边形1234567#parallelogram&#123; width: 200px; height: 100px; background: #232323; -webkit-transform: skew(-45deg); -moz-transform: skew(-45deg); -o-transform: skew(-45deg); transform: skew(-45deg);&#125; 5.梯形1234567#trapezoid&#123; width: 100px; height: 0; border-bottom: 100px solid #232323; border-left: 50px solid transparent; border-right: 50px solid transparent;&#125; 6.六角星123456789101112131415161718#six-star&#123; width: 0; height: 0; position: relative; border-bottom: 100px solid #232323; border-left: 50px solid transparent; border-right: 50px solid transparent;&#125;#six-star:after&#123; content: ""; width: 0; height: 0; position: absolute; left: -50px; top: 35px; border-top: 100px solid #232323; border-left: 50px solid transparent; border-right: 50px solid transparent;&#125; 7.五角星12345678910111213141516171819202122232425262728293031323334#five-star&#123; width: 0px; height: 0px; margin: 50px 0; position: relative; display: block; color: #232323; border-right: 100px solid transparent; border-bottom: 70px solid #232323; border-left:100px solid transparent; -moz-transform:rotate(35deg); -webkit-transform: rotate(35deg); -ms-transform:rotate(35deg); -o-transform:rotate(35deg);&#125;#five-star:before&#123; border-bottom: 80px solid #232323;; border-left: 30px solid transparent; border-right: 30px solid transparent; position: absolute; height: 0; width: 0; top: -45px; left: -63px; display: block; content: ''; -webkit-transform: rotate(-35deg); -moz-transform:rotate(-35deg); -ms-transform:rotate(-35deg); -o-transform:rotate(-35deg);&#125;#five-star:after&#123; position: absolute; display: block; color: #232323; top: 3px; left: -105px; width: 0px; height: 0px; border-right: 100px solid transparent; border-bottom: 70px solid #232323; border-left: 100px solid transparent; -webkit-transform: rotate(-70deg); -moz-transform:rotate(-70deg); -ms-transform:rotate(-70deg); -o-transform:rotate(-70deg); content: '';&#125; 8.十二角星123456789101112131415161718192021222324252627282930#burst-12 &#123; background: red; width: 80px; height: 80px; position: relative; text-align: center; &#125; #burst-12:before, #burst-12:after &#123; content: ""; position: absolute; top: 0; left: 0; height: 80px; width: 80px; background: red; &#125; #burst-12:before &#123; -webkit-transform: rotate(30deg); -moz-transform: rotate(30deg); -ms-transform: rotate(30deg); -o-transform: rotate(30deg); transform: rotate(30deg); &#125; #burst-12:after &#123; -webkit-transform: rotate(60deg); -moz-transform: rotate(60deg); -ms-transform: rotate(60deg); -o-transform: rotate(60deg); transform: rotate(60deg); &#125; 9.八角星1234567891011121314151617181920212223242526#burst-8 &#123; background: red; width: 80px; height: 80px; position: relative; text-align: center; -webkit-transform: rotate(20deg); -moz-transform: rotate(20deg); -ms-transform: rotate(20deg); -o-transform: rotate(20eg); transform: rotate(20deg); &#125; #burst-8:before &#123; content: ""; position: absolute; top: 0; left: 0; height: 80px; width: 80px; background: red; -webkit-transform: rotate(135deg); -moz-transform: rotate(135deg); -ms-transform: rotate(135deg); -o-transform: rotate(135deg); transform: rotate(135deg); &#125; 10.五边形123456789101112131415#pentagon &#123; position: relative; width: 54px; border-width: 50px 18px 0; border-style: solid; border-color: #232323 transparent;&#125;#pentagon:before &#123; content: ""; position: absolute; height: 0; width: 0; top: -85px; left: -18px; border-width: 0 45px 35px; border-style: solid; border-color: transparent transparent #232323;&#125; 11.六边形123456789101112131415161718192021222324#hexagon &#123; width: 100px; height: 55px; background: #232323; position: relative;&#125;#hexagon:before &#123; content: ""; position: absolute; top: -25px; left: 0; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 25px solid #232323; &#125;#hexagon:after &#123; content: ""; position: absolute; bottom: -25px; left: 0; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 25px solid #232323; &#125; 12.爱心12345678910111213141516171819202122232425262728293031323334353637383940#heart &#123; position: relative; width: 100px; height: 90px; &#125; #heart:before, #heart:after &#123; position: absolute; content: ""; left: 50px; top: 0; width: 50px; height: 80px; background: red; -moz-border-radius: 50px 50px 0 0; border-radius: 50px 50px 0 0; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -ms-transform-origin: 0 100%; -o-transform-origin: 0 100%; transform-origin: 0 100%; &#125; #heart:after &#123; left: 0; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); -webkit-transform-origin: 100% 100%; -moz-transform-origin: 100% 100%; -ms-transform-origin: 100% 100%; -o-transform-origin: 100% 100%; transform-origin :100% 100%; &#125; 13.无穷大符号123456789101112131415161718192021222324252627282930313233#infinity &#123; position: relative; width: 212px; height: 100px; &#125; #infinity:before, #infinity:after &#123; content: ""; position: absolute; top: 0; left: 0; width: 60px; height: 60px; border: 20px solid red; -moz-border-radius: 50px 50px 0 50px; border-radius: 50px 50px 0 50px; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); &#125; #infinity:after &#123; left: auto; right: 0; -moz-border-radius: 50px 50px 50px 0; border-radius: 50px 50px 50px 0; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); &#125; 14.鸡蛋12345678#egg &#123; display:block; width: 126px; height: 180px; background-color: red; -webkit-border-radius: 63px 63px 63px 63px / 108px 108px 72px 72px; border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; &#125; 15.食逗人（Pac-Man）123456789101112#pacman &#123; width: 0px; height: 0px; border-right: 60px solid transparent; border-top: 60px solid red; border-left: 60px solid red; border-bottom: 60px solid red; border-top-left-radius: 60px; border-top-right-radius: 60px; border-bottom-left-radius: 60px; border-bottom-right-radius: 60px; &#125; 16.提示对话框1234567891011121314151617181920#talkbubble &#123; width: 120px; height: 80px; background: red; position: relative; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; &#125; #talkbubble:before &#123; content:""; position: absolute; right: 100%; top: 26px; width: 0; height: 0; border-top: 13px solid transparent; border-right: 26px solid red; border-bottom: 13px solid transparent; &#125; 17.钻石1234567891011121314151617181920#cut-diamond &#123; border-style: solid; border-color: transparent transparent red transparent; border-width: 0 25px 25px 25px; height: 0; width: 50px; position: relative; margin: 20px 0 50px 0; &#125; #cut-diamond:after &#123; content: ""; position: absolute; top: 25px; left: -25px; width: 0; height: 0; border-style: solid; border-color: red transparent transparent transparent; border-width: 70px 50px 0 50px; &#125; 18.阴阳八卦（霸气的这个）1234567891011121314151617181920212223242526272829303132#yin-yang &#123; width: 96px; height: 48px; background: #eee; border-color: red; border-style: solid; border-width: 2px 2px 50px 2px; border-radius: 100%; position: relative; &#125; #yin-yang:before &#123; content: ""; position: absolute; top: 50%; left: 0; background: #eee; border: 18px solid red; border-radius: 100%; width: 12px; height: 12px; &#125; #yin-yang:after &#123; content: ""; position: absolute; top: 50%; left: 50%; background: red; border: 18px solid #eee; border-radius:100%; width: 12px; height: 12px; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片转换为base64]]></title>
      <url>%2F2016%2F01%2F19%2F%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BAbase64%E7%9A%84demo%2F</url>
      <content type="text"><![CDATA[base64编码介绍base64是一种网络上常用的8bit字节代码的编码方式，base64可以用于http环境下传递较长的标识信息，同时可以放在url当中使用，因为base64不惧可读性，所以具有一定的 加密 功能。 为什么要把图片转换成base64编码？将图片转换成base64代码可以减少http请求，因为图片可以以字符编码的形式直接传递到客户端，而文件形式都需要进行http请求。但是也会有一个小缺点，就是图片编码化base64的时候大小会变大，但是通过gzip优化以后基本差不多。所以在应用的过程当中较小的图片可以直接编码成base64，较大的图片则不建议如此使用。 html5如何将图片转换成base64？html5如果要将图片转换成base64需要使用到一个html5的接口FileReader.readAsDataURL()接口说明,这个接口可以将文件转换成base64编码格式，并且再以data：URL的形式展现出来。 应用实例demo123456789101112131415161718192021222324252627282930313233343536&lt;!Doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;html5 image to base64&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; //获取dom节点 var img_upload=document.getElementById("img_upload") ,base64_code=document.getElementById("base64_code") ,img_area=document.getElementById("img_area"); // 添加一个监听事件，如果上传文件发生变化就执行readFile函数。 img_upload.addEventListener('change',readFile,false);&#125; //调用接口，将图片转换成base64再输出 function readFile()&#123; var file=this.files[0]; //获取上传的对象 if(!/image\/\w+/.test(file.type))&#123; alert("请确保文件为图像类型"); return false; &#125; var reader=new FileReader(); reader.readAsDataURL(file); reader.onload=function()&#123; base64_code.innerHTML = this.result; img_area.innerHTML = '&lt;div&gt;图片展示：&lt;/div&gt;&lt;img src="'+this.result+'" alt=""/&gt;'; &#125; &#125; &lt;/script&gt; &lt;input type="file" id="img_upload"/&gt;//上传图片 &lt;textarea id="base64_code" rows="30" cols="360"&gt;&lt;/textarea&gt;//base64代码显示 &lt;p id="img_area"&gt;&lt;/p&gt;//图片显示&lt;/body&gt;&lt;/html&gt; 注：this.result这个result是FileReader.readAsDataURL()接口当中转换完图片输出的base64结果存放在result当中。在代码当中添加console.log(reader);查看一下FileReader对象就可以看到。(reader是我自己起的对象的名称)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-基础补充_02]]></title>
      <url>%2F2015%2F06%2F08%2F15-js%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85-02%2F</url>
      <content type="text"><![CDATA[1.ECMAScript是一种标准和规范，JavaScript和JScript是这种规范的实现和扩展。2.ECMAScript5中关于对象(Object)的新方法：(1)获取对象某个属性的描述符：Object.getOwnPropertyDescriptor(对象, “属性名”) 。(2)定义或修改对象某个属性的属性特征(不常用)：描述符.value/writable/enumerable/configurable=”值”/true/false Object.defineProperty(对象,”属性名”,描述符); 注意：这种方法不常用。若使用，则需要两步：修改描述符—→定义/修改属性(3)定义或修改对象某个自有属性的属性特征(常用)： 123456Object.defineProperty(对象,"属性名",&#123; value:"属性值", writable:true/false, enumerable:true/false, configurable:true/false, &#125;); 注意:这种方法只能定义对象自有属性的属性特征，而不能定义对象原型属性的属性特征。(4) Object.preventExtensions(对象)—属性不可添加、可删除、可修改Object.seal(对象) —属性不可添加、不可删除、可修改Object.freeze(对象) —属性不可添加、不可删除、不可修改 注意：(3)为定义或修改对象某个属性的属性特征，(4)为定义或修改对象所有属性的特征。定义或修改对象某个属性的属性特征时，有四个可定义/修改项：属性值、可修改、可枚举、可删除。定义或修改对象所有属性的特征时，有三个可定义/修改项：可添加、可删除、可修改。 (5) Object.getPrototypeOf(对象) 得到对象的proto属性值。 3.ECMAScript5中关于数组(Array)的新方法：ECMAScript5中，大部分数组新方法的参数为一个匿名函数，并且数组的每一个元素调用一次该匿名函数，该匿名函数一般有两个参数:数组元素和索引值。 (1)数组.forEach():从头到位遍历数组，每个元素都调用指定的函数（该方法的参数），该方法在元素遍历结束之前无法终止。1234567891011var arr=[1,3,5,7,9];var sum=0arr.forEach(function(item,index)&#123; sum=sum+item;&#125;);alert(sum);//弹出25。arr.forEach(function(item,index)&#123;// item=item+1;语法错误，只能通过arr[index]改变数组元素的值。 arr[index]=item+1;&#125;);alert(arr[1]);//弹出4。 注意：数组.forEach()可以取代for循环在数组中的应用，无返回值(return)。 (2)数组.map():调用数组的每一个元素传递给指定函数，并返回一个数组，它包含该函数的返回值。12345var arr = [1, 2, 3, 4, 5]var arr1 = arr.map(function(item) &#123; return item * item;&#125;);alert(arr1) //弹出1,4,9,16,25 (3)数组.filter():创建一个新的匹配过滤条件的数组。123456var arr1 = ['Charles', 'Mark', 'Bill', 'Vincent', 'William', 'Joseph']var arr2 = arr1.filter(function(item, index) &#123; return item.indexOf("ll") &gt; -1&#125;);alert(arr2); //弹出Bill、William。 (4)数组.some()查看数组是否有符合条件的元素1234567891011var arr1 = "Charles,Mark,Bill,Vincent,William,Joseph".split(",");alert(arr1.some( function(item, index) &#123; return item.length &lt; 5; &#125;)); //true alert(arr1.some( function(item, index) &#123; return item.length &lt; 10; &#125;)) //true (5)数组.every()查看数组元素是否全部符合条件。1234567891011var arr1 = "Charles,Mark,Bill,Vincent,William,Joseph".split(",");alert(arr1.every( function(item, index) &#123; return item.length &lt; 5; &#125;)); //false alert(arr1.every( function(item, index) &#123; return item.length &lt; 10;&#125;)) //true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生ajax]]></title>
      <url>%2F2015%2F05%2F23%2F14-js%E5%8E%9F%E7%94%9Fajax%2F</url>
      <content type="text"><![CDATA[Json属性值的访问方式12345678var person=&#123;a:1,'b':2,'c':function()&#123;alert(3)&#125;&#125;alert(person.a);//弹出1alert(person['a']);//弹出1alert(person[a]);//语法错误alert(person.b);//弹出2alert(person['b']);//弹出2alert(person.'b');//语法错误person.c();//弹出3 注意：①无论Json中属性名有无引号，通过对象点属性名访问时属性名不可有引号，通过对象中括号属性名访问时属性名必须加引号。②对象的属性名、属性值以及方法名应该加引号，对象的方法值不可加引号。③若调用对象的方法，则只能用对象点方法名小括号的调用方式。Ajax库12345678910111213141516171819202122232425262728293031function ajax(obj) &#123; var xhr = new XMLHttpRequest(); obj.url = obj.url + '?rand=' + Math.random(); xhr.open(obj.method, obj.url, obj.async); xhr.send(null); if (obj.async === false) &#123; callback(); &#125; if (obj.async === true) &#123; xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; callback(); &#125; &#125;; &#125;; function callback() &#123; if (xhr.status == 200) &#123; obj.success(xhr.responseText); //回调 &#125; else &#123; alert('数据返回失败！状态代码：' + xhr.status + '，状态信息：' + xhr.statusText); &#125;; &#125;;&#125;;ajax(&#123; 'method': 'GET', 'url': 'a.txt', 'async': true, 'success': function(a) &#123; alert(a) &#125;&#125;) 注意：执行对象作为参数的函数时调用了该对象的一个方法。 ajax()为一个函数，函数的实参为一个对象，对象有一个success方法。 对象作为实参调用ajax()函数→执行ajax()函数代码→xhr.responseText作为实参调用对象的success方法。 即：对象是ajax()函数的实参，xhr.responseText是对象success方法的实参。 应用实例(Ajax——省市联级)1234567891011121314151617181920212223242526272829303132333435363738394041424344//本json一共有三层：数组[—对象&#123;—数组[。&lt;body&gt; &lt;select id="sel1"&gt; &lt;option&gt;请选择&lt;/option&gt; &lt;/select&gt; &lt;select id="sel2"&gt; &lt;option&gt;请选择&lt;/option&gt; &lt;/select&gt;&lt;script&gt;var xhr = new XMLHttpRequest();xhr.open('GET', 'http://localhost:3000/api/5', true);xhr.send(null);xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; ojson = JSON.parse(xhr.responseText); &#125;; for (var i = 0; i &lt; ojson.length; i++) &#123; //进入第一层内部。 for (var j in ojson[i]) &#123; //进入第二层内部。 sel1.add(new Option(j, j)); //将第二层内部的键插入到sel1。 &#125;; &#125;;&#125;;sel1.onchange = function() &#123; sel2.options.length = 1; for (var i = 0; i &lt; ojson.length; i++) &#123; //进入第一层内部。 for (var j in ojson[i]) &#123; //进入第二层内部。 if (this.value == j) &#123; //判断第二层内部的键是否等于sel1被选项的value值。 for (var n = 0; n &lt; ojson[i][j].length; n++) &#123; //进入第三层内部。 sel2.add(new Option(ojson[i][j][n], ojson[i][j][n])); //将第三层内部的值插入到sel2。 &#125;; &#125;; &#125;; &#125;;&#125;;&lt;/script&gt;&lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMLHttpRequest对象]]></title>
      <url>%2F2015%2F05%2F10%2F13-jsXMLHttpRequest%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[1.XMLHttpRequest对象：发送请求到服务器并获得返回结果。 2.aJax使用步骤：①创建一个XMLHttpRequest对象； ②使用open方法设置ajax参数； ③与服务器建立连接，发送数据到服务端； ④在onreadystatechange事件函数中接收服务器数据。 3.onreadyStatechange事件：当XMLHttpRequest对象的readyState属性值发生变化时，触发该事件。 4.readyState属性:XMLHttpRequest对象的状态信息0——XMLHttpRequest对象没有完成初始化。1——XMLHttpRequest对象开始发送请求。2——XMLHttpRequest对象请求发送完成，已收到全部响应内容。3——XMLHttpRequest对象开始读取响应，还没有结束4——XMLHttpRequest对象读取响应结束。(0)未初始化—→(1)发送请求—→(2)发送完成—→(3)读取响应—→(4)读取结束new XMLHttpRequest()—(0)→open()—(1)→send()—(1)—(4)→responseText 5.status属性:XMLHttpRequest对象的状态码200——服务器响应正常400——无法找到请求的资源403——没有访问权限404——访问的资源不存在500——服务器内部错误new XMLHttpRequest()—(0)→open()—(0)→send()—(0)—(200)→responseText 6.responseText获得响应的文本内容；responseXML获得响应的XML文档对象7.创建一个服务器，并在页面上输出:”hello world!”12345678910111213141516//加载和返回内置的HTTP模块var http = require("http");//创建一个http的服务器http.createServer(function(request, response) &#123; //向请求的客户端发送响应,其中第一个参数为状态码，第二个参数为设置信息的键值对 response.writeHead(200, &#123; "context-type": "text/html" &#125;); //页面上打印的内容 response.write("hello world!"); //结束请求响应 response.end(); //服务器运行在8080端口&#125;).listen(8080);//控制台上输出Server running at localhost:8080 console.log("Server running at localhost:8080");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-实现单例模式的几种方法]]></title>
      <url>%2F2015%2F04%2F29%2F12-js%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1.构造函数内部判断实现单例模式123456789101112131415161718192021function Person() &#123; if (Person.unique !== undefined) &#123; return Person.unique; //若构造函数Person的unique属性值已定义，则返回构造函数Person的unique属性值。 //否则执行以下代码。 &#125;; this.name = 'Jake'; //给实例对象添加属性。 this.say = function() &#123; alert('hello') &#125;; //给实例对象添加方法。 Person.unique = this; //定义构造函数的uneque属性，将构造函数的实例对象赋值给构造函数的unique属性。 &#125;; var p1 = new Person(); var p2 = new Person(); alert(p1 === p2); //弹出true alert(Person.unique === p1); //弹出true。 Person.unique.say() //弹出hello。&#125; 2. 闭包方式实现单例模式123456789101112131415161718192021var single=(function()&#123; //声明一个全局变量singe，single的值为匿名函数的返回值unique。 var unique;//在匿名函数内声明局部变量unique。 function Person()&#123; this.age='20'; this.say=function()&#123; alert('hello') &#125;; &#125;;//在匿名函数内创建构造函数Person。 if (unique===undefined) &#123; unique=new Person(); &#125;;//如果局部变量unique未定义，则将构造函数的实例对象赋值给该局部变量。 return unique;//返回该局部变量（实例对象）。&#125;)()var p1=single;var p2=single;alert(p1===p2);//弹出true。 3.重写构造方式实现单例模式123456789101112131415161718192021222324252627282930原理： function demo()&#123; alert(1); demo=function()&#123; alert(2); &#125;; &#125;; demo();//弹出1 demo();//弹出2 demo();//弹出2 demo();//弹出2 过程：第一次执行函数有两步：①弹出1。②改变变量demo所指向的函数体。 function Person()&#123; this.age='20'; //给实例对象添加属性。 this.say=function()&#123; alert('hello') &#125;; //给实例对象添加方法。 var instance = this; //声明一个局部变量instance，将Person构造函数的实例对象赋值给该变量。 Person=function()&#123; return instance; &#125;; //改变构造函数内部的函数体，使第一次之后实例对象时直接返回变量instance。 &#125;; var p1=new Person(); var p2=new Person(); alert(p1===p2);//弹出true。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-数据交互]]></title>
      <url>%2F2015%2F04%2F21%2F11-js%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%2F</url>
      <content type="text"><![CDATA[1.可以使用eval函数将字符串转换为JSON对象。1eval('('+string+')'); 高级版本的浏览器中将字符串转为JSON格式：JSON.parse(string);高级版本的浏览器中将JSON转为字符串：JSON.stringify(obj) 2.用for in解析JSON数据。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 var people = &#123; "programmers": [&#123; "firstName": "Brett", "lastName": "McLaughlin", "email": "aaaa" &#125;, &#123; "firstName": "Jason", "lastName": "Hunter", "email": "bbbb" &#125;, &#123; "firstName": "Elliotte", "lastName": "Harold", "email": "cccc" &#125;], "authors": [&#123; "firstName": "Isaac", "lastName": "Asimov", "genre": "science fiction" &#125;, &#123; "firstName": "Tad", "lastName": "Williams", "genre": "fantasy" &#125;, &#123; "firstName": "Frank", "lastName": "Peretti", "genre": "christian fiction" &#125;], "musicians": [&#123; "firstName": "Eric", "lastName": "Clapton", "instrument": "guitar" &#125;, &#123; "firstName": "Sergei", "lastName": "Rachmaninoff", "instrument": "piano" &#125;] &#125;;for (i in people) &#123; for (n = 0; n &lt; people[i].length; n++) &#123; var tr = document.createElement('tr'); for (m in people[i][n]) &#123; var td = document.createElement('td'); td.innerHTML = people[i][n][m]; tr.appendChild(td); &#125;; document.getElementById(i).appendChild(tr); &#125;; &#125;; 注意：var people = {“programmers”: [{“firstName”: “Brett”,……12345678910111213141516171819202122 第一步：利用for循环(数组)和for in(json)打通每一层通道。 for (var i in people) &#123;进入第一层内部for (var j=0;j&lt; people[i].length;j++)&#123;进入第二层内部 for (var n in people[i][j]) &#123;进入第三层内部 &#125;; &#125;; &#125;;第二步：最内层内创建插入单元格，最内层外创建插入行。 for (var i in people) &#123; for (var j=0;j&lt; people[i].length;j++) &#123; var tr=document.createElement('tr'); for (var n in people[i][j]) &#123; var td=document.createElement('td'); td.innerHTML=people[i][j][n]; tr.appendChild(td); &#125;; document.getElementById(i).appendChild(tr); &#125;; &#125;; jq 数据交互方法12345678910111213141516171819202122232425262728293031323334353637383940function getData(ID,urls,pages)&#123;//ajax请求 $.ajax(&#123; url:urls, type:"POST", dataType:"json", data:&#123;page:pages&#125;, async: false, success:function(data)&#123; if(data &amp;&amp; data.code=='success')&#123; var dataD=data.data; var str=""; if(dataD.length==0&amp;&amp;pages==1)&#123; $(ID).html('&lt;li&gt;'+"暂时没有数据"+'&lt;/li&gt;').css(&#123; "text-align":"center", "color":"#ccc" &#125;); return false; &#125;else if(dataD.length==0&amp;&amp;pages!=1)&#123; return; &#125; else&#123; $.each(dataD,function(index,val)&#123; str +='&lt;li&gt;&lt;span class="money"&gt;'+val.money+'元'+'&lt;/span&gt;&lt;span class="dates"&gt;'+val.time+'&lt;/span&gt;' if(val.state==0)&#123; str+='&lt;span class="state state0"&gt;'+'提现失败'+'&lt;/span&gt;&lt;/li&gt;' &#125;else if(val.state==1)&#123; str+='&lt;span class="state state1"&gt;'+'提现成功'+'&lt;/span&gt;&lt;/li&gt;' &#125;else if(val.state==2)&#123; str+='&lt;span class="state state2"&gt;'+'审核中'+'&lt;/span&gt;&lt;/li&gt;' &#125; &#125;) &#125; $(ID).append(str); &#125;else&#123; &#125; &#125; &#125;)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-继承]]></title>
      <url>%2F2015%2F04%2F10%2F10-js%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[继承默认情况：子类—prototype→子类的原型 123子类的原型—constructor→子类 Student.prototype=Student.prototype Student.prototype.constructor=Student; 1.继承的第一种方法：call、apply、bind1234567call、apply、bind 略有不同；call和apply主要是传递参数的方法不同call(对象，实参1，实参2……)apply(对象，[实参1，实参2……])bind 与call和apply的区别是需要自执行(方法后加个小口号“()”)，如下两种方式否可以实现用bind继承：bind(对象，实参1，实参2……)()bind(对象，[实参1，实参2……])() 2.继承的第二种方法：子类—prototype→父类实例123子类原型指向父类实例 父类实例（子类原型）—constructor→子类Student.prototype=new Person(); Student.prototype.constructor=Student; 3.继承的第三种方法： 子类—prototype→父类原型子类原型指向父类原型 父类原型（子类原型）—constructor→子类Student.prototype=Person.prototype;Student.prototype.constructor=Student; 4.继承的第四种方法： 定义一个空类12345678定义空类作为桥梁 空类—prototype→父类 子类—prototype→空类实例空类实例（子类原型）—constructor→子类 var F=function()&#123;&#125; F.prototype=Parent.prototype; Child.prototype=new F; Child.prototype.constructor=Child; 5.继承的第五种方法： ①拷贝类的原型属性for in12345678910111213141516171819①for (i in Parent.prototype) &#123; Child.prototype[i]=Parent.prototype[i]; &#125;;②拷贝对象的所有属性（浅拷贝）for infor (i in p1) &#123; c1[i]=p1[i]; &#125;; ③拷贝对象的所有属性（深拷贝） for in实现数组与对象数据本身的拷贝，而不仅复制栈地址。function extend(child, parent) &#123; //深拷贝封装函数 for (i in parent) &#123; if ((typeof parent[i]) === 'object') &#123; child[i] = (parent[i].constructor === Array) ? [] : &#123;&#125;; extend(child[i], parent[i]) &#125; else &#123; child[i] = parent[i]; &#125;; &#125;; &#125; 6. 继承的第六种方法：对象继承对象的属性，与类无关。1234567891011121314语法：var 子对象=Object.create(父对象，子对象的自有属性) 。举例：var 子对象名 = Object.create(父对象名, &#123; 属性名1: &#123; writable: true,//该属性是否可修改 enumerable: true,//该属性是否可枚举 configurable: true,//该属性是否可删除 value: ‘属性值’, //该属性的属性值。 &#125;, 属性名2: &#123; writable: true, enumerable: true, configurable: true, value: ‘属性值’ &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-闭包]]></title>
      <url>%2F2015%2F03%2F25%2F09-js%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[闭包1.概念：将父函数的局部变量放在子函数中，将子函数作为父函数的返回值，扩展局部变量的访问范围，使函数外可以访问和修改局部变量。 2.任何一个函数都是一个对象的方法，函数中的this指代该函数作为一个方法所属于的对象。一个自由函数是全局变量window的方法。3.对象属性的访问权限：①私有变量(var a=1;)只能被私有函数或特权方法访问。 ②私有函数(var fn=function(){};)只能被特权方法访问。 ③特权方法(this.say=function(){})可以在对象外部访问。 特点：1.逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑。 2.方便调用上下文的局部变量。 3.加强封装性，第2点的延伸，可以达到对变量的保护作用。 优点：1.保护函数内的变量安全,加强了封装性 2.在内存中维持一个变量(用的太多就变成了缺点，占内存) 缺点：闭包有一个非常严重的问题，那就是内存浪费问题， 这个内存浪费不仅仅因为它常驻内存，更重要的是， 对闭包的使用不当会造成无效内存的产生。 闭包之所以会占用资源是当父函数执行结束后，子函数扩展的变量不随着销毁。以为执行子函数的时候需要依赖父函数中的变量。不适合场景：返回闭包的函数是个非常大的函数 应用：闭包的典型框架应该就是jquery了。 闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。 这在做框架的时候体现更明显，有些方法和属性只是运算逻辑过程中的使用的，不想让外部修改这些属性，因此就可以设计一个闭包来只提供方法获取。 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-基础补充_01]]></title>
      <url>%2F2015%2F03%2F13%2F08-js%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85-01%2F</url>
      <content type="text"><![CDATA[1.parseInt(‘n进制数字’,n) ——将n进制数字转化为10进制数字，当n等于10时，可以简写为parseInt(‘10进制数字’)。1234alert(parseInt('23',10)) //弹出23。alert(parseInt('23',16)) //弹出35。alert(parseInt('11',2)) //弹出3。alert(parseInt('23',8)) //弹出19。 2.当未将函数赋值给一个变量时，函数名即代表函数整体，通过函数名加括号()调用函数执行；当将函数赋值给一个变量时，该变量代表函数整体，通过变量名加括号()调用函数执行。在书写代码时，如果想调用函数执行，通过函数名加括号或者变量名加括号的方式，如果想要引入函数整体，则通过函数名不加括号、变量名不加括号或者直接写整个函数整体的方式。 应用：①DOM2级事件处理程序中addEventListener(“事件”,demo)，demo表示引入函数整体，而不是调用函数执行，因此不可加括号。 ②事件函数有两种写法，一种是事件等于函数整体，一种是事件等于函数名无括号（等价于函数整体）。 123456789101112131415&lt;script&gt; function demo()&#123; alert('1') &#125; demo()//弹出1 alert(demo) //弹出function demo()&#123;alert('1')&#125;。&lt;/script&gt;&lt;script&gt; var a=function demo()&#123; alert('1') &#125; a()//弹出1 alert(a)//弹出function demo()&#123;alert('1')&#125; alert(demo) //语法错误：demo is not defined&lt;/script&gt; 3.构造函数也是一个对象，既可以给构造函数添加属性，又可以给构造函数实例出的对象添加属性。123456789101112131415161718192021222324252627&lt;script&gt;function Person(age)&#123; Person.age1='10'; //构造函数也是一个对象，给构造函数添加属性，与实例出的对象无关。 this.age=age; //给构造函数实例出的对象添加属性，与构造函数无关。&#125;alert(typeof Person);//弹出functionvar p1=new Person(20);alert(p1.age1); //弹出undefined。alert(p1.age); //弹出20。alert(Person.age1); //弹出10。alert(Person.age);//弹出undefined。&lt;/script&gt;//给构造函数自身添加属性：只有函数被调用之后，函数内的代码才会被执行，构造函数才会被添加属性。&lt;script&gt;function Person()&#123; Person.age=1;&#125;;alert(Person.age);//此时构造函数内代码未执行，构造函数的age属性未添加，弹出undefined。Person();alert(Person.age);//此时构造函数内代码已执行，构造函数的age属性已添加，弹出1。&lt;/script&gt; 4.检测及遍历对象的属性语法：①”属性名” in 对象——判断该属性是否是该对象的属性（自有属性或者原型属性），返回值为布尔类型。②对象.hasOwnProperty(“属性名”);——判断该属性是否是该对象的自有属性，返回值为布尔类型。 ③for(变量 in 对象){}遍历对象的属性（自有属性或者原型属性），在花括号中，变量指代该对象的属性名，对象[变量]指代该对象的属性值。 ④delete 对象.属性名;——删除对象的该属性。 注意：在方法①和方法②中，引号不可省略。 1234567891011121314151617181920212223242526272829303132333435363738例题：&lt;script&gt;function Person(name,age)&#123; Person.type="函数"; //给构造函数添加自有属性 this.name=name; //给实例对象添加自有属性 this.age=age; //给实例对象添加自有属性 this.say=function()&#123; //给实例对象添加自有属性 alert('你好') &#125;&#125;Person.prototype.height="1.8米";//给构造函数的prototype（实例对象的_proto_）添加属性//此处应注意：构造函数的prototype不等价于构造函数的_proto_var p1=new Person("Jake","26");//从构造函数中实例出对象p1alert('type' in Person);//弹出truealert('type' in p1);//弹出falsealert('age' in Person);//弹出falsealert('name' in p1);//弹出truealert('height' in Person);//弹出false。因为Person.prototype指向Person原型对象，指向p1的_proto_原型对象，Person的_proto_指向上一级构造函数的原型对象alert(p1.hasOwnProperty('age'))//弹出truealert(p1.hasOwnProperty('height'))//弹出falsealert(Person.hasOwnProperty('type'))//弹出true//属性名要加引号for(pro1 in p1)&#123; document.write("属性名："+pro1+";属性值："+p1[pro1]+"&lt;br /&gt;") //弹出name、age、say、height属性名及对应属性值&#125;for(pro2 in Person)&#123; document.write("属性名："+pro2+";属性值："+Person[pro2]+"&lt;br /&gt;") //弹出type属性名及对应属性值（无height属性）&#125;delete p1.name;//删除实例对象p1的name属性 for(pro1 in p1)&#123; document.write("属性名："+pro1+";属性值："+p1[pro1]+"&lt;br /&gt;") //弹出age、say、height属性名及对应属性值&#125;&lt;/script&gt; 5.每一个栈空间中存放的可能是基本数据类型（Number、string、……）的数据本身，也可能是引用数据类型在堆中存放的数据地址。(栈:stack;堆:heap)6.对于基本数据类型而言，每一个变量名与每一个栈空间与每一个数据本身都是一一对应的关系，并不存在多个变量名对应一个数据的情况。对于引用数据类型而言，每一个变量名对应每一个栈空间，多个栈空间可能存放同一个堆地址，指向同一个数据本身。即：对于基本数据类型，变量名与数据本身一一对应，相互并不影响。对于引用数据类型，多个变量名可能对应同一个数据本身，独自都可以修改堆空间中存放的数据本身。对于基本数据类型，a=b的含义为将变量b对应栈空间中存放的数据本身复制一份存放在变量a对应的栈空间中，数据本身发生复制。 对于引用数据类型以及自定义对象，a=b的含义为将变量b对应栈空间中存放的堆地址复制一份存放在变量a对应的栈空间中，堆地址对应的堆空间中存放的数据本身并未发生复制。对于引用数据类型以及自定义对象，即使a=b，变量a与变量b也并不对应同一块栈空间，只是它们所对应的不同栈空间中存放的是同一个堆地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 例题1-1： &lt;script&gt; var a=[1]; var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 a=a.push(2); //修改变量a对应栈空间中存放的堆地址对应的堆空间中的数据本身。 alert(b); //弹出1,2 &lt;/script&gt;例题1-2： &lt;script&gt; var a=new Object(); var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 a.age=12; //修改变量a对应栈空间中存放的堆地址对应的堆空间中的数据本身。 alert(b.age);//弹出12 &lt;/script&gt;例题1-3： &lt;script&gt; var a=[1]; var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 b.age=2; //修改变量b对应栈空间中存放的堆地址对应的堆空间中的数据本身。 a.age=1; //修改变量a对应栈空间中存放的堆地址对应的堆空间中的数据本身。 alert(b.age);//弹出1 &lt;/script&gt;注意：只有点能够修改堆空间中存放的数据本身，只有等号则重新开辟一块堆空间存放新数据。例题2-1： &lt;script&gt; var a=[1]; var b=[1]; //与b=a的含义不同。此时虽然数组b与数组a的数值相等，但是含义为新申请一块堆空间，存放数据[1],在变量b对应的栈空间中存放该堆地址。此时有两个堆空间都存放数据[1]。变量a与变量b对应不同的数据，互不影响。 a.age=23; alert(b.age);//弹出undefined。 &lt;/script&gt;例题2-2： &lt;script&gt; var a=[1]; var b=a; //变量a对应栈空间中存放的堆地址复制一份存放在变量b对应栈空间中。 a=[1,2]; //注意:这一步为重新申请一块堆空间，存放数据[1,2]，并在变量名a对应栈空间中清除老的堆地址，存放该新申请的堆地址。——①并未改变变量名a对应的栈空间以前存放的堆地址对应的数据本身。②并未改变变量名b对应的栈空间中所存放的堆地址。 alert(b);//弹出1。 &lt;/script&gt; 7.全局变量的作用范围：从当前全局变量的声明位置到最后一个script标签的结束位置。123456789101112131415161718192021222324 例题1-1： &lt;script&gt; var a=1; alert(a);//弹出1。 &lt;/script&gt;例题1-2： &lt;script&gt; alert(a);//弹出undefined。 var a=1; &lt;/script&gt;例题1-3： &lt;script&gt; var a=1; &lt;/script&gt; &lt;script&gt; alert(a);//弹出1。 &lt;/script&gt;例题1-4： &lt;script&gt; alert(a);//运行错误：a is not defined &lt;/script&gt; &lt;script&gt; var a=1; &lt;/script&gt; 8.JavaScript预解析是把变量、函数以及函数的参数预解析到他们能调用的环境中，并将其赋一个初始值。预解析对象：①var 变量名 ②function 变量名(){} ③函数形式参数（等价于var 变量名） 预解析结果：var 变量 ——解析为—→ 变量名=undefined function 变量名(){} ——解析为—→ 变量名=function 变量名(){} 同一变量名:②预解析结果优先级高于①预解析结果undefined的优先级。 所有变量声明在预解析阶段完成，当开始逐行解读代码后只能通过表达式（赋值运算符）来改变变量的值和类型。（动态语言） 注意：JavaScript不会预解析的两种情况 ①无var的变量。②变量名=function (){} 12345678910111213141516171819202122232425262728293031例题1-1： &lt;script&gt; alert(a);//弹出undefined。 var a=1; &lt;/script&gt;例题1-2： &lt;script&gt; alert(demo);//弹出undefined。 var demo=function()&#123; alert(1) &#125; &lt;/script&gt;例题1-3： &lt;script&gt; alert(a);//运行错误，a is not defined。 a=1; &lt;/script&gt;例题1-4： &lt;script&gt; alert(demo); //弹出function demo()&#123;alert(1)&#125;。 function demo()&#123; alert(1) &#125; &lt;/script&gt;例题1-5： &lt;script&gt; alert(demo);//运行错误：demo is not defined。 demo=function()&#123; alert(1) &#125; &lt;/script&gt; 9.变量预解析与变量值修改预解析的意义———生成当前环境中的变量对象。 变量预解析：①var 变量名 ②function 变量名(){} ③函数形式参数 变量值修改：①var 变量名= ②变量名=（赋值运算符是修改变量值的标志） 注意：①var 变量名=function(){} 可预解析可修改，预解析结果为变量名=undefined，修改后结果为变量名=function(){}②function 变量名(){}这种写法虽然也表示变量名等于整个函数体，但是由于没有赋值运算符，所以只会在预解析过程中修改变量值，不会在代码执行过程中修改变量的值。 1234567891011121314151617181920212223242526272829303132333435例子1： &lt;script&gt; alert(a);//弹出function a()&#123; alert ("better");&#125;; var a=1;//可预解析，可修改。 alert (a);//弹出1。 var a=function ()&#123; alert("good"); &#125;; //可预解析，可修改。 alert (a);//弹出function ()&#123; alert("good");&#125;; a=3;//不可预解析，可修改。 alert(a);//弹出3。 function a()&#123; alert ("better"); &#125;;//可预解析，不可修改。 alert (a) //弹出3。 &lt;/script&gt;例子2： &lt;script&gt; alert(a);//预解析之后，a=function a() &#123;alert("pleased")&#125;; //故弹出 function a() &#123;alert("pleased")&#125;; function a() &#123; alert("bad") &#125;; //可预解析，不可修改，a=function a() &#123;alert("pleased")&#125; a();//弹出pleased。 var a = 3;//可预解析，可修改。a=3; alert(a);//弹出3。 var a = function() &#123; alert("happy") &#125;;//可预解析，可修改。 a = function() &#123;alert("happy")&#125;; a();//弹出happy。 function a() &#123; alert("pleased") &#125;;//可预解析，不可修改。a = function() &#123;alert("happy")&#125;; a();//弹出happy。 &lt;/script&gt; //注意：①关注代码执行过程中变量名a对应的值是否发生改变，只有出现赋值运算符时，变量a的值才会被修改。②只有当变量名a对应的值是一个函数体的时候，a()才会执行，并且执行变量名a当前对应函数体中的代码。 10.执行环境——每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。也是一个环境。变量对象——存放当前所在环境中的所有变量和函数； 作用域——变量可产生作用的区域，基本相当于当前执行环境； 作用域链(由内向外搜索变量)——当代码进入一个新环境时，会产生新的变量对象，变量对象有新的作用域，新的作用域与上一级作用域链接形成作用域链。 函数形参预解析过程——函数的形式参数在函数调用过程中第一次被赋值，在函数执行过程中可能会被多次赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566举例1-1: &lt;button id="btn"&gt;111&lt;/button&gt; &lt;script&gt; btn.onclick = function() &#123; name = 10;//这里的name未声明，为全局变量 b(name); //等价于b(10),10为实参,调用函数b时赋值 alert(name); //弹出全局变量name等于10 &#125;; function b(name) &#123; //隐含条件:var name=“实参(10)”;此时name为局部变量 name = 20; //变量name已声明,为局部变量name=20 &#125;; &lt;/script&gt;举例1-2: &lt;button id="btn"&gt;222&lt;/button&gt; &lt;script&gt; btn.onclick = function() &#123; name = 10;//这里的name未声明，为全局变量 b(name); //等价于b(10),10为实参,调用函数b时赋值 alert(name); //弹出全局变量name等于20 &#125;; function b(n) &#123; //隐含条件:var n=“实参”;此时n为局部变量。 name = 20; //变量name未声明，为全局变量name=20 &#125;; &lt;/script&gt;例题2-1： &lt;script&gt; var a = 1; //外层执行环境(全局)变量a=1 function fn1() &#123; alert(a); //内层执行环境预解析结束，无a，调用外层执行环境(全局)变量a=1 a = 2; //改变外层执行环境(全局)变量a=2 &#125;; fn1();//弹出1 alert(a)//弹出2 &lt;/script&gt;例题2-2： &lt;script&gt; var a = 1; //外层执行环境(全局)变量a=1 function fn2() &#123; alert(a); //内层执行环境预解析结束，内层环境变量a=undefined var a = 2; //改变内层环境变量a=2 &#125;; fn2();//弹出undefined alert(a) //弹出外层环境(全局)变量a=1 &lt;/script&gt; 例题2-3： &lt;script&gt; var a = 1;//全局变量a=1 function fn1(a) &#123;//隐含条件:var a=“实参”;此时a为局部变量,未传入实参,局部变量a=undefined alert(a); a = 2;//改变局部变量a=2 &#125; fn1();//执行函数，弹出局部变量a等于undefined alert(a);//弹出全局变量a=1 &lt;/script&gt;例题2-4： &lt;script&gt; var a = 1;//全局变量a=1。 function fn1(a) &#123;//隐含条件:var a=“实参”;此时a为局部变量,传入实参1,局部变量a=1 alert(a); a = 2;//改变局部变量a=2 &#125; fn1(a);//执行函数，弹出局部变量a等于1 alert(a);//弹出全局变量a=1 &lt;/script&gt; 11.元素.scrollTop含义为元素滚动条的向下滚动的距离、元素可视区向下移动的距离、元素向上卷动的距离。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-原型与原型链]]></title>
      <url>%2F2015%2F03%2F08%2F07-js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
      <content type="text"><![CDATA[1.原型与构造函数（类）一一对应。原型与构造函数的名字相同，都为构造函数名，但是构造函数的数据类型为function，而原型数据类型为Object注意：原型与构造函数不一定一一对应。赋值—— 若：Worker.prototype=Person.prototype则：Person类、Worker类—→Person原型过程：此时Person、Worker两个构造函数的prototype都指向Person原型，而Person原型的constructor指向Person构造函数。（P31蓝色箭线起始位置分叉）继承——若：for (i in Person.prototype) {Worker.prototype[i] = Person.prototype[i]}则：Person原型—→Person类；Worker原型—→Worker类过程：此时Person构造函数的prototype都指向Person原型，Worker构造函数的prototype都指向Worker原型。其实，Person与Worker在原型链中是平行的关系，而不是后代的关系。 2.对象和原型都可以定义属性和方法，构造函数（类）没有对象或原型的属性和方法，构造函数中的this指代的不是构造函数自身，而是构造函数所实例出的对象。3.给原型添加新属性，与该原型相对应（原型—构造函数—对象）的所有对象都拥有该属性；给对象添加新属性，不会在对应原型中添加对应的属性；修改对象从原型中继承属性的属性值，该对象会有两个同名属性，一个是该对象自有的属性，一个是从原型中继承的属性，两个同名属性的属性值不同，自有属性的属性值优先级高于原型属性的属性值，自有属性的属性值不影响原型同名属性的属性值，原型同名属性的属性值不变；修改原型中已有属性的属性值，如果对象已定义同名属性的新的属性值，则对象的属性值不变，如果对象没有定义同名属性的新的属性值，对象的属性值随原型属性值的改变而改变即：修改原型属性，不一定影响对象；修改对象属性，一般不影响原型。注意：所有的自定义对象都可以通过对象直接给原型添加属性，也都可以添加自有属性，所有的内置对象（包括：1，“abc”）都可以通过对象直接给原型添加属性，但并不是所有的内置对象都可以添加自有属性——①Object对象数据类型既可以添加自有属性，又可以给原型添加属性：数组new Array、函数function、元素（例外情况：null为Object数据类型但既不可以添加自有属性属性，又不可以给原型添加属性。）。②直接写的基本数据类型不可以添加自有属性，但可以通过直接写的基本数据类型给原型添加属性：boolean、number、string。（例外情况：undefined为基本数据类型但既不可以添加自有属性属性，又不可以给原型添加属性。）③从类中new出来的基本数据类型为Object，既可以添加自有属性，又可以给原型添加属性。 4.既可以通过构造函数（类）给原型添加或修改属性和方法，又可以通过对象直接给原型添加或修改属性和方法。原型由两部分组成，一部分是原型属性与属性值组成的键值对集合，一部分是原型的constructor属性，该属性指向对应的构造函数（类）（每一个函数都有一个prototype原型属性，这个属性是一个指针，指向该函数的原型对象）。构造函数有三个作用，一个作用是给原型添加或修改属性，第二个作用是实例出对象，第三个作用是给构造函数实例出的对象添加各自不同的属性值。构造函数在原型构造对象过程中存在的最大意义即是实例出对象，在对象与原型之间搭建桥梁；第二意义是对实例出的对象添加各自不同的属性值，第三意义是给原型添加或修改属性，由于构造函数实例出的对象也可以直接给原型添加或修改属性，所以这一过程虽然很常用，但意义并不重大。 5.构造函数（类）.prototype.属性名=属性值。——含义为给构造函数、实例对象的原型添加（修改）一个属性。构造函数（类）.prototype={}——含义为用一个新的对象覆盖构造函数的原型对象。此时新原型对象的constructor属性值无法指向当前构造函数，需要定义新原型对象的constructor属性为当前构造函数。 6.对象.proto.属性名=属性值。——含义为给实例对象、构造函数的原型添加（修改）一个属性。7.在JavaScript中，一切对象都有proto属性，而只有函数有Prototype属性。三条原型链：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 ①由字面量或工厂方式定义的对象到Object： 字面量构造对象/工厂方式构造对象P3—_ptoto_→Object ②由构造函数（类）到Object: Person构造函数（类）—_ptoto_→function()—_ptoto_→Object ③由构造函数实例出的对象到Object： P1、P2—_ptoto_→Person(Person构造函数(类)的prototype属性属性值)—_ptoto_→Object 原型链： ①第一行矩形中内容表示原型对象，底行矩形中内容表示构造函数。 ②箭头起始矩形中内容为对象，箭头上的椭圆表示该对象的属性名，箭头指向矩形中内容为该对象的属性值。 ③没有椭圆的箭头表示该对象的_proto_属性值，没有椭圆的箭头组成原型链。 过程： ①所有对象都有_proto_属性，所有的_proto_属性都指向原型。 ②所有原型的_proto_属性都指向object原型，所有构造函数的_proto_属性都指向上一级原型。 ③只有函数有prototype属性，函数的prototype属性指向它的原型。 结论： ①函数的prototype指向它的原型、函数的_proto_指向上一级原型，原型的_proto_指向Object原型。 ②函数—prototype→同级原型；函数—_proto_→上一级原型；原型—construct→同级函数；原型—_proto_→object原型。 ③类即是一个函数，原型的原型即是一个对象（Object），可以设置对象的原型指向一个明确的Object（原型或实例对象）。 例子1： &lt;script&gt; var p1=&#123;name:'Jake'&#125; //字面量 function Person(a)&#123; //工厂方式 var o=new Object(); o.name=a; return o; &#125; p2=Person('Jake') function demo(a)&#123; //构造函数 this.name=a; &#125; p3=new demo('Jake'); &lt;/script&gt; &lt;script&gt; function Person()&#123;&#125; var person1=new Person(); person1.__proto__.name='Jake';//通过对象给原型添加属性。 alert(Person.prototype.name);//通过构造函数访问原型的属性，弹出Jake。 Person.prototype.age='26';//通过构造函数给原型添加属性。 alert(person1.__proto__.age);//通过对象访问原型的属性，弹出26。 alert(person1.name);//访问对象的原型属性，弹出Jake。 alert(Person.age);//弹出undefined，构造函数没有继承原型的属性。注意：每一个函数都有一个name属性，该属性的属性值是指向该函数的函数名。每一个函数都有一个prototype属性，该属性的属性值指向该函数的原型对象。 person1.name='Jason';//给对象新添加一个在原型中同名的自有属性。 alert(person1.name);//弹出Jason。 alert(person1.__proto__.name)//弹出jake，原型对象的同名name属性的属性值并未改变。 &lt;/script&gt;注意：对象可以访问原型的属性，可以继承原型的属性，可以直接给原型添加（修改）属性，可以新添加原型中同名的自有属性，也可以创建原型中所没有的自有属性；构造函数可以访问原型的属性，可以给原型添加（修改）属性，可以给对象添加（修改）自有属性，也可以实例出对象。例子2： &lt;script&gt; function Person()&#123;&#125; Person.prototype=&#123; //创建新的原型，覆盖之前的原型。 constructor:'Person',//定义新原型的构造方法指向Person。 name:[1,2], //给原型对象添加name属性。 &#125; var p1=new Person();//在构造函数中实例（new）出对象p1。 var p2=new Person();//在构造函数中实例（new）出对象p2。 p1.name.push(4);//这种方式并不是给对象p1新添加一个在原型中同名的name自有属性，而是修改p1的原型的name属性值。 alert(p1.name); //获取对象p1的name属性值，弹出1,2,4。 alert(p2.name); //获取对象p2的name属性值，弹出1,2,4。说明原型的name属性值被改变。 &lt;/script&gt;例子3： &lt;script&gt; function Person()&#123;&#125; Person.prototype=&#123; //新的原型覆盖之前的原型。 constructor:'Person', //定义新原型的构造方法指向Person。 name:[1,2], //给原型添加name属性。 say:function()&#123; //给原型添加say属性。 return this.name;//返回原型对象的name属性值。 &#125; &#125; var p1=new Person();//在构造函数中实例（new）出对象p1。 var p2=new Person();//在构造函数中实例（new）出对象p2。 alert(p1.say()); //获取对象p1在原型中继承的say属性，弹出1,2。 p1.name=[1,2,3];//给对象P1新添加一个在原型中同名的name自有属性，属性值为[1,2,3]。 alert(p1.name); //获取p1的name属性值，由于name自有属性的属性值优先级高于原型中继承的同名name属性的属性值，所以弹出1,2,3。 alert(p2.name); //弹出1,2。说明原型的name属性值未被改变。 p1.name.push(4);//通过这种方式修改对象p1的name自有属性的属性值。 alert(p1.name);//弹出1,2,3,4。 alert(p2.name); //弹出1,2。说明原型的name属性值仍未被改变。 p1.name1=['a','b','c'];//在对象p1中增加name1属性。 alert(p1.name1);//弹出a,b,c alert(p2.name1);//弹出undefined。说明原型中并未添加name1属性。 &lt;/script&gt;例子4（对象自定义原型1）： &lt;script&gt; var a = &#123; x: 10,calculate: function(z) &#123; return this.x + this.y + z &#125; &#125;;//字面量构造对象a，未自定义对象a的原型，对象a的原型指向Object。 var b = &#123; y: 20,__proto__: a&#125;;//字面量构造对象b，自定义对象b的原型为对象a。 var c = &#123; y: 30&#125;;//字面量构造对象c，未自定义对象c的原型，对象c的原型指向Object。 alert(b.calculate(30));//弹出60 &lt;/script&gt;例子5（对象自定义原型2）： &lt;script&gt; var a=&#123;age:10,say:function()&#123; alert('hello') &#125;&#125;; var b=&#123;age:20,__proto__:a&#125;; b.say();//弹出hello。 var c=&#123;age:30,__proto__:b&#125;; c.say();//弹出hello。 &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-函数]]></title>
      <url>%2F2015%2F03%2F01%2F06-js%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[函数基础学习总结1.递归：函数调用自身的编程技巧称为递归。注意：①如果要用递归得到数学运算的最终结果，每一个递归函数的返回值即是当前递归次数的最终数学运算结果。②用历史递归函数所有的返回值（函数值）和参数（即递归次数）表示当前递归函数的返回值（函数值）。 例子1：求1+2+3+……10012345678function getSum(n)&#123; if (n==1) &#123; return 1; &#125; else&#123; return getSum(n-1)+n &#125; &#125; alert(getSum(100)) 例子2：求1,1,2,3,5,8……的第25项12345678function getNum(n)&#123; if (n==1||n==2) &#123; return 1; &#125; else&#123; return getNum(n-1)+getNum(n-2); &#125;&#125;alert(getNum(25)) 例子3：求1！+2！+3！+……+10！1234567891011function getSum(n) &#123; if (n == 0) &#123; return 0; &#125; else if (n == 1) &#123; return 1; &#125; else &#123; return getSum(n - 1) + (getSum(n - 1) - getSum(n - 2)) * n; //用上一次和上上一次递归函数的返回值（函数值）以及n表示当前递归函数的返回值（函数值）。 &#125;&#125;alert(getSum(10)) 2.创建一个函数，将html元素的id名作为函数的参数，将该html元素作为函数相对应的返回值。123456789&lt;p id="pid"&gt;123&lt;/p&gt;&lt;div id="div"&gt;abc&lt;/div&gt;&lt;script&gt; function id(a)&#123; return document.getElementById(a) &#125; alert(id("pid").innerHTML) //弹出123 alert(id("div").innerHTML) //弹出abc&lt;/script&gt; 注意：在调用此函数时，实际参数的赋值必须为带引号的ID名。3.创建一个insertAfter(新子节点，旧子节点)函数，该函数可以使新子节点插入到旧子节点之后。12345678910111213141516171819&lt;div id="div1"&gt;第一个DIV&lt;/div&gt;&lt;div id="div2"&gt;第一个DIV&lt;/div&gt;&lt;div id="div3"&gt;第一个DIV&lt;/div&gt;&lt;script&gt; var p=document.createElement("p"); p.innerHTML="这是新增的p元素"; var div1=document.getElementById("div1"); var div2=document.getElementById("div2"); var div3=document.getElementById("div3"); function insertAfter(new1,old1)&#123; var parent=old1.parentNode if (old1==parent.lastChild) &#123; parent.appendChild(new1) &#125; else&#123; parent.insertBefore(new1,old1.nextSibling) &#125; &#125; insertAfter(p,div2);&lt;/script&gt; 注意：createElement()创建元素节点；parentNode父节点；childNodes子节点集；firstChild第一个子节点；lastChild最后个子节点；previousSibling前一个兄弟节点；nextSibling后一个兄弟节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM 基础知识总结]]></title>
      <url>%2F2015%2F02%2F25%2F05-jsDOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1.获取当前文档URL的两个方法：12alert(document.URL); alert(location.href) 2.childNodeschildNodes返回的是所有子节点的集合（不包括子节点的子节点）。这些子节点中可能有元素节点、文本节点、注释节点，而不可能有属性节点（属性节点不是任何节点的子节点）。节点有三个属性：nodeName、nodeType、nodeValue。 我们可以通过节点的nodeName属性获取节点名，nodeType属性获取节点类型，nodeValue属性获取节点值。只有元素节点有子节点（子节点可能是元素节点、文本节点以及注释节点），而元素节点、文本节点、注释节点都有父节点，属性节点既没有子节点又没有父节点。script标签属于元素节点，script标签内所有代码（包括注释内容）为script标签的一个子节点， 并且此子节点类型为文本节点。即： script标签内只有一个子节点，为文本节点，注释内容不被认为是一个注释节点，而被认为是此文本节点的一部分。 注意节点的属性与元素的属性的区别： ①节点有三个属性：nodeName、nodeType、nodeValue。 ②在HTML中，元素和元素的属性都属于节点。 例题：遍历一个元素节点的所有属性节点名、值、类型。 12345&lt;input id="ipt" type="text" value="123" name="qer" /&gt; var ipt=document.getElementById("ipt").attributes; for (n=0;n&lt;ipt.length;n++) &#123; document.write(ipt[n].nodeName+";"+ipt[n].nodeValue+';'+ipt[n].nodeType+"&lt;br /&gt;") &#125; 注意：①ipt为input元素节点的属性节点集合。②for(){}循环遍历input每一个属性节点的名、值、类型。3.一切事物皆对象，对象都拥有属性和方法。属性即对象带有的一些特定性质，方法即对象的使用方式。获取属性（特定性质）不加括号，调用方法（使用方式）要加括号。4.把某个元素节点的非空白子节点存入数组123456789101112131415161718192021var html=document.getElementsByTagName("html")[0];var son=html.childNodes;var arr=new Array();for (n=0;n&lt;html.childNodes.length;n++) &#123; if (son[n].nodeType==3&amp;&amp;son[n].nodeValue.trim()=='') &#123; continue; &#125; else&#123; arr.push(son[n]); &#125;; &#125;;alert(arr.length) //弹出2注意：字符串.trim()方法，将字符串两边的空格删去。字符串.trimleft()方法，将字符串左边的空格删去。字符串.trimright()方法，将字符串右边的空格删去。例子：var str=" ad2cd "alert(str.length);//弹出13alert(str.trimLeft().length);//弹出11alert(str.trimRight().length);//弹出7alert(str.trim().length);//弹出5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BOM 基础知识总结]]></title>
      <url>%2F2015%2F02%2F17%2F04-jsBOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1.window对象的conform方法：显示一个带有提示信息、确认和取消按钮的对话框。语法：conform(“提示信息”)注意：如果将conform方法赋值给一个变量，当处理该对话框时，若点击确认，该变量为布尔数据类型true，若点击取消，该变量为布尔数据类型false。12345678910111213141516原理：var a=confirm(); //弹出对话框alert(a); //若对话框点击确认，则弹出ture；若对话框点击取消，则弹出false。例子：&lt;p id="pid"&gt;文字&lt;/p&gt; &lt;button id="btn"&gt;删除&lt;/button&gt;&lt;script&gt;var p=document.getElementById("pid"),btn=document.getElementById("btn");btn.addEventListener("click",demo)function demo()&#123;var a=confirm("确认删除吗？") if(a)&#123; p.innerHTML=""; alert("已经删除") &#125;&#125; 注意：DOM2级事件处理程序中addEventListener(“事件”,demo)，demo不可加括号。2.script标签中的代码无法操作(document)文档流上方的HTML元素对象。3.计时器123456789101112131415161718192021222324&lt;p id="pid"&gt;&lt;/p&gt;&lt;button onclick="demo2()"&gt;按钮&lt;/button&gt;function demo()&#123; p=document.getElementById("pid") var d=new Date(); var year=d.getFullYear(); var month=d.getMonth(); var dates=d.getDate(); //获得的是日期号 var h=d.getHours(); var m=d.getMinutes(); var s=d.getSeconds(); var fulltime=year+"年"+month+"月"+dates+"日"+h+":"+m+":"+s p.innerHTML=fulltime;&#125;var begin=setInterval(demo,1000); //计时器中调用函数的第一种写法，无括号无引号。 //在句柄中添加函数只能用这种方法，无括号无引号。 // setInterval("demo()",1000); //计时器中调用函数的第二种写法，有括号有引号。 // setInterval(function()&#123;demo()&#125;,1000); //计时器中调用函数的第三种写法。function demo2()&#123; clearInterval(begin)&#125; 注意：var begin=setInterval(demo,1000); begin是统计setInterval函数的个数用的，指明是第几个setInterval函数。在本例题中，begin===1。如果不声明begin变量，clearInterval(begin)中的begin改为1，代码运行效果不变。4.BOM浏览器对象模型(Browser Object Model)：使用对象描述了浏览器的各部分内容。Window对象、计时器、History对象、Location对象、Screen对象、Navigator对象、弹出窗口、Cookies。页面刷新: location.reload(); DOM文档对象模型(Document Object Model)：当一个html页面加载到浏览器的时候，那么浏览器会为每个标签都创建一个对应的对象描述该标签的所有信息，那么我们看到的网页信息实际上就是看到了这些标签对象的信息，如果我们需要操作页面数据，那么我们就可以通过这些标签对象进行操作。 5.Location对象用来更改当前页面的URL123456&lt;button id="btn1"&gt;按钮&lt;/button&gt;document.getElementById("btn1").addEventListener("click",demo)//在句柄中添加函数只能用这种方法，无括号无引号。function demo()&#123; location.href="new_file.html"&#125; 6.在服务器通过location.search获取数据（键值对）。12345678910111213141516171819 &lt;form method="get" action="new_file.html"&gt; &lt;input type="text" name="usename" /&gt; &lt;input type="password" name="passord" /&gt; &lt;input type="submit" /&gt; &lt;/form&gt;页面2(new_file.html)代码： &lt;button id="btn"&gt;按钮&lt;/button&gt; var btn= document.getElementById("btn"); btn.addEventListener("click", demo) function demo() &#123; var a = location.search //取得当前 URL的查询字串(?符号及后面的部分)（字符串格式） alert(a) var b = a.substring(1)//截取从第二位开始的查询字串(substring:子串、子链) var c = b.split("&amp;") //将查询字串以"&amp;"为分隔符分隔为数组 for (i = 0; i &lt; c.length; i++) &#123; alert(c[i]) //逐个弹出每一个数组元素 alert(c[i].split("=")[1])//弹出每一个键值对的结果 &#125;; &#125;; JavaScript中的For…in 声明1234567 for...in 声明用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。for ... in 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作。语法：for (变量 in 对象)&#123;代码块&#125;注意：for ... in 循环在遍历数组时，变量指每一个数组的下标值，对象[变量]指每一个数组元素。for ... in 循环在遍历对象时，变量指每一个对象的属性名，对象[变量]指每一个对象的属性值。例子：获取浏览器(window)对象导航(navigator)子对象的所有属性名和属性值。for (i in window.navigator) &#123; document.write(i+"="+window.navigator[i]+"&lt;br /&gt;")&#125;; 8.B/S结构(Browser/Serve，浏览器/服务器模式)、C/S结构(Client/Serve，客户端和服务器模式)：B/S结构是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。C/S结构是软件系统体系结构，通过它可以充分利用两端环境的优势，将任务合理分配到Client客户端和Serve服务端来实现。 9.document.images：获取文档上所有的img标签的集合。123456789 document.images[0]：获取文档上第1个img标签。 document.forms：获取文档上所有的form标签的集合。 document.forms[n]：获取文档上第n+1个form标签。//举例： &lt;img src="img/shili.jpg" /&gt; &lt;script&gt; document.images[0].style.border="3px solid red" &lt;/script&gt;//注意：这种写法只适用于forms、images两种情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-数组]]></title>
      <url>%2F2015%2F02%2F13%2F03-js%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[数组arry1.随机产生一个大于0小于1的数值(0&lt;x&lt;1)方法为：1Math.random() 随机产生一个大于0小于n的数值(0&lt;x&lt;n)方法为：1Math.random()*n 随机产生一个大于0小于n+1的数值(0&lt;x&lt;n+1)方法为：1Math.random()*(n+1) 随机产生一个从0到n-1的整数(0&lt;=x&lt;=n-1)方法为：1Math.floor(Math.random()*n) Math.round(Math.random()*(n-1)) 随机产生一个从0到n的整数(0&lt;=x&lt;=n)方法为：1Math.floor(Math.random()*(n+1)) Math.round(Math.random()*n) 2.数组的属性：length属性表示数组的长度，即其中元素的个数。3. 数组的常用方法：（1）concat()连结两个或更多的数组12345concatenate连结 语法：数组1.concat(数组2,数组3,……数组n) 返回值：连结后的新数组 var arr1=[1,"2",4]; var arr2=[5,new Object,6] var arr3=arr1.concat(arr2) document.write(arr3+"&lt;br /&gt;") //页面输出返回值1,2,4,5,[object Object],6 （2）join()将数组的所有元素放入一个字符串，元素通过指定的字符串进行分隔。（即是将数组转化为一个字符串，数组元素之间可设置分隔符）。123456语法：数组.join(“分隔符”)，若不设置分隔符join()，默认分隔符为逗号。 返回值：生成的字符串 var arr=[1,"2",4,5,new Object,6] var arr1=arr.join("") document.write(arr1)//页面输出新字符串及返回值 //1245[object Object]6，无空格。 document.write(typeof arr) //页面输出Object 3）pop()删除并返回数组最后一个元素12345语法：数组.pop() 删除数组最后一个元素，并返回数组最后一个元素 返回值：最后一个元素 var arr = [1, "2", 4, 5, new Object, 6] var arr1 = arr.pop() document.write(arr1+"&lt;br/&gt;") //页面输出返回值6。 document.write(arr) //页面输出新数组1,2,4,5,[object Object]。 （4）push()向数组的末尾添加一个或更多的元素，并返回新的长度1234567语法：数组.push(元素1，元素2，……) 返回值：新的长度 例子： var arr=[1,"2",4,5,new Object,6] var arr1=arr.push("12",new Object,3) document.write(arr1+"&lt;br/&gt;") //页面输出返回值9。 document.write(arr) //页面输出新数组1,2,4,5,[object Object],6,12,[object Object],3 含义：arr添加了三个元素，而arr1为数值9。 （5）reverse()颠倒数组中元素的顺序123456789101112语法：数组.reverse() 返回值：颠倒后的数组 例子： var arr=[1,"2",4,5,new Object,6] arr.reverse(); document.write(arr) //页面输出6,[object Object],5,4,2,1 注意：数组.reverse()语法正确，而字符串.reverse()语法错误。 注解：字符串转化为数组的方法为：字符串.split(“分隔符”) 例子： var str=window.prompt("请输入数值") //prompt提示框输入字符串str。 var arr=str.split(""); //字符串str转化为数值arr。 arr.reverse(); //颠倒数组arr元素中的顺序。 var str2=arr.join("") //将数组arr转化为字符串str2，并且没有分隔符。document.write(str+"&lt;br /&gt;"); //页面输出字符串str：546285753 document.write(arr+"&lt;br /&gt;"); //页面输出颠倒顺序后的数组arr：3,5,7,5,8,2,6,4,5 document.write(str2) //页面输出字符串str2：357582645 （6）shift()删除并返回数组的第一个元素语法：数组.shift() 删除数组第一个元素。 返回值：删除的第一个元素。var arr = [&quot;a&quot;, &quot;2&quot;, 4, 5, new Object, 6] var arr1 = arr.shift() document.write(arr1+&quot; “) //页面输出返回值a。 document.write(arr) //页面输出新数组2,4,5,[object Object],6。 （7）slice()从某个指定的数组返回选定的元素，不会修改数组。123456语法：数组.slice(选择元素的起始底，选择元素的结束次序) 返回值：选择的元素。 var arr = ["a", "2", 4, 5, new Object, 6] var arr1 = arr.slice(2,5) document.write(arr1+"&lt;br/&gt;") //页面输出返回值4, 5, new Object document.write(arr) //页面输出a,4,5,[object Object],6。 注意：该方法并不会修改数组。 （8）sort()对数组的元素进行排序1234语法：数组.sort() 返回值：排序之后的数组。 var arr = [21,11,-4,9,45,6] arr.sort() document.write(arr+"&lt;br /&gt;") //页面输出-4,11,21,45,6,9 var t=function (a,b)&#123; return a-b &#125;; arr.sort(t); document.write(arr) //页面输出-4,6,9,11,21,45 （9）splice()从数组中添加/删除元素，然后返回被删除的元素。12345语法：数组.splice(删除元素的起始底，删除元素的个数，增加的元素1，增加的元素2……) 返回值：被删除的元素。 var arr = ["a", "2", 4, 5, new Object, 6] var arr1 = arr.splice(2,1,"bc",3) document.write(arr1+"&lt;br /&gt;")//页面输出4 document.write(arr) //页面输出a,2,bc,3,5,[object Object],6。 （10）tostring()将数组转化为字符串1234语法：数组.tostring() 返回值：字符串 var arr = ["a","2",new Object,6] arr.toString() document.write(arr) //页面输出a,2,[object Object],6 （11）unshift()向数组开头添加一个或更多元素，并返回新的长度12语法：数组.unshift(“元素1”,”元素2”,”元素3”) 返回值：新的长度 var arr = ["a","2",new Object,6] var arr1=arr.unshift(1,"bc") document.write(arr1+"&lt;br /&gt;")//页面输出6 document.write(arr) //页面输出1,bc,a,2,[object Object],6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础语法]]></title>
      <url>%2F2015%2F02%2F09%2F02-js%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[js基本语法1.prompt(“信息提示”,”默认值”)。prompt：提示注意：prompt(“信息提示”,”默认值”)，即使输入number类型内容，提交的也是string数据类型。2.switch条件语句中的条件表达式(case 值:)默认的判断过程是全等（===）判断，即认为”3”不全等于3。（在if else条件语句中，==不识别数据类型，===识别数据类型。）例子：123var a="2" switch(a)&#123; case 2: //不满足该条件表达式alert("a"+"==="+2); //不执行，不弹出 break;default: alert("a"+"!=="+2) //弹出a！==2 &#125; 3.if else条件语句从前向后执行，当满足第一个条件表达式时，执行对应的条件语句，之后跳出if else条件语句。此时即使后面仍有满足条件的表达式，也不再执行相对应的条件语句。4.switch条件语句从前向后执行，break语句用来跳出当前switch语句。switch条件语句中不同的条件表达式(case 值:)之间为或(||)的关系。如果满足一个条件表达(case 值:)式的条件语句后没有break语句，则执行该条件语句和之后第一个break语句之前的所有条件语句。注意：由于不同的条件表达式(case 值:)之间为或(||)的关系，认为该条件表达式和之后第一个break之前所有的条件表达式返回true，执行之间所有的条件语句。5.求1！+2！+3！+……+10！123456var n=1 ;var num= 1;var sum= 0;while(n&lt;=10)&#123; num=num*n;sum=sum+num; n++; &#125;alert(sum) 注意：写循环体时最重要的是明确每一个变量所代表的含义（在Hbuild中标注每一个变量的含义）。求和循环核心三变量：循环次数n、各项数值num、各项总和sum。for循环1234567var num=初值;var sum=0;for (n=1;n&lt;=循环次数;n++) &#123; num=表达式; sum=sum+num; &#125; alert(sum)&#125; 过程：①项数赋值循环次数。②求解各项数值表达式。③初值赋值。while循环1234567var n=1 ;var num=初值;var sum= 0;while(n&lt;=循环次数)&#123; num=表达式; sum=sum+num; n++;&#125;alert(sum) 过程：①项数赋值循环次数。②求解各项数值表达式。③初值赋值。do while循环####12345678var n=1;var num= 初值;var sum=0; do&#123; num=表达式; sum=sum+num; n=n+1; &#125;while(n&lt;=循环次数) alert(sum) 过程：①项数赋值循环次数。②求解各项数值表达式。③初值赋值。6.求和 sum=2+22+222+22222+…..+2222222212345678var n = 1;var num = 0;var sum = 0;while (n &lt;= 8) &#123; num = num*10+2; sum = sum + num; n++; &#125; alert(sum)&#125; 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。7.求和 sum=1/1!+1/2!+1/3!+1/4!+1/5!+…..+1/10!12345678var n = 1;var num = 1;var sum = 0;while (n &lt;=10 ) &#123; num =1/((1/num)*n); sum = sum + num; n++;&#125;alert(sum) 8.有一只猴子吃一堆果子，已知每天吃昨天剩下的果子的一半再多一个，直到第10天才吃完。问原来这堆果子有多少个？12345678910var n = 1;var num = 0;var sum = 0;while (n &lt;= 10) &#123; num =2*num+2; sum = sum + num; n++; &#125; alert(num)&#125; 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。9.国际象棋棋盘有64格，若在第1格放1粒谷；第2格放2粒谷；第3格放4粒谷；第4格放8粒谷……如此一直放到第64格。假设2000000粒谷有一顿重，问需要多少吨谷才够放？123456789var n = 1;var num = 0.5;var sum = 0;while (n &lt;= 64) &#123; num =num*2; sum = sum + num; n++; &#125; alert(sum)&#125; 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。10.求出1-100之间所有除以3余1的数,并求和12345678910var n=1;var num=1;var sum=0;while (n&lt;=100)&#123; num=n; if(num%3==1)&#123; sum=sum+num; &#125; n++; &#125;alert(sum); 过程：①循环次数赋值。②求解各项数值表达式。③初值赋值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript简介]]></title>
      <url>%2F2015%2F01%2F12%2F01-js%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[js基本特点1. 弱类型语言：没有明确的数据类型声明，所有变量都用var声明。2. 脚本语言：计算机可以直接执行源代码。3. JavaScript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言,可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。4. JavaScript——最流行的脚本语言:弱类型语言、动态性语言、解释性语言。5. JavaScript 组成：ECMAScript（语法）、DOM（文档对象模型）、BOM（浏览器对象模型）。 BOM（Browser Object Model）js初识代码（文档输出的几种写法）1234567document.write("Hello JavaScript1&lt;br/&gt;");//文档输出时换行的第一种写法。 document.write("Hello JavaScript2"+"&lt;br /&gt;");//文档输出时换行的第二种写法。document.writeln("Hello JavaScript2"); //文档输出时文本后加一个空格。alert("Hello\nJavaScript"); //弹出对话框时换行的第一种方法。alert("Hello"+"\n"+"JavaScript"); //弹出对话框时换行的第二种方法。console.log("Hello\nJavaScript"); //控制台输出文本换行的第一种写法。 console.log("Hello"+"\n"+"JavaScript"); //控制台输出文本换行的第二种写法。 注意：①window是一个全局对象，在书写时一般省略。例如：window.document；window.alert；window.consolejs运算符简介加号（+）有两种含义：①算数运算符；②字符串拼接；当相加的各数据全部为数字数据类型时，加号的含义为算数运算符。当相加的各数据有字符串数据类型时，加号的含义在第一个字符串之前为算数运算符，在第一个字符串之后为字符串拼接（括号中的数字为加法）。例子：12var a=2+3+15+"12"+4+"abc"+(2+3)+9+1;console.log(a);//20124abc591; 注意：字符串数据类型必须用双引号包裹script标签script标签可以放在文档的任何位置，通常放在head中，建议写在body之前，使浏览器先加载标签，再运行JavaScript代码，增强用户体验。 script标签必须成对出现，同一个页面中可以出现多对，且从上往下执行。 如果一个script标签用来引入外部JavaScript文件，此标签内不能再写JavaScript代码。(标签内部写代码的时候注意script不能有src属性，值为空也不可以) script标签的type属性可以不写，也可以写text/javascript属性值，这种写法不标准，但是最通用，浏览器支持较好，也可以写application/javascript属性值，这种写法浏览器支持不是特别好。 script标签的async用来设置脚本是否支持异步，默认属性值为“false”，可定义“true”或“async”。 外链JavaScript文件的script标签添加async属性，使下一个script标签的起始执行时间无需等待当前script标签的外链JavaScript执行结束。 标识符（变量、函数、属性的名字，或者函数的参数）JavaScript的变量用来保存值或者表达式，变量的值是可以改变。变量就是计算机在内存中申请一块空间地址的别名，便于程序员识别。变量三要素：①变量名 ②变量值 ③变量类型####（1）当一个变量已声明未赋值时，变量的值为undefined。 （2）变量可以先声明后赋值，也可以声明和赋值同时进行。var a;a=10; （3）可以同时声明多个变量，变量之间用逗号隔开。var a=10,b=37,c=53; （4）所有变量都用var声明，没有严格区分数据类型，属于弱类型语言。 （5）用typeof 来确定变量的数据类型。 var a=1;alert(typeof a);//等价于alert(typeof(a)); （6）语法中可以省略var。 注意：当声明一个变量时，如果没有给他赋值，无法明确知道变量的类型，这样的语言称作弱类型语言。JavaScript是一种弱类型的语言，把所有的变量类型都用var声明，而不用明确声明数据类型，只有真正给变量赋值时，变量的类型才决定，也就是说变量的数据类型是由变量的值的类型来决定的。js数据类型ECMAScript中有5种基本数据类型：undefined、null、boolean、number 、string,还有一种复杂数据类型。 也叫引用数据类型object和函数类型function，当然，function也可以看做object类型。ECMAScript不支持 任何创建自定义类型的机制，所有值都成为以上7 种数据类型之一。在JavaScript中，用typeof()检测变量 的数据类型。对于值或变量使用typeof 操作符会返回如下字符串： 123456789101112131415undefined： 未定义 boolean ：布尔值 string： 字符串 number ：数值 object： 对象或null function ：函数 基本数据类型：数字、字符串、布尔、未定义 var a=1; alert(typeof(a)); //返回number 数字var a="1"; alert(typeof a); //返回string 字符串 var a; alert(typeof (a)) //返回undefined 未定义 var a=false; alert(typeof(a)); //返回boolean 布尔 引用数据类型：函数、数组、对象、日期、空 var a=null; alert(typeof(a)); //返回object 空 var a=function ()&#123;&#125;; alert(typeof a); //返回function（属于object的一种） var a=new Array ; alert(typeof a); //返回object 数组 var a=new Object(); alert(typeof a); //返回object 对象 关键字在JavaScript语法中有特定用途，不能用作标识符，保留字未来可能成为关键字。]]></content>
    </entry>

    
  
  
</search>
